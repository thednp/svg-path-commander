{"version":3,"file":"svg-path-commander.js","sources":["../node_modules/.pnpm/@thednp+dommatrix@2.0.10/node_modules/@thednp/dommatrix/dist/dommatrix.mjs","../src/options/options.ts","../src/parser/paramsCount.ts","../src/parser/finalizeSegment.ts","../src/parser/error.ts","../src/parser/scanFlag.ts","../src/parser/isDigit.ts","../src/parser/invalidPathValue.ts","../src/parser/scanParam.ts","../src/parser/isSpace.ts","../src/parser/skipSpaces.ts","../src/parser/isPathCommand.ts","../src/parser/isDigitStart.ts","../src/parser/isArcCommand.ts","../src/parser/isMoveCommand.ts","../src/parser/scanSegment.ts","../src/parser/pathParser.ts","../src/parser/parsePathString.ts","../src/process/absolutizeSegment.ts","../src/process/iterate.ts","../src/convert/pathToAbsolute.ts","../src/process/relativizeSegment.ts","../src/convert/pathToRelative.ts","../src/math/rotateVector.ts","../src/process/arcToCubic.ts","../src/process/quadToCubic.ts","../src/math/midPoint.ts","../src/process/lineToCubic.ts","../src/process/segmentToCubic.ts","../src/process/normalizeSegment.ts","../src/parser/paramsParser.ts","../src/convert/pathToCurve.ts","../src/math/roundTo.ts","../src/convert/pathToString.ts","../src/math/distanceSquareRoot.ts","../src/math/lineTools.ts","../src/math/arcTools.ts","../src/math/bezier.ts","../src/math/cubicTools.ts","../src/math/quadTools.ts","../src/math/polygonTools.ts","../src/util/distanceEpsilon.ts","../src/process/normalizePath.ts","../src/util/getPointAtLength.ts","../src/util/getTotalLength.ts","../src/util/getPropertiesAtLength.ts","../src/util/getPropertiesAtPoint.ts","../src/util/getClosestPoint.ts","../src/util/getPathArea.ts","../src/util/getDrawDirection.ts","../src/util/getPathBBox.ts","../src/util/getSegmentAtLength.ts","../src/util/getSegmentOfPoint.ts","../src/util/isPathArray.ts","../src/util/isAbsoluteArray.ts","../src/util/isNormalizedArray.ts","../src/util/isCurveArray.ts","../src/util/isPointInStroke.ts","../src/util/isRelativeArray.ts","../src/util/isValidPath.ts","../src/util/shapeParams.ts","../src/util/isElement.ts","../src/util/shapeToPathArray.ts","../src/util/shapeToPath.ts","../src/process/getSVGMatrix.ts","../src/process/shortenSegment.ts","../src/process/roundSegment.ts","../src/process/optimizePath.ts","../src/process/projection2d.ts","../src/process/reverseCurve.ts","../src/process/reversePath.ts","../src/process/roundPath.ts","../src/process/splitCubic.ts","../src/process/splitPath.ts","../src/process/transformPath.ts","../src/index.ts"],"sourcesContent":["var Z = Object.defineProperty;\nvar z = (s, t, e) => t in s ? Z(s, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : s[t] = e;\nvar p = (s, t, e) => z(s, typeof t != \"symbol\" ? t + \"\" : t, e);\nconst $ = {\n  a: 1,\n  b: 0,\n  c: 0,\n  d: 1,\n  e: 0,\n  f: 0,\n  m11: 1,\n  m12: 0,\n  m13: 0,\n  m14: 0,\n  m21: 0,\n  m22: 1,\n  m23: 0,\n  m24: 0,\n  m31: 0,\n  m32: 0,\n  m33: 1,\n  m34: 0,\n  m41: 0,\n  m42: 0,\n  m43: 0,\n  m44: 1,\n  is2D: !0,\n  isIdentity: !0\n}, E = (s) => (s instanceof Float64Array || s instanceof Float32Array || Array.isArray(s) && s.every((t) => typeof t == \"number\")) && [6, 16].some((t) => s.length === t), P = (s) => s instanceof DOMMatrix || s instanceof y || typeof s == \"object\" && Object.keys($).every((t) => s && t in s), g = (s) => {\n  const t = new y(), e = Array.from(s);\n  if (!E(e))\n    throw TypeError(\n      `CSSMatrix: \"${e.join(\",\")}\" must be an array with 6/16 numbers.`\n    );\n  // istanbul ignore else @preserve\n  if (e.length === 16) {\n    const [\n      n,\n      i,\n      r,\n      a,\n      l,\n      m,\n      h,\n      c,\n      u,\n      f,\n      w,\n      o,\n      d,\n      A,\n      M,\n      b\n    ] = e;\n    t.m11 = n, t.a = n, t.m21 = l, t.c = l, t.m31 = u, t.m41 = d, t.e = d, t.m12 = i, t.b = i, t.m22 = m, t.d = m, t.m32 = f, t.m42 = A, t.f = A, t.m13 = r, t.m23 = h, t.m33 = w, t.m43 = M, t.m14 = a, t.m24 = c, t.m34 = o, t.m44 = b;\n  } else if (e.length === 6) {\n    const [n, i, r, a, l, m] = e;\n    t.m11 = n, t.a = n, t.m12 = i, t.b = i, t.m21 = r, t.c = r, t.m22 = a, t.d = a, t.m41 = l, t.e = l, t.m42 = m, t.f = m;\n  }\n  return t;\n}, X = (s) => {\n  if (P(s))\n    return g([\n      s.m11,\n      s.m12,\n      s.m13,\n      s.m14,\n      s.m21,\n      s.m22,\n      s.m23,\n      s.m24,\n      s.m31,\n      s.m32,\n      s.m33,\n      s.m34,\n      s.m41,\n      s.m42,\n      s.m43,\n      s.m44\n    ]);\n  throw TypeError(\n    `CSSMatrix: \"${JSON.stringify(s)}\" is not a DOMMatrix / CSSMatrix / JSON compatible object.`\n  );\n}, O = (s) => {\n  if (typeof s != \"string\")\n    throw TypeError(`CSSMatrix: \"${JSON.stringify(s)}\" is not a string.`);\n  const t = String(s).replace(/\\s/g, \"\");\n  let e = new y();\n  const n = `CSSMatrix: invalid transform string \"${s}\"`;\n  return t.split(\")\").filter((i) => i).forEach((i) => {\n    const [r, a] = i.split(\"(\");\n    if (!a) throw TypeError(n);\n    const l = a.split(\",\").map(\n      (o) => o.includes(\"rad\") ? parseFloat(o) * (180 / Math.PI) : parseFloat(o)\n    ), [m, h, c, u] = l, f = [m, h, c], w = [m, h, c, u];\n    if (r === \"perspective\" && m && [h, c].every((o) => o === void 0))\n      e.m34 = -1 / m;\n    else if (r.includes(\"matrix\") && [6, 16].includes(l.length) && l.every((o) => !Number.isNaN(+o))) {\n      const o = l.map((d) => Math.abs(d) < 1e-6 ? 0 : d);\n      e = e.multiply(g(o));\n    } else if (r === \"translate3d\" && f.every((o) => !Number.isNaN(+o)))\n      e = e.translate(m, h, c);\n    else if (r === \"translate\" && m && c === void 0)\n      e = e.translate(m, h || 0, 0);\n    else if (r === \"rotate3d\" && w.every((o) => !Number.isNaN(+o)) && u)\n      e = e.rotateAxisAngle(m, h, c, u);\n    else if (r === \"rotate\" && m && [h, c].every((o) => o === void 0))\n      e = e.rotate(0, 0, m);\n    else if (r === \"scale3d\" && f.every((o) => !Number.isNaN(+o)) && f.some((o) => o !== 1))\n      e = e.scale(m, h, c);\n    else if (r === \"scale\" && !Number.isNaN(m) && m !== 1 && c === void 0) {\n      const d = Number.isNaN(+h) ? m : h;\n      e = e.scale(m, d, 1);\n    } else if (r === \"skew\" && (m || !Number.isNaN(m) && h) && c === void 0)\n      e = e.skew(m, h || 0);\n    else if ([\"translate\", \"rotate\", \"scale\", \"skew\"].some(\n      (o) => r.includes(o)\n    ) && /[XYZ]/.test(r) && m && [h, c].every((o) => o === void 0))\n      if (r === \"skewX\" || r === \"skewY\")\n        e = e[r](m);\n      else {\n        const o = r.replace(/[XYZ]/, \"\"), d = r.replace(o, \"\"), A = [\"X\", \"Y\", \"Z\"].indexOf(d), M = o === \"scale\" ? 1 : 0, b = [\n          A === 0 ? m : M,\n          A === 1 ? m : M,\n          A === 2 ? m : M\n        ];\n        e = e[o](...b);\n      }\n    else\n      throw TypeError(n);\n  }), e;\n}, x = (s, t) => t ? [s.a, s.b, s.c, s.d, s.e, s.f] : [\n  s.m11,\n  s.m12,\n  s.m13,\n  s.m14,\n  s.m21,\n  s.m22,\n  s.m23,\n  s.m24,\n  s.m31,\n  s.m32,\n  s.m33,\n  s.m34,\n  s.m41,\n  s.m42,\n  s.m43,\n  s.m44\n], Y = (s, t, e) => {\n  const n = new y();\n  return n.m41 = s, n.e = s, n.m42 = t, n.f = t, n.m43 = e, n;\n}, F = (s, t, e) => {\n  const n = new y(), i = Math.PI / 180, r = s * i, a = t * i, l = e * i, m = Math.cos(r), h = -Math.sin(r), c = Math.cos(a), u = -Math.sin(a), f = Math.cos(l), w = -Math.sin(l), o = c * f, d = -c * w;\n  n.m11 = o, n.a = o, n.m12 = d, n.b = d, n.m13 = u;\n  const A = h * u * f + m * w;\n  n.m21 = A, n.c = A;\n  const M = m * f - h * u * w;\n  return n.m22 = M, n.d = M, n.m23 = -h * c, n.m31 = h * w - m * u * f, n.m32 = h * f + m * u * w, n.m33 = m * c, n;\n}, T = (s, t, e, n) => {\n  const i = new y(), r = Math.sqrt(s * s + t * t + e * e);\n  if (r === 0)\n    return i;\n  const a = s / r, l = t / r, m = e / r, h = n * (Math.PI / 360), c = Math.sin(h), u = Math.cos(h), f = c * c, w = a * a, o = l * l, d = m * m, A = 1 - 2 * (o + d) * f;\n  i.m11 = A, i.a = A;\n  const M = 2 * (a * l * f + m * c * u);\n  i.m12 = M, i.b = M, i.m13 = 2 * (a * m * f - l * c * u);\n  const b = 2 * (l * a * f - m * c * u);\n  i.m21 = b, i.c = b;\n  const k = 1 - 2 * (d + w) * f;\n  return i.m22 = k, i.d = k, i.m23 = 2 * (l * m * f + a * c * u), i.m31 = 2 * (m * a * f + l * c * u), i.m32 = 2 * (m * l * f - a * c * u), i.m33 = 1 - 2 * (w + o) * f, i;\n}, I = (s, t, e) => {\n  const n = new y();\n  return n.m11 = s, n.a = s, n.m22 = t, n.d = t, n.m33 = e, n;\n}, v = (s, t) => {\n  const e = new y();\n  if (s) {\n    const n = s * Math.PI / 180, i = Math.tan(n);\n    e.m21 = i, e.c = i;\n  }\n  if (t) {\n    const n = t * Math.PI / 180, i = Math.tan(n);\n    e.m12 = i, e.b = i;\n  }\n  return e;\n}, R = (s) => v(s, 0), D = (s) => v(0, s), N = (s, t) => {\n  const e = t.m11 * s.m11 + t.m12 * s.m21 + t.m13 * s.m31 + t.m14 * s.m41, n = t.m11 * s.m12 + t.m12 * s.m22 + t.m13 * s.m32 + t.m14 * s.m42, i = t.m11 * s.m13 + t.m12 * s.m23 + t.m13 * s.m33 + t.m14 * s.m43, r = t.m11 * s.m14 + t.m12 * s.m24 + t.m13 * s.m34 + t.m14 * s.m44, a = t.m21 * s.m11 + t.m22 * s.m21 + t.m23 * s.m31 + t.m24 * s.m41, l = t.m21 * s.m12 + t.m22 * s.m22 + t.m23 * s.m32 + t.m24 * s.m42, m = t.m21 * s.m13 + t.m22 * s.m23 + t.m23 * s.m33 + t.m24 * s.m43, h = t.m21 * s.m14 + t.m22 * s.m24 + t.m23 * s.m34 + t.m24 * s.m44, c = t.m31 * s.m11 + t.m32 * s.m21 + t.m33 * s.m31 + t.m34 * s.m41, u = t.m31 * s.m12 + t.m32 * s.m22 + t.m33 * s.m32 + t.m34 * s.m42, f = t.m31 * s.m13 + t.m32 * s.m23 + t.m33 * s.m33 + t.m34 * s.m43, w = t.m31 * s.m14 + t.m32 * s.m24 + t.m33 * s.m34 + t.m34 * s.m44, o = t.m41 * s.m11 + t.m42 * s.m21 + t.m43 * s.m31 + t.m44 * s.m41, d = t.m41 * s.m12 + t.m42 * s.m22 + t.m43 * s.m32 + t.m44 * s.m42, A = t.m41 * s.m13 + t.m42 * s.m23 + t.m43 * s.m33 + t.m44 * s.m43, M = t.m41 * s.m14 + t.m42 * s.m24 + t.m43 * s.m34 + t.m44 * s.m44;\n  return g([\n    e,\n    n,\n    i,\n    r,\n    a,\n    l,\n    m,\n    h,\n    c,\n    u,\n    f,\n    w,\n    o,\n    d,\n    A,\n    M\n  ]);\n};\nclass y {\n  /**\n   * @constructor\n   * @param init accepts all parameter configurations:\n   * * valid CSS transform string,\n   * * CSSMatrix/DOMMatrix instance,\n   * * a 6/16 elements *Array*.\n   */\n  constructor(t) {\n    return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.e = 0, this.f = 0, this.m11 = 1, this.m12 = 0, this.m13 = 0, this.m14 = 0, this.m21 = 0, this.m22 = 1, this.m23 = 0, this.m24 = 0, this.m31 = 0, this.m32 = 0, this.m33 = 1, this.m34 = 0, this.m41 = 0, this.m42 = 0, this.m43 = 0, this.m44 = 1, t ? this.setMatrixValue(t) : this;\n  }\n  /**\n   * A `Boolean` whose value is `true` if the matrix is the identity matrix. The identity\n   * matrix is one in which every value is 0 except those on the main diagonal from top-left\n   * to bottom-right corner (in other words, where the offsets in each direction are equal).\n   *\n   * @return the current property value\n   */\n  get isIdentity() {\n    return this.m11 === 1 && this.m12 === 0 && this.m13 === 0 && this.m14 === 0 && this.m21 === 0 && this.m22 === 1 && this.m23 === 0 && this.m24 === 0 && this.m31 === 0 && this.m32 === 0 && this.m33 === 1 && this.m34 === 0 && this.m41 === 0 && this.m42 === 0 && this.m43 === 0 && this.m44 === 1;\n  }\n  /**\n   * A `Boolean` flag whose value is `true` if the matrix was initialized as a 2D matrix\n   * and `false` if the matrix is 3D.\n   *\n   * @return the current property value\n   */\n  get is2D() {\n    return this.m31 === 0 && this.m32 === 0 && this.m33 === 1 && this.m34 === 0 && this.m43 === 0 && this.m44 === 1;\n  }\n  /**\n   * The `setMatrixValue` method replaces the existing matrix with one computed\n   * in the browser. EG: `matrix(1,0.25,-0.25,1,0,0)`\n   *\n   * The method accepts any *Array* values, the result of\n   * `DOMMatrix` instance method `toFloat64Array()` / `toFloat32Array()` calls\n   * or `CSSMatrix` instance method `toArray()`.\n   *\n   * This method expects valid *matrix()* / *matrix3d()* string values, as well\n   * as other transform functions like *translateX(10px)*.\n   *\n   * @param source\n   * @return the matrix instance\n   */\n  setMatrixValue(t) {\n    return typeof t == \"string\" && t.length && t !== \"none\" ? O(t) : Array.isArray(t) || t instanceof Float64Array || t instanceof Float32Array ? g(t) : typeof t == \"object\" ? X(t) : this;\n  }\n  /**\n   * Returns a *Float32Array* containing elements which comprise the matrix.\n   * The method can return either the 16 elements or the 6 elements\n   * depending on the value of the `is2D` parameter.\n   *\n   * @param is2D *Array* representation of the matrix\n   * @return an *Array* representation of the matrix\n   */\n  toFloat32Array(t) {\n    return Float32Array.from(x(this, t));\n  }\n  /**\n   * Returns a *Float64Array* containing elements which comprise the matrix.\n   * The method can return either the 16 elements or the 6 elements\n   * depending on the value of the `is2D` parameter.\n   *\n   * @param is2D *Array* representation of the matrix\n   * @return an *Array* representation of the matrix\n   */\n  toFloat64Array(t) {\n    return Float64Array.from(x(this, t));\n  }\n  /**\n   * Creates and returns a string representation of the matrix in `CSS` matrix syntax,\n   * using the appropriate `CSS` matrix notation.\n   *\n   * matrix3d *matrix3d(m11, m12, m13, m14, m21, ...)*\n   * matrix *matrix(a, b, c, d, e, f)*\n   *\n   * @return a string representation of the matrix\n   */\n  toString() {\n    const { is2D: t } = this, e = this.toFloat64Array(t).join(\", \");\n    return `${t ? \"matrix\" : \"matrix3d\"}(${e})`;\n  }\n  /**\n   * Returns a JSON representation of the `CSSMatrix` instance, a standard *Object*\n   * that includes `{a,b,c,d,e,f}` and `{m11,m12,m13,..m44}` properties as well\n   * as the `is2D` & `isIdentity` properties.\n   *\n   * The result can also be used as a second parameter for the `fromMatrix` static method\n   * to load values into another matrix instance.\n   *\n   * @return an *Object* with all matrix values.\n   */\n  toJSON() {\n    const { is2D: t, isIdentity: e } = this;\n    return { ...this, is2D: t, isIdentity: e };\n  }\n  /**\n   * The Multiply method returns a new CSSMatrix which is the result of this\n   * matrix multiplied by the passed matrix, with the passed matrix to the right.\n   * This matrix is not modified.\n   *\n   * @param m2 CSSMatrix\n   * @return The resulted matrix.\n   */\n  multiply(t) {\n    return N(this, t);\n  }\n  /**\n   * The translate method returns a new matrix which is this matrix post\n   * multiplied by a translation matrix containing the passed values. If the z\n   * component is undefined, a 0 value is used in its place. This matrix is not\n   * modified.\n   *\n   * @param x X component of the translation value.\n   * @param y Y component of the translation value.\n   * @param z Z component of the translation value.\n   * @return The resulted matrix\n   */\n  translate(t, e, n) {\n    const i = t;\n    let r = e, a = n;\n    return typeof r > \"u\" && (r = 0), typeof a > \"u\" && (a = 0), N(this, Y(i, r, a));\n  }\n  /**\n   * The scale method returns a new matrix which is this matrix post multiplied by\n   * a scale matrix containing the passed values. If the z component is undefined,\n   * a 1 value is used in its place. If the y component is undefined, the x\n   * component value is used in its place. This matrix is not modified.\n   *\n   * @param x The X component of the scale value.\n   * @param y The Y component of the scale value.\n   * @param z The Z component of the scale value.\n   * @return The resulted matrix\n   */\n  scale(t, e, n) {\n    const i = t;\n    let r = e, a = n;\n    return typeof r > \"u\" && (r = t), typeof a > \"u\" && (a = 1), N(this, I(i, r, a));\n  }\n  /**\n   * The rotate method returns a new matrix which is this matrix post multiplied\n   * by each of 3 rotation matrices about the major axes, first X, then Y, then Z.\n   * If the y and z components are undefined, the x value is used to rotate the\n   * object about the z axis, as though the vector (0,0,x) were passed. All\n   * rotation values are in degrees. This matrix is not modified.\n   *\n   * @param rx The X component of the rotation, or Z if Y and Z are null.\n   * @param ry The (optional) Y component of the rotation value.\n   * @param rz The (optional) Z component of the rotation value.\n   * @return The resulted matrix\n   */\n  rotate(t, e, n) {\n    let i = t, r = e || 0, a = n || 0;\n    return typeof t == \"number\" && typeof e > \"u\" && typeof n > \"u\" && (a = i, i = 0, r = 0), N(this, F(i, r, a));\n  }\n  /**\n   * The rotateAxisAngle method returns a new matrix which is this matrix post\n   * multiplied by a rotation matrix with the given axis and `angle`. The right-hand\n   * rule is used to determine the direction of rotation. All rotation values are\n   * in degrees. This matrix is not modified.\n   *\n   * @param x The X component of the axis vector.\n   * @param y The Y component of the axis vector.\n   * @param z The Z component of the axis vector.\n   * @param angle The angle of rotation about the axis vector, in degrees.\n   * @return The resulted matrix\n   */\n  rotateAxisAngle(t, e, n, i) {\n    if ([t, e, n, i].some((r) => Number.isNaN(+r)))\n      throw new TypeError(\"CSSMatrix: expecting 4 values\");\n    return N(this, T(t, e, n, i));\n  }\n  /**\n   * Specifies a skew transformation along the `x-axis` by the given angle.\n   * This matrix is not modified.\n   *\n   * @param angle The angle amount in degrees to skew.\n   * @return The resulted matrix\n   */\n  skewX(t) {\n    return N(this, R(t));\n  }\n  /**\n   * Specifies a skew transformation along the `y-axis` by the given angle.\n   * This matrix is not modified.\n   *\n   * @param angle The angle amount in degrees to skew.\n   * @return The resulted matrix\n   */\n  skewY(t) {\n    return N(this, D(t));\n  }\n  /**\n   * Specifies a skew transformation along both the `x-axis` and `y-axis`.\n   * This matrix is not modified.\n   *\n   * @param angleX The X-angle amount in degrees to skew.\n   * @param angleY The angle amount in degrees to skew.\n   * @return The resulted matrix\n   */\n  skew(t, e) {\n    return N(this, v(t, e));\n  }\n  /**\n   * Transforms a specified vector using the matrix, returning a new\n   * {x,y,z,w} Tuple *Object* comprising the transformed vector.\n   * Neither the matrix nor the original vector are altered.\n   *\n   * The method is equivalent with `transformPoint()` method\n   * of the `DOMMatrix` constructor.\n   *\n   * @param t Tuple with `{x,y,z,w}` components\n   * @return the resulting Tuple\n   */\n  transformPoint(t) {\n    const e = this.m11 * t.x + this.m21 * t.y + this.m31 * t.z + this.m41 * t.w, n = this.m12 * t.x + this.m22 * t.y + this.m32 * t.z + this.m42 * t.w, i = this.m13 * t.x + this.m23 * t.y + this.m33 * t.z + this.m43 * t.w, r = this.m14 * t.x + this.m24 * t.y + this.m34 * t.z + this.m44 * t.w;\n    return t instanceof DOMPoint ? new DOMPoint(e, n, i, r) : {\n      x: e,\n      y: n,\n      z: i,\n      w: r\n    };\n  }\n}\np(y, \"Translate\", Y), p(y, \"Rotate\", F), p(y, \"RotateAxisAngle\", T), p(y, \"Scale\", I), p(y, \"SkewX\", R), p(y, \"SkewY\", D), p(y, \"Skew\", v), p(y, \"Multiply\", N), p(y, \"fromArray\", g), p(y, \"fromMatrix\", X), p(y, \"fromString\", O), p(y, \"toArray\", x), p(y, \"isCompatibleArray\", E), p(y, \"isCompatibleObject\", P);\nexport {\n  y as default\n};\n//# sourceMappingURL=dommatrix.mjs.map\n","import { Options } from \"../interface\";\n\n/** SVGPathCommander default options */\nconst defaultOptions: Options = {\n  origin: [0, 0, 0],\n  round: 4,\n};\n\nexport default defaultOptions;\n","/** Segment params length */\nconst paramsCount = {\n  a: 7,\n  c: 6,\n  h: 1,\n  l: 2,\n  m: 2,\n  r: 4,\n  q: 4,\n  s: 4,\n  t: 2,\n  v: 1,\n  z: 0,\n};\n\nexport default paramsCount;\n","import paramsCount from \"./paramsCount\";\nimport PathParser from \"./pathParser\";\nimport type { PathCommand, PathSegment, RelativeCommand } from \"../types\";\n\n/**\n * Breaks the parsing of a pathString once a segment is finalized.\n *\n * @param path the `PathParser` instance\n */\nconst finalizeSegment = (path: PathParser) => {\n  let pathCommand = path.pathValue[path.segmentStart] as PathCommand;\n  let relativeCommand = pathCommand.toLowerCase() as RelativeCommand;\n  const { data } = path;\n\n  while (data.length >= paramsCount[relativeCommand]) {\n    // overloaded `moveTo`\n    // https://github.com/rveciana/svg-path-properties/blob/master/src/parse.ts\n    if (relativeCommand === \"m\" && data.length > 2) {\n      path.segments.push(\n        [pathCommand as PathCommand | number].concat(\n          data.splice(0, 2) as number[],\n        ) as PathSegment,\n      );\n      relativeCommand = \"l\";\n      pathCommand = pathCommand === \"m\" ? \"l\" : \"L\";\n    } else {\n      path.segments.push(\n        [pathCommand as PathCommand | number].concat(\n          data.splice(0, paramsCount[relativeCommand]) as number[],\n        ) as PathSegment,\n      );\n    }\n\n    if (!paramsCount[relativeCommand]) {\n      break;\n    }\n  }\n};\nexport default finalizeSegment;\n","const error = \"SVGPathCommander Error\";\nexport default error;\n","import error from \"./error\";\nimport type PathParser from \"./pathParser\";\n\n/**\n * Validates an A (arc-to) specific path command value.\n * Usually a `large-arc-flag` or `sweep-flag`.\n *\n * @param path the `PathParser` instance\n */\nconst scanFlag = (path: PathParser) => {\n  const { index, pathValue } = path;\n  const code = pathValue.charCodeAt(index);\n\n  if (code === 0x30 /* 0 */) {\n    path.param = 0;\n    path.index += 1;\n    return;\n  }\n\n  if (code === 0x31 /* 1 */) {\n    path.param = 1;\n    path.index += 1;\n    return;\n  }\n\n  path.err = `${error}: invalid Arc flag \"${\n    pathValue[index]\n  }\", expecting 0 or 1 at index ${index}`;\n};\n\nexport default scanFlag;\n","import { DigitNumber } from \"../types\";\n\n/**\n * Checks if a character is a digit.\n *\n * @param code the character to check\n * @returns check result\n */\nconst isDigit = (code: number): code is DigitNumber => {\n  return code >= 48 && code <= 57; // 0..9\n};\nexport default isDigit;\n","const invalidPathValue = \"Invalid path value\";\nexport default invalidPathValue;\n","import isDigit from \"./isDigit\";\nimport invalidPathValue from \"./invalidPathValue\";\nimport error from \"./error\";\nimport type PathParser from \"./pathParser\";\n\n/**\n * Validates every character of the path string,\n * every path command, negative numbers or floating point numbers.\n *\n * @param path the `PathParser` instance\n */\nconst scanParam = (path: PathParser) => {\n  const { max, pathValue, index: start } = path;\n  let index = start;\n  let zeroFirst = false;\n  let hasCeiling = false;\n  let hasDecimal = false;\n  let hasDot = false;\n  let ch;\n\n  if (index >= max) {\n    path.err =\n      `${error}: ${invalidPathValue} at index ${index}, \"pathValue\" is missing param`;\n    return;\n  }\n  ch = pathValue.charCodeAt(index);\n\n  if (ch === 0x2b /* + */ || ch === 0x2d /* - */) {\n    index += 1;\n    // ch = (index < max) ? pathValue.charCodeAt(index) : 0;\n    ch = pathValue.charCodeAt(index);\n  }\n\n  // This logic is shamelessly borrowed from Esprima\n  // https://github.com/ariya/esprimas\n  if (!isDigit(ch) && ch !== 0x2e /* . */) {\n    // path.err = 'SvgPath: param should start with 0..9 or `.` (at pos ' + index + ')';\n    path.err = `${error}: ${invalidPathValue} at index ${index}, \"${\n      pathValue[index]\n    }\" is not a number`;\n    return;\n  }\n\n  if (ch !== 0x2e /* . */) {\n    zeroFirst = ch === 0x30 /* 0 */;\n    index += 1;\n\n    ch = pathValue.charCodeAt(index);\n\n    if (zeroFirst && index < max) {\n      // decimal number starts with '0' such as '09' is illegal.\n      if (ch && isDigit(ch)) {\n        // path.err = 'SvgPath: numbers started with `0` such as `09`\n        // are illegal (at pos ' + start + ')';\n        path.err = `${error}: ${invalidPathValue} at index ${start}, \"${\n          pathValue[start]\n        }\" illegal number`;\n        return;\n      }\n    }\n\n    while (index < max && isDigit(pathValue.charCodeAt(index))) {\n      index += 1;\n      hasCeiling = true;\n    }\n\n    ch = pathValue.charCodeAt(index);\n  }\n\n  if (ch === 0x2e /* . */) {\n    hasDot = true;\n    index += 1;\n    while (isDigit(pathValue.charCodeAt(index))) {\n      index += 1;\n      hasDecimal = true;\n    }\n\n    ch = pathValue.charCodeAt(index);\n  }\n\n  if (ch === 0x65 /* e */ || ch === 0x45 /* E */) {\n    if (hasDot && !hasCeiling && !hasDecimal) {\n      path.err = `${error}: ${invalidPathValue} at index ${index}, \"${\n        pathValue[index]\n      }\" invalid float exponent`;\n      return;\n    }\n\n    index += 1;\n\n    ch = pathValue.charCodeAt(index);\n\n    if (ch === 0x2b /* + */ || ch === 0x2d /* - */) {\n      index += 1;\n    }\n    if (index < max && isDigit(pathValue.charCodeAt(index))) {\n      while (index < max && isDigit(pathValue.charCodeAt(index))) {\n        index += 1;\n      }\n    } else {\n      path.err = `${error}: ${invalidPathValue} at index ${index}, \"${\n        pathValue[index]\n      }\" invalid integer exponent`;\n      return;\n    }\n  }\n\n  path.index = index;\n  path.param = +path.pathValue.slice(start, index);\n};\nexport default scanParam;\n","import type { SpaceNumber } from \"../types\";\n\n/**\n * Checks if the character is a space.\n *\n * @param ch the character to check\n * @returns check result\n */\n\nconst isSpace = (ch: number): ch is SpaceNumber => {\n  const allSpaces = [\n    // Special spaces\n    0x1680,\n    0x180e,\n    0x2000,\n    0x2001,\n    0x2002,\n    0x2003,\n    0x2004,\n    0x2005,\n    0x2006,\n    0x2007,\n    0x2008,\n    0x2009,\n    0x200a,\n    0x202f,\n    0x205f,\n    0x3000,\n    0xfeff,\n    // Line terminators\n    0x0a,\n    0x0d,\n    0x2028,\n    0x2029,\n    // White spaces\n    0x20,\n    0x09,\n    0x0b,\n    0x0c,\n    0xa0,\n  ];\n\n  return allSpaces.includes(ch);\n};\nexport default isSpace;\n","import isSpace from \"./isSpace\";\nimport type PathParser from \"./pathParser\";\n\n/**\n * Points the parser to the next character in the\n * path string every time it encounters any kind of\n * space character.\n *\n * @param path the `PathParser` instance\n */\nconst skipSpaces = (path: PathParser) => {\n  const { pathValue, max } = path;\n  while (path.index < max && isSpace(pathValue.charCodeAt(path.index))) {\n    path.index += 1;\n  }\n};\nexport default skipSpaces;\n","import type { PathCommandNumber } from \"../types\";\n\n/**\n * Checks if the character is a path command.\n *\n * @param code the character to check\n * @returns check result\n */\nconst isPathCommand = (code: number): code is PathCommandNumber => {\n  // eslint-disable-next-line no-bitwise -- Impossible to satisfy\n  switch (code | 0x20) {\n    case 0x6d /* m */:\n    case 0x7a /* z */:\n    case 0x6c /* l */:\n    case 0x68 /* h */:\n    case 0x76 /* v */:\n    case 0x63 /* c */:\n    case 0x73 /* s */:\n    case 0x71 /* q */:\n    case 0x74 /* t */:\n    case 0x61 /* a */:\n      // case 0x72/* r */:\n      return true;\n    default:\n      return false;\n  }\n};\nexport default isPathCommand;\n","import isDigit from \"./isDigit\";\nimport type { DigitNumber } from \"../types\";\n\n/**\n * Checks if the character is or belongs to a number.\n * [0-9]|+|-|.\n *\n * @param code the character to check\n * @returns check result\n */\nconst isDigitStart = (\n  code: number,\n): code is DigitNumber | 0x2b | 0x2d | 0x2e => {\n  return isDigit(code) /* 0..9 */ || code === 0x2b /* + */ ||\n    code === 0x2d /* - */ || code === 0x2e; /* . */\n};\nexport default isDigitStart;\n","/**\n * Checks if the character is an A (arc-to) path command.\n *\n * @param code the character to check\n * @returns check result\n */\nconst isArcCommand = (code: number): code is 0x61 => {\n  // eslint-disable-next-line no-bitwise -- Impossible to satisfy\n  return (code | 0x20) === 0x61;\n};\nexport default isArcCommand;\n","/**\n * Checks if the character is a MoveTo command.\n *\n * @param code the character to check\n * @returns check result\n */\nconst isMoveCommand = (code: number): code is 0x6d | 0x4d => {\n  // eslint-disable-next-line no-bitwise -- Impossible to satisfy\n  switch (code | 0x20) {\n    case 0x6d /* m */:\n    case 0x4d /* M */:\n      return true;\n    default:\n      return false;\n  }\n};\nexport default isMoveCommand;\n","import finalizeSegment from \"./finalizeSegment\";\nimport paramCounts from \"./paramsCount\";\nimport scanFlag from \"./scanFlag\";\nimport scanParam from \"./scanParam\";\nimport skipSpaces from \"./skipSpaces\";\nimport isPathCommand from \"./isPathCommand\";\nimport isDigitStart from \"./isDigitStart\";\nimport isArcCommand from \"./isArcCommand\";\nimport isMoveCommand from \"./isMoveCommand\";\nimport invalidPathValue from \"./invalidPathValue\";\nimport error from \"./error\";\n\nimport type PathParser from \"./pathParser\";\nimport type { PathSegment, RelativeCommand } from \"../types\";\n\n/**\n * Scans every character in the path string to determine\n * where a segment starts and where it ends.\n *\n * @param path the `PathParser` instance\n */\nconst scanSegment = (path: PathParser) => {\n  const { max, pathValue, index, segments } = path;\n  const cmdCode = pathValue.charCodeAt(index);\n  const reqParams =\n    paramCounts[pathValue[index].toLowerCase() as RelativeCommand];\n\n  path.segmentStart = index;\n\n  // segments always start with a path command\n  if (!isPathCommand(cmdCode)) {\n    path.err = `${error}: ${invalidPathValue} \"${\n      pathValue[index]\n    }\" is not a path command at index ${index}`;\n    return;\n  }\n\n  // after a Z segment, we only expect a MoveTo path command\n  const lastSegment = segments[segments.length - 1] as PathSegment | undefined;\n  if (\n    !isMoveCommand(cmdCode) && lastSegment?.[0]?.toLocaleLowerCase() === \"z\"\n  ) {\n    path.err = `${error}: ${invalidPathValue} \"${\n      pathValue[index]\n    }\" is not a MoveTo path command at index ${index}`;\n    return;\n  }\n\n  path.index += 1;\n  skipSpaces(path);\n\n  path.data = [];\n\n  if (!reqParams) {\n    // Z\n    finalizeSegment(path);\n    return;\n  }\n\n  for (;;) {\n    for (let i = reqParams; i > 0; i -= 1) {\n      if (isArcCommand(cmdCode) && (i === 3 || i === 4)) scanFlag(path);\n      else scanParam(path);\n\n      if (path.err.length) {\n        return;\n      }\n      path.data.push(path.param);\n\n      skipSpaces(path);\n\n      // after ',' param is mandatory\n      if (\n        path.index < max && pathValue.charCodeAt(path.index) === 0x2c /* , */\n      ) {\n        path.index += 1;\n        skipSpaces(path);\n      }\n    }\n\n    if (path.index >= path.max) {\n      break;\n    }\n\n    // Stop on next segment\n    if (!isDigitStart(pathValue.charCodeAt(path.index))) {\n      break;\n    }\n  }\n\n  finalizeSegment(path);\n};\nexport default scanSegment;\n","import type { PathArray, PathSegment } from \"../types\";\n\n/**\n * The `PathParser` is used by the `parsePathString` static method\n * to generate a `pathArray`.\n *\n * @param pathString\n */\nexport default class PathParser {\n  declare segments: PathArray | PathSegment[];\n  declare pathValue: string;\n  declare max: number;\n  declare index: number;\n  declare param: number;\n  declare segmentStart: number;\n  declare data: (string | number)[];\n  declare err: string;\n\n  constructor(pathString: string) {\n    this.segments = [];\n    this.pathValue = pathString;\n    this.max = pathString.length;\n    this.index = 0;\n    this.param = 0.0;\n    this.segmentStart = 0;\n    this.data = [];\n    this.err = \"\";\n  }\n}\n","import scanSegment from \"./scanSegment\";\nimport skipSpaces from \"./skipSpaces\";\nimport PathParser from \"./pathParser\";\nimport type { PathArray } from \"../types\";\n\n/**\n * Parses a path string value and returns an array\n * of segments we like to call `pathArray`.\n *\n * @param pathInput the string to be parsed\n * @returns the resulted `pathArray` or error string\n */\nconst parsePathString = <T extends PathArray>(pathInput: string | T) => {\n  if (typeof pathInput !== \"string\") {\n    return pathInput.slice(0) as typeof pathInput;\n  }\n\n  const path = new PathParser(pathInput);\n\n  skipSpaces(path);\n\n  while (path.index < path.max && !path.err.length) {\n    scanSegment(path);\n  }\n\n  if (path?.err.length) {\n    throw TypeError(path.err);\n  }\n\n  return path.segments as PathArray;\n};\n\nexport default parsePathString;\n","import type {\n  AbsoluteCommand,\n  AbsoluteSegment,\n  ASegment,\n  CSegment,\n  HSegment,\n  LSegment,\n  MSegment,\n  PathSegment,\n  QSegment,\n  SSegment,\n  TSegment,\n  VSegment,\n} from \"../types\";\n\n/**\n * Returns an absolute segment of a `PathArray` object.\n *\n * @param segment the segment object\n * @param index the segment index\n * @param lastX the last known X value\n * @param lastY the last known Y value\n * @returns the absolute segment\n */\nconst absolutizeSegment = (\n  segment: PathSegment,\n  index: number,\n  lastX: number,\n  lastY: number,\n) => {\n  const [pathCommand] = segment;\n  const absCommand = pathCommand.toUpperCase() as AbsoluteCommand;\n  const isAbsolute = absCommand === pathCommand;\n\n  /* istanbul ignore else @preserve */\n  if (index === 0 || isAbsolute) return segment as MSegment | AbsoluteSegment;\n  // const values = segment.slice(1) as number[];\n  if (absCommand === \"A\") {\n    return [\n      absCommand,\n      segment[1],\n      segment[2],\n      segment[3],\n      segment[4],\n      segment[5],\n      (segment as ASegment)[6] + lastX,\n      (segment as ASegment)[7] + lastY,\n    ] as ASegment;\n  } else if (absCommand === \"V\") {\n    return [absCommand, (segment as VSegment)[1] + lastY] as VSegment;\n  } else if (absCommand === \"H\") {\n    return [absCommand, (segment as HSegment)[1] + lastX] as HSegment;\n  } else if (absCommand === \"L\") {\n    return [\n      absCommand,\n      (segment as LSegment)[1] + lastX,\n      (segment as LSegment)[2] + lastY,\n    ] as LSegment;\n  } else {\n    // use brakets for `eslint: no-case-declaration`\n    // https://stackoverflow.com/a/50753272/803358\n    const absValues = [] as number[];\n    const seglen = segment.length;\n    for (let j = 1; j < seglen; j += 1) {\n      absValues.push((segment[j] as number) + (j % 2 ? lastX : lastY));\n    }\n    // for c, s, q, t\n    return [absCommand as typeof absCommand | number].concat(absValues) as\n      | MSegment\n      | QSegment\n      | TSegment\n      | SSegment\n      | CSegment;\n  }\n};\nexport default absolutizeSegment;\n","// import paramsParser from '../parser/paramsParser';\nimport type {\n  AbsoluteCommand,\n  IteratorCallback,\n  PathArray,\n  PathCommand,\n  PathSegment,\n} from \"../types\";\n\nconst iterate = <T extends PathArray>(\n  path: PathArray,\n  iterator: IteratorCallback,\n) => {\n  let pathLen = path.length;\n  let segment: PathSegment;\n  let pathCommand = \"M\" as PathCommand;\n  let absCommand = \"M\" as AbsoluteCommand;\n  let isRelative = false;\n  let x = 0;\n  let y = 0;\n  let mx = 0;\n  let my = 0;\n  let segLen = 0;\n\n  for (let i = 0; i < pathLen; i += 1) {\n    segment = path[i];\n    [pathCommand] = segment;\n    segLen = segment.length;\n    absCommand = pathCommand.toUpperCase() as AbsoluteCommand;\n    isRelative = absCommand !== pathCommand;\n\n    const iteratorResult = iterator(segment, i, x, y);\n    // some methods like getPointAtLength would like to break\n    // when task is complete\n    if (iteratorResult === false) {\n      break;\n    }\n\n    // segment = path[i];\n    if (absCommand === \"Z\") {\n      x = mx;\n      y = my;\n    } else if (absCommand === \"H\") {\n      x = (segment[1] as number) + (isRelative ? x : 0);\n    } else if (absCommand === \"V\") {\n      y = (segment[1] as number) + (isRelative ? y : 0);\n    } else {\n      x = (segment[segLen - 2] as number) + (isRelative ? x : 0);\n      y = (segment[segLen - 1] as number) + (isRelative ? y : 0);\n\n      if (absCommand === \"M\") {\n        mx = x;\n        my = y;\n      }\n    }\n\n    if (iteratorResult) {\n      path[i] = iteratorResult;\n      if (iteratorResult[0] === \"C\") {\n        pathLen = path.length;\n      }\n    }\n  }\n  return path as T;\n};\n\nexport default iterate;\n","import parsePathString from \"../parser/parsePathString\";\nimport absolutizeSegment from \"../process/absolutizeSegment\";\nimport type { AbsoluteArray, PathArray } from \"../types\";\nimport iterate from \"../process/iterate\";\n\n/**\n * Parses a path string value or object and returns an array\n * of segments, all converted to absolute values.\n *\n * @param pathInput the path string | object\n * @returns the resulted `pathArray` with absolute values\n */\nconst pathToAbsolute = (pathInput: string | PathArray) => {\n  const path = parsePathString(pathInput);\n\n  return iterate<AbsoluteArray>(path, absolutizeSegment);\n};\nexport default pathToAbsolute;\n","import type {\n  aSegment,\n  cSegment,\n  hSegment,\n  lSegment,\n  MSegment,\n  PathSegment,\n  qSegment,\n  RelativeCommand,\n  RelativeSegment,\n  sSegment,\n  tSegment,\n  vSegment,\n} from \"../types\";\n\n/**\n * Returns a relative segment of a `PathArray` object.\n *\n * @param segment the segment object\n * @param index the segment index\n * @param lastX the last known X value\n * @param lastY the last known Y value\n * @returns the relative segment\n */\nconst relativizeSegment = (\n  segment: PathSegment,\n  index: number,\n  lastX: number,\n  lastY: number,\n) => {\n  const [pathCommand] = segment;\n  const relCommand = pathCommand.toLowerCase() as RelativeCommand;\n  const isRelative = pathCommand === relCommand;\n\n  /* istanbul ignore else @preserve */\n  if (index === 0 || isRelative) return segment as MSegment | RelativeSegment;\n\n  if (relCommand === \"a\") {\n    return [\n      relCommand,\n      segment[1],\n      segment[2],\n      segment[3],\n      segment[4],\n      segment[5],\n      (segment as aSegment)[6] - lastX,\n      (segment as aSegment)[7] - lastY,\n    ] as aSegment;\n  } else if (relCommand === \"v\") {\n    return [relCommand, (segment as vSegment)[1] - lastY] as vSegment;\n  } else if (relCommand === \"h\") {\n    return [relCommand, (segment as hSegment)[1] - lastX] as hSegment;\n  } else if (relCommand === \"l\") {\n    return [\n      relCommand,\n      (segment as lSegment)[1] - lastX,\n      (segment as lSegment)[2] - lastY,\n    ] as lSegment;\n  } else {\n    // use brakets for `eslint: no-case-declaration`\n    // https://stackoverflow.com/a/50753272/803358\n    const relValues = [] as number[];\n    const seglen = segment.length;\n    for (let j = 1; j < seglen; j += 1) {\n      relValues.push((segment[j] as number) - (j % 2 ? lastX : lastY));\n    }\n    // for c, s, q, t\n    return [relCommand as RelativeCommand | number].concat(relValues) as\n      | qSegment\n      | tSegment\n      | sSegment\n      | cSegment;\n  }\n};\n\nexport default relativizeSegment;\n","import type { PathArray, RelativeArray } from \"../types\";\nimport parsePathString from \"../parser/parsePathString\";\nimport iterate from \"../process/iterate\";\nimport relativizeSegment from \"../process/relativizeSegment\";\n\n/**\n * Parses a path string value or object and returns an array\n * of segments, all converted to relative values.\n *\n * @param pathInput the path string | object\n * @returns the resulted `pathArray` with relative values\n */\nconst pathToRelative = (pathInput: string | PathArray): RelativeArray => {\n  const path = parsePathString(pathInput);\n\n  return iterate<RelativeArray>(path, relativizeSegment);\n};\nexport default pathToRelative;\n","/**\n * Returns an {x,y} vector rotated by a given\n * angle in radian.\n *\n * @param x the initial vector x\n * @param y the initial vector y\n * @param rad the radian vector angle\n * @returns the rotated vector\n */\nconst rotateVector = (\n  x: number,\n  y: number,\n  rad: number,\n): { x: number; y: number } => {\n  const { sin, cos } = Math;\n  const X = x * cos(rad) - y * sin(rad);\n  const Y = x * sin(rad) + y * cos(rad);\n  return { x: X, y: Y };\n};\n\nexport default rotateVector;\n","import rotateVector from \"../math/rotateVector\";\n\n/**\n * Converts A (arc-to) segments to C (cubic-bezier-to).\n *\n * For more information of where this math came from visit:\n * http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n *\n * @param X1 the starting x position\n * @param Y1 the starting y position\n * @param RX x-radius of the arc\n * @param RY y-radius of the arc\n * @param angle x-axis-rotation of the arc\n * @param LAF large-arc-flag of the arc\n * @param SF sweep-flag of the arc\n * @param X2 the ending x position\n * @param Y2 the ending y position\n * @param recursive the parameters needed to split arc into 2 segments\n * @return the resulting cubic-bezier segment(s)\n */\nconst arcToCubic = (\n  X1: number,\n  Y1: number,\n  RX: number,\n  RY: number,\n  angle: number,\n  LAF: number,\n  SF: number,\n  X2: number,\n  Y2: number,\n  recursive?: [number, number, number, number],\n): number[] => {\n  let x1 = X1;\n  let y1 = Y1;\n  let rx = RX;\n  let ry = RY;\n  let x2 = X2;\n  let y2 = Y2;\n  // for more information of where this Math came from visit:\n  // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n  const d120 = (Math.PI * 120) / 180;\n\n  const rad = (Math.PI / 180) * (+angle || 0);\n  let res = [] as number[];\n  let xy;\n  let f1;\n  let f2;\n  let cx;\n  let cy;\n\n  if (!recursive) {\n    xy = rotateVector(x1, y1, -rad);\n    x1 = xy.x;\n    y1 = xy.y;\n    xy = rotateVector(x2, y2, -rad);\n    x2 = xy.x;\n    y2 = xy.y;\n\n    const x = (x1 - x2) / 2;\n    const y = (y1 - y2) / 2;\n    let h = (x * x) / (rx * rx) + (y * y) / (ry * ry);\n    if (h > 1) {\n      h = Math.sqrt(h);\n      rx *= h;\n      ry *= h;\n    }\n    const rx2 = rx * rx;\n    const ry2 = ry * ry;\n\n    const k = (LAF === SF ? -1 : 1) *\n      Math.sqrt(\n        Math.abs(\n          (rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x),\n        ),\n      );\n\n    cx = (k * rx * y) / ry + (x1 + x2) / 2;\n    cy = (k * -ry * x) / rx + (y1 + y2) / 2;\n    // eslint-disable-next-line no-bitwise -- Impossible to satisfy no-bitwise\n    f1 = Math.asin(((((y1 - cy) / ry) * 10 ** 9) >> 0) / 10 ** 9);\n    // eslint-disable-next-line no-bitwise -- Impossible to satisfy no-bitwise\n    f2 = Math.asin(((((y2 - cy) / ry) * 10 ** 9) >> 0) / 10 ** 9);\n\n    f1 = x1 < cx ? Math.PI - f1 : f1;\n    f2 = x2 < cx ? Math.PI - f2 : f2;\n    if (f1 < 0) f1 = Math.PI * 2 + f1;\n    if (f2 < 0) f2 = Math.PI * 2 + f2;\n    if (SF && f1 > f2) {\n      f1 -= Math.PI * 2;\n    }\n    if (!SF && f2 > f1) {\n      f2 -= Math.PI * 2;\n    }\n  } else {\n    [f1, f2, cx, cy] = recursive;\n  }\n  let df = f2 - f1;\n  if (Math.abs(df) > d120) {\n    const f2old = f2;\n    const x2old = x2;\n    const y2old = y2;\n    f2 = f1 + d120 * (SF && f2 > f1 ? 1 : -1);\n    x2 = cx + rx * Math.cos(f2);\n    y2 = cy + ry * Math.sin(f2);\n    res = arcToCubic(x2, y2, rx, ry, angle, 0, SF, x2old, y2old, [\n      f2,\n      f2old,\n      cx,\n      cy,\n    ]);\n  }\n  df = f2 - f1;\n  const c1 = Math.cos(f1);\n  const s1 = Math.sin(f1);\n  const c2 = Math.cos(f2);\n  const s2 = Math.sin(f2);\n  const t = Math.tan(df / 4);\n  const hx = (4 / 3) * rx * t;\n  const hy = (4 / 3) * ry * t;\n  const m1 = [x1, y1];\n  const m2 = [x1 + hx * s1, y1 - hy * c1];\n  const m3 = [x2 + hx * s2, y2 - hy * c2];\n  const m4 = [x2, y2];\n  m2[0] = 2 * m1[0] - m2[0];\n  m2[1] = 2 * m1[1] - m2[1];\n  if (recursive) {\n    return [m2[0], m2[1], m3[0], m3[1], m4[0], m4[1]].concat(res);\n  }\n  res = [m2[0], m2[1], m3[0], m3[1], m4[0], m4[1]].concat(res);\n  const newres = [];\n  for (let i = 0, ii = res.length; i < ii; i += 1) {\n    newres[i] = i % 2\n      ? rotateVector(res[i - 1], res[i], rad).y\n      : rotateVector(res[i], res[i + 1], rad).x;\n  }\n  return newres;\n};\nexport default arcToCubic;\n","/**\n * Converts a Q (quadratic-bezier) segment to C (cubic-bezier).\n *\n * @param x1 curve start x\n * @param y1 curve start y\n * @param qx control point x\n * @param qy control point y\n * @param x2 curve end x\n * @param y2 curve end y\n * @returns the cubic-bezier segment\n */\nconst quadToCubic = (\n  x1: number,\n  y1: number,\n  qx: number,\n  qy: number,\n  x2: number,\n  y2: number,\n): [number, number, number, number, number, number] => {\n  const r13 = 1 / 3;\n  const r23 = 2 / 3;\n  return [\n    r13 * x1 + r23 * qx, // cpx1\n    r13 * y1 + r23 * qy, // cpy1\n    r13 * x2 + r23 * qx, // cpx2\n    r13 * y2 + r23 * qy, // cpy2\n    x2,\n    y2, // x,y\n  ];\n};\nexport default quadToCubic;\n","import { PointTuple } from \"../types\";\n\n/**\n * Returns the coordinates of a specified distance\n * ratio between two points.\n *\n * @param a the first point coordinates\n * @param b the second point coordinates\n * @param t the ratio\n * @returns the midpoint coordinates\n */\nconst midPoint = (a: PointTuple, b: PointTuple, t: number): PointTuple => {\n  const [ax, ay] = a;\n  const [bx, by] = b;\n  return [ax + (bx - ax) * t, ay + (by - ay) * t];\n};\n\nexport default midPoint;\n","import midPoint from \"../math/midPoint\";\n\n/**\n * Converts an L (line-to) segment to C (cubic-bezier).\n *\n * @param x1 line start x\n * @param y1 line start y\n * @param x2 line end x\n * @param y2 line end y\n * @returns the cubic-bezier segment\n */\nconst lineToCubic = (x1: number, y1: number, x2: number, y2: number) => {\n  const c1 = midPoint([x1, y1], [x2, y2], 1.0 / 3.0);\n  const c2 = midPoint([x1, y1], [x2, y2], 2.0 / 3.0);\n  return [c1[0], c1[1], c2[0], c2[1], x2, y2];\n};\nexport default lineToCubic;\n","import arcToCubic from \"./arcToCubic\";\nimport quadToCubic from \"./quadToCubic\";\nimport lineToCubic from \"./lineToCubic\";\nimport type { CSegment, MSegment, PathSegment } from \"../types\";\nimport type { ParserParams } from \"../interface\";\n\n/**\n * Converts any segment to C (cubic-bezier).\n *\n * @param segment the source segment\n * @param params the source segment parameters\n * @returns the cubic-bezier segment\n */\nconst segmentToCubic = (segment: PathSegment, params: ParserParams) => {\n  const [pathCommand] = segment;\n  const values = segment.slice(1).map(Number);\n  const [x, y] = values;\n  // let args;\n  const { x1: px1, y1: py1, x: px, y: py } = params;\n\n  if (!\"TQ\".includes(pathCommand)) {\n    params.qx = null;\n    params.qy = null;\n  }\n\n  if (pathCommand === \"M\") {\n    params.x = x;\n    params.y = y;\n    return segment;\n  } else if (pathCommand === \"A\") {\n    return [\"C\" as string | number].concat(\n      arcToCubic(\n        px1,\n        py1,\n        values[0],\n        values[1],\n        values[2],\n        values[3],\n        values[4],\n        values[5],\n        values[6],\n      ),\n    ) as CSegment;\n  } else if (pathCommand === \"Q\") {\n    params.qx = x;\n    params.qy = y;\n    return [\"C\" as string | number].concat(\n      quadToCubic(px1, py1, values[0], values[1], values[2], values[3]),\n    ) as CSegment;\n  } else if (pathCommand === \"L\") {\n    return [\"C\" as string | number].concat(\n      lineToCubic(px1, py1, x, y),\n    ) as CSegment;\n  } else if (pathCommand === \"Z\") {\n    return [\"C\" as string | number].concat(\n      lineToCubic(px1, py1, px, py),\n    ) as CSegment;\n  }\n\n  return segment as MSegment | CSegment;\n};\nexport default segmentToCubic;\n","import type { ParserParams } from \"../interface\";\nimport type {\n  ASegment,\n  CSegment,\n  HSegment,\n  LSegment,\n  MSegment,\n  NormalSegment,\n  PathCommand,\n  PathSegment,\n  PointTuple,\n  QSegment,\n  VSegment,\n} from \"../types\";\n\n/**\n * Normalizes a single segment of a `pathArray` object.\n *\n * @param segment the segment object\n * @param params the normalization parameters\n * @returns the normalized segment\n */\nconst normalizeSegment = (segment: PathSegment, params: ParserParams) => {\n  const [pathCommand] = segment;\n  const absCommand = pathCommand.toUpperCase();\n  const isRelative = pathCommand !== absCommand;\n  const { x1: px1, y1: py1, x2: px2, y2: py2, x, y } = params;\n  const values = segment.slice(1) as number[];\n  let absValues = values.map((n, j) => n + (isRelative ? (j % 2 ? y : x) : 0));\n\n  if (!\"TQ\".includes(absCommand)) {\n    // optional but good to be cautious\n    params.qx = null;\n    params.qy = null;\n  }\n\n  // istanbul ignore else @preserve\n  if (absCommand === \"A\") {\n    absValues = values.slice(0, -2).concat(\n      values[5] + (isRelative ? x : 0),\n      values[6] + (isRelative ? y : 0),\n    );\n\n    return [\"A\" as PathCommand | number].concat(absValues) as ASegment;\n  } else if (absCommand === \"H\") {\n    return [\n      \"L\",\n      (segment as HSegment)[1] + (isRelative ? x : 0),\n      py1,\n    ] as LSegment;\n  } else if (absCommand === \"V\") {\n    return [\n      \"L\",\n      px1,\n      (segment as VSegment)[1] + (isRelative ? y : 0),\n    ] as LSegment;\n  } else if (absCommand === \"L\") {\n    return [\n      \"L\",\n      (segment as LSegment)[1] + (isRelative ? x : 0),\n      (segment as LSegment)[2] + (isRelative ? y : 0),\n    ] as LSegment;\n  } else if (absCommand === \"M\") {\n    return [\n      \"M\",\n      (segment as MSegment)[1] + (isRelative ? x : 0),\n      (segment as MSegment)[2] + (isRelative ? y : 0),\n    ] as MSegment;\n  } else if (absCommand === \"C\") {\n    return [\"C\" as PathCommand | number].concat(absValues) as CSegment;\n  } else if (absCommand === \"S\") {\n    const x1 = px1 * 2 - px2;\n    const y1 = py1 * 2 - py2;\n    params.x1 = x1;\n    params.y1 = y1;\n    return [\"C\", x1, y1].concat(absValues) as CSegment;\n  } else if (absCommand === \"T\") {\n    const qx = px1 * 2 - (params.qx ? params.qx : /* istanbul ignore next */ 0);\n    const qy = py1 * 2 - (params.qy ? params.qy : /* istanbul ignore next */ 0);\n    params.qx = qx;\n    params.qy = qy;\n    return [\"Q\", qx, qy].concat(absValues) as QSegment;\n  } else if (absCommand === \"Q\") {\n    const [nqx, nqy] = absValues as PointTuple;\n    params.qx = nqx;\n    params.qy = nqy;\n    return [\"Q\" as PathCommand | number].concat(absValues) as QSegment;\n  } else if (absCommand === \"Z\") {\n    return [\"Z\"] as NormalSegment;\n  }\n\n  // istanbul ignore next @preserve\n  return segment as NormalSegment;\n};\nexport default normalizeSegment;\n","import type { ParserParams } from \"../interface\";\n\nconst paramsParser: ParserParams = {\n  x1: 0,\n  y1: 0,\n  x2: 0,\n  y2: 0,\n  x: 0,\n  y: 0,\n  qx: null,\n  qy: null,\n};\n\nexport default paramsParser;\n","import segmentToCubic from \"../process/segmentToCubic\";\nimport { AbsoluteCommand, CSegment, CurveArray, PathArray } from \"../types\";\nimport iterate from \"../process/iterate\";\nimport parsePathString from \"../parser/parsePathString\";\nimport normalizeSegment from \"../process/normalizeSegment\";\nimport paramsParser from \"../parser/paramsParser\";\n\n/**\n * Parses a path string value or 'pathArray' and returns a new one\n * in which all segments are converted to cubic-bezier.\n *\n * In addition, un-necessary `Z` segment is removed if previous segment\n * extends to the `M` segment.\n *\n * @param pathInput the string to be parsed or 'pathArray'\n * @returns the resulted `pathArray` converted to cubic-bezier\n */\nconst pathToCurve = (pathInput: string | PathArray): CurveArray => {\n  const params = { ...paramsParser };\n  const path = parsePathString(pathInput);\n\n  return iterate<CurveArray>(path, (seg, index, lastX, lastY) => {\n    params.x = lastX;\n    params.y = lastY;\n    const normalSegment = normalizeSegment(seg, params);\n    let result = segmentToCubic(normalSegment, params);\n    const isLongArc = result[0] === \"C\" && result.length > 7;\n\n    if (isLongArc) {\n      path.splice(\n        index + 1,\n        0,\n        [\"C\" as AbsoluteCommand | number].concat(result.slice(7)) as CSegment,\n      );\n      result = result.slice(0, 7) as CSegment;\n    }\n\n    const seglen = result.length;\n    params.x1 = +result[seglen - 2];\n    params.y1 = +result[seglen - 1];\n    params.x2 = +result[seglen - 4] || params.x1;\n    params.y2 = +result[seglen - 3] || params.y1;\n\n    return result;\n  });\n};\nexport default pathToCurve;\n","const roundTo = (n: number, round: number) => {\n  const pow = round >= 1 ? 10 ** round : 1;\n\n  return round > 0 ? Math.round(n * pow) / pow : Math.round(n);\n};\n\nexport default roundTo;\n","import type { PathArray, PathSegment } from \"../types\";\nimport defaultOptions from \"../options/options\";\nimport roundTo from \"../math/roundTo\";\n\n/**\n * Returns a valid `d` attribute string value created\n * by rounding values and concatenating the `pathArray` segments.\n *\n * @param path the `pathArray` object\n * @param roundOption amount of decimals to round values to\n * @returns the concatenated path string\n */\nconst pathToString = (\n  path: PathArray,\n  roundOption?: number | \"off\",\n): string => {\n  const pathLen = path.length;\n  let { round } = defaultOptions;\n  let segment = path[0] as PathSegment;\n  let result = \"\";\n\n  // allow for ZERO decimals\n  round = roundOption === \"off\"\n    ? roundOption\n    : typeof roundOption === \"number\" && roundOption >= 0\n    ? roundOption\n    : typeof round === \"number\" && round >= 0\n    ? round\n    : /* istanbul ignore next @preserve */ \"off\";\n\n  for (let i = 0; i < pathLen; i += 1) {\n    segment = path[i];\n    const [pathCommand] = segment;\n    const values = segment.slice(1) as number[];\n    result += pathCommand;\n    if (round === \"off\") {\n      result += values.join(\" \");\n    } else {\n      let j = 0;\n      const valLen = values.length;\n      while (j < valLen) {\n        result += roundTo(values[j], round);\n        if (j !== valLen - 1) result += \" \";\n        j += 1;\n      }\n    }\n  }\n\n  return result;\n};\n\nexport default pathToString;\n","import { type PointTuple } from \"../types\";\n\n/**\n * Returns the square root of the distance\n * between two given points.\n *\n * @param a the first point coordinates\n * @param b the second point coordinates\n * @returns the distance value\n */\nconst distanceSquareRoot = (a: PointTuple, b: PointTuple) => {\n  return Math.sqrt(\n    (a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1]),\n  );\n};\n\nexport default distanceSquareRoot;\n","import midPoint from \"./midPoint\";\nimport distanceSquareRoot from \"./distanceSquareRoot\";\n\n/**\n * Returns length for line segments (MoveTo, LineTo).\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @returns the line segment length\n */\nconst getLineLength = (x1: number, y1: number, x2: number, y2: number) => {\n  return distanceSquareRoot([x1, y1], [x2, y2]);\n};\n\n/**\n * Returns a point along the line segments (MoveTo, LineTo).\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @param distance the distance to point in [0-1] range\n * @returns the point at length\n */\nconst getPointAtLineLength = (\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  distance?: number,\n) => {\n  let point = { x: x1, y: y1 };\n\n  /* istanbul ignore else @preserve */\n  if (typeof distance === \"number\") {\n    const length = distanceSquareRoot([x1, y1], [x2, y2]);\n    if (distance <= 0) {\n      point = { x: x1, y: y1 };\n    } else if (distance >= length) {\n      point = { x: x2, y: y2 };\n    } else {\n      const [x, y] = midPoint([x1, y1], [x2, y2], distance / length);\n      point = { x, y };\n    }\n  }\n  return point;\n};\n\n/**\n * Returns bounding box for line segments (MoveTo, LineTo).\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @param distance the distance to point in [0-1] range\n * @returns the extrema for line segments\n */\nconst getLineBBox = (x1: number, y1: number, x2: number, y2: number) => {\n  const { min, max } = Math;\n\n  return [min(x1, x2), min(y1, y2), max(x1, x2), max(y1, y2)] as [\n    number,\n    number,\n    number,\n    number,\n  ];\n};\n\nexport { getLineBBox, getLineLength, getPointAtLineLength };\n","import { getPointAtLineLength } from \"./lineTools\";\nimport type { Point, PointTuple } from \"../types\";\n\n/**\n * Returns the Arc segment length.\n * @param rx radius along X axis\n * @param ry radius along Y axis\n * @param theta the angle in radians\n * @returns the arc length\n */\nconst arcLength = (rx: number, ry: number, theta: number) => {\n  const halfTheta = theta / 2;\n  const sinHalfTheta = Math.sin(halfTheta);\n  const cosHalfTheta = Math.cos(halfTheta);\n  const term1 = rx ** 2 * sinHalfTheta ** 2;\n  const term2 = ry ** 2 * cosHalfTheta ** 2;\n  const length = Math.sqrt(term1 + term2) * theta;\n  return Math.abs(length);\n};\n\n/**\n * Find point on ellipse at given angle around ellipse (theta);\n * @param cx the center X\n * @param cy the center Y\n * @param rx the radius X\n * @param ry the radius Y\n * @param alpha the arc rotation angle in radians\n * @param theta the arc sweep angle in radians\n * @returns a point around ellipse at given angle\n */\nconst arcPoint = (\n  cx: number,\n  cy: number,\n  rx: number,\n  ry: number,\n  alpha: number,\n  theta: number,\n) => {\n  const { sin, cos } = Math;\n  // theta is angle in radians around arc\n  // alpha is angle of rotation of ellipse in radians\n  const cosA = cos(alpha);\n  const sinA = sin(alpha);\n  const x = rx * cos(theta);\n  const y = ry * sin(theta);\n\n  return [cx + cosA * x - sinA * y, cy + sinA * x + cosA * y] as PointTuple;\n};\n\n/**\n * Returns the angle between two points.\n * @param v0 starting point\n * @param v1 ending point\n * @returns the angle in radian\n */\nconst angleBetween = (v0: Point, v1: Point) => {\n  const { x: v0x, y: v0y } = v0;\n  const { x: v1x, y: v1y } = v1;\n  const p = v0x * v1x + v0y * v1y;\n  const n = Math.sqrt((v0x ** 2 + v0y ** 2) * (v1x ** 2 + v1y ** 2));\n  const sign = v0x * v1y - v0y * v1x < 0 ? -1 : 1;\n  return sign * Math.acos(p / n);\n};\n\n/**\n * Returns the following properties for an Arc segment: center, start angle,\n * end angle, and radiuses on X and Y axis.\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param RX the radius on X axis\n * @param RY the radius on Y axis\n * @param angle the ellipse rotation in degrees\n * @param LAF the large arc flag\n * @param SF the sweep flag\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @returns properties specific to Arc segments\n */\nconst getArcProps = (\n  x1: number,\n  y1: number,\n  RX: number,\n  RY: number,\n  angle: number,\n  LAF: number,\n  SF: number,\n  x: number,\n  y: number,\n) => {\n  const { abs, sin, cos, sqrt, PI } = Math;\n  let rx = abs(RX);\n  let ry = abs(RY);\n  const xRot = ((angle % 360) + 360) % 360;\n  const xRotRad = xRot * (PI / 180);\n\n  // istanbul ignore next @preserve\n  if (x1 === x && y1 === y) {\n    return {\n      rx,\n      ry,\n      startAngle: 0,\n      endAngle: 0,\n      center: { x, y },\n    };\n  }\n\n  if (rx === 0 || ry === 0) {\n    return {\n      rx,\n      ry,\n      startAngle: 0,\n      endAngle: 0,\n      center: { x: (x + x1) / 2, y: (y + y1) / 2 },\n    };\n  }\n\n  const dx = (x1 - x) / 2;\n  const dy = (y1 - y) / 2;\n\n  const transformedPoint = {\n    x: cos(xRotRad) * dx + sin(xRotRad) * dy,\n    y: -sin(xRotRad) * dx + cos(xRotRad) * dy,\n  };\n\n  const radiiCheck = transformedPoint.x ** 2 / rx ** 2 +\n    transformedPoint.y ** 2 / ry ** 2;\n\n  if (radiiCheck > 1) {\n    rx *= sqrt(radiiCheck);\n    ry *= sqrt(radiiCheck);\n  }\n\n  const cSquareNumerator = rx ** 2 * ry ** 2 -\n    rx ** 2 * transformedPoint.y ** 2 - ry ** 2 * transformedPoint.x ** 2;\n  const cSquareRootDenom = rx ** 2 * transformedPoint.y ** 2 +\n    ry ** 2 * transformedPoint.x ** 2;\n\n  let cRadicand = cSquareNumerator / cSquareRootDenom;\n  /* istanbul ignore next @preserve */\n  cRadicand = cRadicand < 0 ? 0 : cRadicand;\n  const cCoef = (LAF !== SF ? 1 : -1) * sqrt(cRadicand);\n  const transformedCenter = {\n    x: cCoef * ((rx * transformedPoint.y) / ry),\n    y: cCoef * (-(ry * transformedPoint.x) / rx),\n  };\n\n  const center = {\n    x: cos(xRotRad) * transformedCenter.x - sin(xRotRad) * transformedCenter.y +\n      (x1 + x) / 2,\n    y: sin(xRotRad) * transformedCenter.x + cos(xRotRad) * transformedCenter.y +\n      (y1 + y) / 2,\n  };\n\n  const startVector = {\n    x: (transformedPoint.x - transformedCenter.x) / rx,\n    y: (transformedPoint.y - transformedCenter.y) / ry,\n  };\n\n  const startAngle = angleBetween({ x: 1, y: 0 }, startVector);\n\n  const endVector = {\n    x: (-transformedPoint.x - transformedCenter.x) / rx,\n    y: (-transformedPoint.y - transformedCenter.y) / ry,\n  };\n\n  let sweepAngle = angleBetween(startVector, endVector);\n  if (!SF && sweepAngle > 0) {\n    sweepAngle -= 2 * PI;\n  } else if (SF && sweepAngle < 0) {\n    sweepAngle += 2 * PI;\n  }\n  sweepAngle %= 2 * PI;\n\n  const endAngle = startAngle + sweepAngle;\n\n  // point.ellipticalArcStartAngle = startAngle;\n  // point.ellipticalArcEndAngle = startAngle + sweepAngle;\n  // point.ellipticalArcAngle = alpha;\n\n  // point.ellipticalArcCenter = center;\n  // point.resultantRx = rx;\n  // point.resultantRy = ry;\n\n  return {\n    center,\n    startAngle,\n    endAngle,\n    rx,\n    ry,\n  };\n};\n\n/**\n * Returns the length of an Arc segment.\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param c1x the first control point X\n * @param c1y the first control point Y\n * @param c2x the second control point X\n * @param c2y the second control point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @returns the length of the Arc segment\n */\nconst getArcLength = (\n  x1: number,\n  y1: number,\n  RX: number,\n  RY: number,\n  angle: number,\n  LAF: number,\n  SF: number,\n  x: number,\n  y: number,\n) => {\n  const { rx, ry, startAngle, endAngle } = getArcProps(\n    x1,\n    y1,\n    RX,\n    RY,\n    angle,\n    LAF,\n    SF,\n    x,\n    y,\n  );\n  return arcLength(rx, ry, endAngle - startAngle);\n};\n\n/**\n * Returns a point along an Arc segment at a given distance.\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param RX the radius on X axis\n * @param RY the radius on Y axis\n * @param angle the ellipse rotation in degrees\n * @param LAF the large arc flag\n * @param SF the sweep flag\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @param distance a [0-1] ratio\n * @returns a point along the Arc segment\n */\nconst getPointAtArcLength = (\n  x1: number,\n  y1: number,\n  RX: number,\n  RY: number,\n  angle: number,\n  LAF: number,\n  SF: number,\n  x: number,\n  y: number,\n  distance?: number,\n) => {\n  let point = { x: x1, y: y1 };\n  const { center, rx, ry, startAngle, endAngle } = getArcProps(\n    x1,\n    y1,\n    RX,\n    RY,\n    angle,\n    LAF,\n    SF,\n    x,\n    y,\n  );\n\n  /* istanbul ignore else @preserve */\n  if (typeof distance === \"number\") {\n    const length = arcLength(rx, ry, endAngle - startAngle);\n    if (distance <= 0) {\n      point = { x: x1, y: y1 };\n    } else if (distance >= length) {\n      point = { x, y };\n    } else {\n      /* istanbul ignore next @preserve */\n      if (x1 === x && y1 === y) {\n        return { x, y };\n      }\n      /* istanbul ignore next @preserve */\n      if (rx === 0 || ry === 0) {\n        return getPointAtLineLength(x1, y1, x, y, distance);\n      }\n      const { PI, cos, sin } = Math;\n      const sweepAngle = endAngle - startAngle;\n      const xRot = ((angle % 360) + 360) % 360;\n      const xRotRad = xRot * (PI / 180);\n      const alpha = startAngle + sweepAngle * (distance / length);\n      const ellipseComponentX = rx * cos(alpha);\n      const ellipseComponentY = ry * sin(alpha);\n\n      point = {\n        x: cos(xRotRad) * ellipseComponentX - sin(xRotRad) * ellipseComponentY +\n          center.x,\n        y: sin(xRotRad) * ellipseComponentX + cos(xRotRad) * ellipseComponentY +\n          center.y,\n      };\n    }\n  }\n\n  return point;\n};\n\n/**\n * Returns the extrema for an Arc segment in the following format:\n * [MIN_X, MIN_Y, MAX_X, MAX_Y]\n *\n * @see https://github.com/herrstrietzel/svg-pathdata-getbbox\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param RX the radius on X axis\n * @param RY the radius on Y axis\n * @param angle the ellipse rotation in degrees\n * @param LAF the large arc flag\n * @param SF the sweep flag\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @returns the extrema of the Arc segment\n */\nconst getArcBBox = (\n  x1: number,\n  y1: number,\n  RX: number,\n  RY: number,\n  angle: number,\n  LAF: number,\n  SF: number,\n  x: number,\n  y: number,\n) => {\n  const { center, rx, ry, startAngle, endAngle } = getArcProps(\n    x1,\n    y1,\n    RX,\n    RY,\n    angle,\n    LAF,\n    SF,\n    x,\n    y,\n  );\n  const deltaAngle = endAngle - startAngle;\n  const { min, max, tan, atan2, PI } = Math;\n\n  // circle/elipse center coordinates\n  const { x: cx, y: cy } = center;\n\n  // rotation to radians\n  const alpha = (angle * PI) / 180;\n  const tangent = tan(alpha);\n\n  /**\n   * find min/max from zeroes of directional derivative along x and y\n   * along x axis\n   */\n  const theta = atan2(-ry * tangent, rx);\n  const angle1 = theta;\n  const angle2 = theta + PI;\n  const angle3 = atan2(ry, rx * tangent);\n  const angle4 = angle3 + PI;\n\n  // inner bounding box\n  let xMin = min(x1, x);\n  let xMax = max(x1, x);\n  let yMin = min(y1, y);\n  let yMax = max(y1, y);\n\n  // on path point close after start\n  const angleAfterStart = endAngle - deltaAngle * 0.001;\n  const pP2 = arcPoint(cx, cy, rx, ry, alpha, angleAfterStart);\n\n  // on path point close before end\n  const angleBeforeEnd = endAngle - deltaAngle * 0.999;\n  const pP3 = arcPoint(cx, cy, rx, ry, alpha, angleBeforeEnd);\n\n  /**\n   * expected extremes\n   * if leaving inner bounding box\n   * (between segment start and end point)\n   * otherwise exclude elliptic extreme points\n   */\n\n  // right\n  if (pP2[0] > xMax || pP3[0] > xMax) {\n    // get point for this theta\n    const pxy = arcPoint(cx, cy, rx, ry, alpha, angle1);\n    xMin = min(xMin, pxy[0]);\n    yMin = min(yMin, pxy[1]);\n    xMax = max(xMax, pxy[0]);\n    yMax = max(yMax, pxy[1]);\n  }\n\n  // left\n  if (pP2[0] < xMin || pP3[0] < xMin) {\n    // get anti-symmetric point\n    const pxy = arcPoint(cx, cy, rx, ry, alpha, angle2);\n    xMin = min(xMin, pxy[0]);\n    yMin = min(yMin, pxy[1]);\n    xMax = max(xMax, pxy[0]);\n    yMax = max(yMax, pxy[1]);\n  }\n\n  // top\n  if (pP2[1] < yMin || pP3[1] < yMin) {\n    // get anti-symmetric point\n    const pxy = arcPoint(cx, cy, rx, ry, alpha, angle4);\n    xMin = min(xMin, pxy[0]);\n    yMin = min(yMin, pxy[1]);\n    xMax = max(xMax, pxy[0]);\n    yMax = max(yMax, pxy[1]);\n  }\n\n  // bottom\n  if (pP2[1] > yMax || pP3[1] > yMax) {\n    // get point for this theta\n    const pxy = arcPoint(cx, cy, rx, ry, alpha, angle3);\n    xMin = min(xMin, pxy[0]);\n    yMin = min(yMin, pxy[1]);\n    xMax = max(xMax, pxy[0]);\n    yMax = max(yMax, pxy[1]);\n  }\n\n  return [xMin, yMin, xMax, yMax] as [number, number, number, number];\n};\n\nexport {\n  angleBetween,\n  arcLength,\n  arcPoint,\n  getArcBBox,\n  getArcLength,\n  getArcProps,\n  getPointAtArcLength,\n};\n","import type {\n  CubicCoordinates,\n  CubicPoints,\n  DeriveCallback,\n  DerivedCubicPoints,\n  DerivedPoint,\n  DerivedQuadPoints,\n  PointTuple,\n  QuadCoordinates,\n  QuadPoints,\n} from \"../types\";\n\n/**\n * Tools from bezier.js by Mike 'Pomax' Kamermans\n * @see https://github.com/Pomax/bezierjs\n */\n\nconst Tvalues = [\n  -0.0640568928626056260850430826247450385909,\n  0.0640568928626056260850430826247450385909,\n  -0.1911188674736163091586398207570696318404,\n  0.1911188674736163091586398207570696318404,\n  -0.3150426796961633743867932913198102407864,\n  0.3150426796961633743867932913198102407864,\n  -0.4337935076260451384870842319133497124524,\n  0.4337935076260451384870842319133497124524,\n  -0.5454214713888395356583756172183723700107,\n  0.5454214713888395356583756172183723700107,\n  -0.6480936519369755692524957869107476266696,\n  0.6480936519369755692524957869107476266696,\n  -0.7401241915785543642438281030999784255232,\n  0.7401241915785543642438281030999784255232,\n  -0.8200019859739029219539498726697452080761,\n  0.8200019859739029219539498726697452080761,\n  -0.8864155270044010342131543419821967550873,\n  0.8864155270044010342131543419821967550873,\n  -0.9382745520027327585236490017087214496548,\n  0.9382745520027327585236490017087214496548,\n  -0.9747285559713094981983919930081690617411,\n  0.9747285559713094981983919930081690617411,\n  -0.9951872199970213601799974097007368118745,\n  0.9951872199970213601799974097007368118745,\n];\n\nconst Cvalues = [\n  0.1279381953467521569740561652246953718517,\n  0.1279381953467521569740561652246953718517,\n  0.1258374563468282961213753825111836887264,\n  0.1258374563468282961213753825111836887264,\n  0.121670472927803391204463153476262425607,\n  0.121670472927803391204463153476262425607,\n  0.1155056680537256013533444839067835598622,\n  0.1155056680537256013533444839067835598622,\n  0.1074442701159656347825773424466062227946,\n  0.1074442701159656347825773424466062227946,\n  0.0976186521041138882698806644642471544279,\n  0.0976186521041138882698806644642471544279,\n  0.086190161531953275917185202983742667185,\n  0.086190161531953275917185202983742667185,\n  0.0733464814110803057340336152531165181193,\n  0.0733464814110803057340336152531165181193,\n  0.0592985849154367807463677585001085845412,\n  0.0592985849154367807463677585001085845412,\n  0.0442774388174198061686027482113382288593,\n  0.0442774388174198061686027482113382288593,\n  0.0285313886289336631813078159518782864491,\n  0.0285313886289336631813078159518782864491,\n  0.0123412297999871995468056670700372915759,\n  0.0123412297999871995468056670700372915759,\n];\n\n/**\n * @param points\n * @returns\n */\nconst deriveBezier = (points: QuadPoints | CubicPoints) => {\n  const dpoints = [] as (DerivedCubicPoints | DerivedQuadPoints)[];\n  for (let p = points, d = p.length, c = d - 1; d > 1; d -= 1, c -= 1) {\n    const list = [] as unknown as DerivedCubicPoints | DerivedQuadPoints;\n    for (let j = 0; j < c; j += 1) {\n      list.push({\n        x: c * (p[j + 1].x - p[j].x),\n        y: c * (p[j + 1].y - p[j].y),\n        t: 0,\n      });\n    }\n    dpoints.push(list);\n    p = list;\n  }\n  return dpoints;\n};\n\n/**\n * @param points\n * @param t\n */\nconst computeBezier = (\n  points: DerivedQuadPoints | DerivedCubicPoints,\n  t: number,\n) => {\n  // shortcuts\n  /* istanbul ignore next @preserve */\n  if (t === 0) {\n    points[0].t = 0;\n    return points[0];\n  }\n\n  const order = points.length - 1;\n\n  /* istanbul ignore next @preserve */\n  if (t === 1) {\n    points[order].t = 1;\n    return points[order];\n  }\n\n  const mt = 1 - t;\n  let p = points as typeof points | [\n    DerivedPoint,\n    DerivedPoint,\n    DerivedPoint,\n    DerivedPoint,\n  ];\n\n  // constant?\n  /* istanbul ignore next @preserve */\n  if (order === 0) {\n    points[0].t = t;\n    return points[0];\n  }\n\n  // linear?\n  /* istanbul ignore else @preserve */\n  if (order === 1) {\n    return {\n      x: mt * p[0].x + t * p[1].x,\n      y: mt * p[0].y + t * p[1].y,\n      t,\n    };\n  }\n\n  // quadratic/cubic curve?\n  const mt2 = mt * mt;\n  const t2 = t * t;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  /* istanbul ignore else @preserve */\n  if (order === 2) {\n    p = [p[0], p[1], p[2], { x: 0, y: 0 } as DerivedPoint];\n    a = mt2;\n    b = mt * t * 2;\n    c = t2;\n  } else if (order === 3) {\n    a = mt2 * mt;\n    b = mt2 * t * 3;\n    c = mt * t2 * 3;\n    d = t * t2;\n  }\n  return {\n    x: a * p[0].x + b * p[1].x + c * p[2].x + d * p[3].x,\n    y: a * p[0].y + b * p[1].y + c * p[2].y + d * p[3].y,\n    t,\n  };\n};\n\nconst calculateBezier = (derivativeFn: DeriveCallback, t: number) => {\n  const d = derivativeFn(t);\n  const l = d.x * d.x + d.y * d.y;\n\n  return Math.sqrt(l);\n};\n\nconst bezierLength = (derivativeFn: DeriveCallback) => {\n  const z = 0.5;\n  const len = Tvalues.length;\n\n  let sum = 0;\n\n  for (let i = 0, t; i < len; i++) {\n    t = z * Tvalues[i] + z;\n    sum += Cvalues[i] * calculateBezier(derivativeFn, t);\n  }\n  return z * sum;\n};\n\n/**\n * Returns the length of CubicBezier / Quad segment.\n * @param curve cubic / quad bezier segment\n */\nconst getBezierLength = (curve: CubicCoordinates | QuadCoordinates) => {\n  const points = [] as unknown as CubicPoints | QuadPoints;\n  for (let idx = 0, len = curve.length, step = 2; idx < len; idx += step) {\n    points.push({\n      x: curve[idx],\n      y: curve[idx + 1],\n    });\n  }\n  const dpoints = deriveBezier(points);\n  return bezierLength((t: number) => {\n    return computeBezier(dpoints[0], t);\n  });\n};\n\n// Precision for consider cubic polynom as quadratic one\nconst CBEZIER_MINMAX_EPSILON = 0.00000001;\n\n/**\n * Returns the most extreme points in a Quad Bezier segment.\n * @param A an array which consist of X/Y values\n */\n// https://github.com/kpym/SVGPathy/blob/acd1a50c626b36d81969f6e98e8602e128ba4302/lib/box.js#L89\nconst minmaxQ = ([v1, cp, v2]: [number, number, number]) => {\n  const min = Math.min(v1, v2);\n  const max = Math.max(v1, v2);\n\n  /* istanbul ignore next @preserve */\n  if (cp >= v1 ? v2 >= cp : v2 <= cp) {\n    // if no extremum in ]0,1[\n    return [min, max] as PointTuple;\n  }\n\n  // check if the extremum E is min or max\n  const E = (v1 * v2 - cp * cp) / (v1 - 2 * cp + v2);\n  return (E < min ? [E, max] : [min, E]) as PointTuple;\n};\n\n/**\n * Returns the most extreme points in a Cubic Bezier segment.\n * @param A an array which consist of X/Y values\n * @see https://github.com/kpym/SVGPathy/blob/acd1a50c626b36d81969f6e98e8602e128ba4302/lib/box.js#L127\n */\nconst minmaxC = ([v1, cp1, cp2, v2]: [number, number, number, number]) => {\n  const K = v1 - 3 * cp1 + 3 * cp2 - v2;\n\n  // if the polynomial is (almost) quadratic and not cubic\n  /* istanbul ignore next @preserve */\n  if (Math.abs(K) < CBEZIER_MINMAX_EPSILON) {\n    if (v1 === v2 && v1 === cp1) {\n      // no curve, point targeting same location\n      return [v1, v2] as PointTuple;\n    }\n\n    return minmaxQ([v1, -0.5 * v1 + 1.5 * cp1, v1 - 3 * cp1 + 3 * cp2]);\n  }\n\n  // the reduced discriminant of the derivative\n  const T = -v1 * cp2 + v1 * v2 - cp1 * cp2 - cp1 * v2 + cp1 * cp1 + cp2 * cp2;\n\n  // if the polynomial is monotone in [0,1]\n  if (T <= 0) {\n    return [Math.min(v1, v2), Math.max(v1, v2)] as PointTuple;\n  }\n  const S = Math.sqrt(T);\n\n  // potential extrema\n  let min = Math.min(v1, v2);\n  let max = Math.max(v1, v2);\n\n  const L = v1 - 2 * cp1 + cp2;\n  // check local extrema\n  for (let R = (L + S) / K, i = 1; i <= 2; R = (L - S) / K, i++) {\n    // istanbul ignore next @preserve\n    if (R > 0 && R < 1) {\n      // if the extrema is for R in [0,1]\n      const Q = v1 * (1 - R) * (1 - R) * (1 - R) +\n        cp1 * 3 * (1 - R) * (1 - R) * R + cp2 * 3 * (1 - R) * R * R +\n        v2 * R * R * R;\n      if (Q < min) {\n        min = Q;\n      }\n      if (Q > max) {\n        max = Q;\n      }\n    }\n  }\n\n  return [min, max] as PointTuple;\n};\n\nexport {\n  bezierLength,\n  calculateBezier,\n  CBEZIER_MINMAX_EPSILON,\n  computeBezier,\n  Cvalues,\n  deriveBezier,\n  getBezierLength,\n  minmaxC,\n  minmaxQ,\n  Tvalues,\n};\n","import { getBezierLength, minmaxC } from \"./bezier\";\nimport { type CubicCoordinates } from \"../types\";\n\n/**\n * Returns a point at a given length of a CubicBezier segment.\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param c1x the first control point X\n * @param c1y the first control point Y\n * @param c2x the second control point X\n * @param c2y the second control point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @param t a [0-1] ratio\n * @returns the point at cubic-bezier segment length\n */\nconst getPointAtCubicSegmentLength = (\n  [x1, y1, c1x, c1y, c2x, c2y, x2, y2]: CubicCoordinates,\n  t: number,\n) => {\n  const t1 = 1 - t;\n  return {\n    x: t1 ** 3 * x1 + 3 * t1 ** 2 * t * c1x + 3 * t1 * t ** 2 * c2x +\n      t ** 3 * x2,\n    y: t1 ** 3 * y1 + 3 * t1 ** 2 * t * c1y + 3 * t1 * t ** 2 * c2y +\n      t ** 3 * y2,\n  };\n};\n\n/**\n * Returns the length of a CubicBezier segment.\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param c1x the first control point X\n * @param c1y the first control point Y\n * @param c2x the second control point X\n * @param c2y the second control point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @returns the CubicBezier segment length\n */\nconst getCubicLength = (\n  x1: number,\n  y1: number,\n  c1x: number,\n  c1y: number,\n  c2x: number,\n  c2y: number,\n  x2: number,\n  y2: number,\n) => {\n  return getBezierLength([x1, y1, c1x, c1y, c2x, c2y, x2, y2]);\n};\n\n/**\n * Returns the point along a CubicBezier segment at a given distance.\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param c1x the first control point X\n * @param c1y the first control point Y\n * @param c2x the second control point X\n * @param c2y the second control point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @param distance the distance to look at\n * @returns the point at CubicBezier length\n */\nconst getPointAtCubicLength = (\n  x1: number,\n  y1: number,\n  c1x: number,\n  c1y: number,\n  c2x: number,\n  c2y: number,\n  x2: number,\n  y2: number,\n  distance?: number,\n) => {\n  const distanceIsNumber = typeof distance === \"number\";\n  let point = { x: x1, y: y1 };\n  /* istanbul ignore else @preserve */\n  if (distanceIsNumber) {\n    const currentLength = getBezierLength([x1, y1, c1x, c1y, c2x, c2y, x2, y2]);\n    if (distance <= 0) {\n      // first point already defined\n    } else if (distance >= currentLength) {\n      point = { x: x2, y: y2 };\n    } else {\n      point = getPointAtCubicSegmentLength(\n        [x1, y1, c1x, c1y, c2x, c2y, x2, y2],\n        distance / currentLength,\n      );\n    }\n  }\n  return point;\n};\n\n/**\n * Returns the boundig box of a CubicBezier segment in the following format:\n * [MIN_X, MIN_Y, MAX_X, MAX_Y]\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param c1x the first control point X\n * @param c1y the first control point Y\n * @param c2x the second control point X\n * @param c2y the second control point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @returns the extrema of the CubicBezier segment\n */\nconst getCubicBBox = (\n  x1: number,\n  y1: number,\n  c1x: number,\n  c1y: number,\n  c2x: number,\n  c2y: number,\n  x2: number,\n  y2: number,\n) => {\n  const cxMinMax = minmaxC([x1, c1x, c2x, x2]);\n  const cyMinMax = minmaxC([y1, c1y, c2y, y2]);\n\n  return [cxMinMax[0], cyMinMax[0], cxMinMax[1], cyMinMax[1]] as [\n    number,\n    number,\n    number,\n    number,\n  ];\n};\n\nexport {\n  getCubicBBox,\n  getCubicLength,\n  getPointAtCubicLength,\n  getPointAtCubicSegmentLength,\n};\n","import { getBezierLength, minmaxQ } from \"./bezier\";\nimport { type QuadCoordinates } from \"../types\";\n\n/**\n * Returns the {x,y} coordinates of a point at a\n * given length of a quadratic-bezier segment.\n *\n * @see https://github.com/substack/point-at-length\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param cx the control point X\n * @param cy the control point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @param t a [0-1] ratio\n * @returns the requested {x,y} coordinates\n */\nconst getPointAtQuadSegmentLength = (\n  [x1, y1, cx, cy, x2, y2]: QuadCoordinates,\n  t: number,\n) => {\n  const t1 = 1 - t;\n  return {\n    x: t1 ** 2 * x1 + 2 * t1 * t * cx + t ** 2 * x2,\n    y: t1 ** 2 * y1 + 2 * t1 * t * cy + t ** 2 * y2,\n  };\n};\n\n/**\n * Returns the length of a QuadraticBezier segment.\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param cx the control point X\n * @param cy the control point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @returns the QuadraticBezier segment length\n */\nconst getQuadLength = (\n  x1: number,\n  y1: number,\n  cx: number,\n  cy: number,\n  x2: number,\n  y2: number,\n) => {\n  return getBezierLength([x1, y1, cx, cy, x2, y2]);\n};\n\n/**\n * Returns the point along a QuadraticBezier segment at a given distance.\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param cx the control point X\n * @param cy the control point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @param distance the distance to look at\n * @returns the point at QuadraticBezier length\n */\nconst getPointAtQuadLength = (\n  x1: number,\n  y1: number,\n  cx: number,\n  cy: number,\n  x2: number,\n  y2: number,\n  distance?: number,\n) => {\n  const distanceIsNumber = typeof distance === \"number\";\n  let point = { x: x1, y: y1 };\n\n  /* istanbul ignore else @preserve */\n  if (distanceIsNumber) {\n    const currentLength = getBezierLength([x1, y1, cx, cy, x2, y2]);\n    if (distance <= 0) {\n      // first point already defined\n    } else if (distance >= currentLength) {\n      point = { x: x2, y: y2 };\n    } else {\n      point = getPointAtQuadSegmentLength(\n        [x1, y1, cx, cy, x2, y2],\n        distance / currentLength,\n      );\n    }\n  }\n  return point;\n};\n\n/**\n * Returns the boundig box of a QuadraticBezier segment in the following format:\n * [MIN_X, MIN_Y, MAX_X, MAX_Y]\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param cx the control point X\n * @param cy the control point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @returns the extrema of the QuadraticBezier segment\n */\nconst getQuadBBox = (\n  x1: number,\n  y1: number,\n  cx: number,\n  cy: number,\n  x2: number,\n  y2: number,\n) => {\n  const cxMinMax = minmaxQ([x1, cx, x2]);\n  const cyMinMax = minmaxQ([y1, cy, y2]);\n  return [cxMinMax[0], cyMinMax[0], cxMinMax[1], cyMinMax[1]] as [\n    number,\n    number,\n    number,\n    number,\n  ];\n};\n\nexport {\n  getPointAtQuadLength,\n  getPointAtQuadSegmentLength,\n  getQuadBBox,\n  getQuadLength,\n};\n","import distanceSquareRoot from \"./distanceSquareRoot\";\nimport { type PointTuple } from \"../types\";\n\n/**\n * d3-polygon-area\n * https://github.com/d3/d3-polygon\n *\n * Returns the area of a polygon.\n *\n * @param polygon an array of coordinates\n * @returns the polygon area\n */\nconst polygonArea = (polygon: PointTuple[]) => {\n  const n = polygon.length;\n  let i = -1;\n  let a: PointTuple;\n  let b = polygon[n - 1];\n  let area = 0;\n\n  /* eslint-disable-next-line */\n  while (++i < n) {\n    a = b;\n    b = polygon[i];\n    area += a[1] * b[0] - a[0] * b[1];\n  }\n\n  return area / 2;\n};\n\n/**\n * d3-polygon-length\n * https://github.com/d3/d3-polygon\n *\n * Returns the perimeter of a polygon.\n *\n * @param polygon an array of coordinates\n * @returns the polygon length\n */\nconst polygonLength = (polygon: PointTuple[]) => {\n  return polygon.reduce((length, point, i) => {\n    if (i) {\n      return length + distanceSquareRoot(polygon[i - 1], point);\n    }\n    return 0;\n  }, 0);\n};\n\nexport { polygonArea, polygonLength };\n","const DISTANCE_EPSILON = 0.00001;\n\nexport default DISTANCE_EPSILON;\n","import normalizeSegment from \"./normalizeSegment\";\nimport type { NormalArray, PathArray } from \"../types\";\nimport iterate from \"./iterate\";\nimport parsePathString from \"../parser/parsePathString\";\nimport paramsParser from \"../parser/paramsParser\";\n\n/**\n * Normalizes a `pathArray` object for further processing:\n * * convert segments to absolute values\n * * convert shorthand path commands to their non-shorthand notation\n *\n * @param pathInput the string to be parsed or 'pathArray'\n * @returns the normalized `pathArray`\n */\nconst normalizePath = (pathInput: string | PathArray) => {\n  const path = parsePathString(pathInput);\n  const params = { ...paramsParser };\n\n  return iterate<NormalArray>(path, (seg, _, lastX, lastY) => {\n    params.x = lastX;\n    params.y = lastY;\n    const result = normalizeSegment(seg, params);\n\n    const seglen = result.length;\n    params.x1 = +result[seglen - 2];\n    params.y1 = +result[seglen - 1];\n    params.x2 = +result[seglen - 4] || params.x1;\n    params.y2 = +result[seglen - 3] || params.y1;\n\n    return result;\n  });\n};\nexport default normalizePath;\n","import DISTANCE_EPSILON from \"./distanceEpsilon\";\nimport type { MSegment, PathArray, PointTuple } from \"../types\";\nimport iterate from \"../process/iterate\";\nimport { getLineLength, getPointAtLineLength } from \"../math/lineTools\";\nimport { getArcLength, getPointAtArcLength } from \"../math/arcTools\";\nimport { getCubicLength, getPointAtCubicLength } from \"../math/cubicTools\";\nimport { getPointAtQuadLength, getQuadLength } from \"../math/quadTools\";\nimport normalizePath from \"../process/normalizePath\";\n\n/**\n * Returns [x,y] coordinates of a point at a given length of a shape.\n *\n * @param pathInput the `pathArray` to look into\n * @param distance the length of the shape to look at\n * @returns the requested {x, y} point coordinates\n */\nconst getPointAtLength = (pathInput: string | PathArray, distance?: number) => {\n  const path = normalizePath(pathInput);\n  let isM = false;\n  let data = [] as number[];\n  let pathCommand = \"M\";\n  let x = 0;\n  let y = 0;\n  let [mx, my] = path[0].slice(1) as PointTuple;\n  const distanceIsNumber = typeof distance === \"number\";\n  let point = { x: mx, y: my };\n  let length = 0;\n  let POINT = point;\n  let totalLength = 0;\n\n  if (!distanceIsNumber || distance < DISTANCE_EPSILON) return point;\n\n  // for (let i = 0; i < pathLen; i += 1) {\n  iterate(path, (seg, _, lastX, lastY) => {\n    [pathCommand] = seg;\n    isM = pathCommand === \"M\";\n    data = !isM ? [lastX, lastY].concat(seg.slice(1) as number[]) : data;\n\n    // this segment is always ZERO\n    /* istanbul ignore else @preserve */\n    if (isM) {\n      // remember mx, my for Z\n      [, mx, my] = seg as MSegment;\n      point = { x: mx, y: my };\n      length = 0;\n    } else if (pathCommand === \"L\") {\n      point = getPointAtLineLength(\n        data[0],\n        data[1],\n        data[2],\n        data[3],\n        distance - totalLength,\n      );\n      length = getLineLength(data[0], data[1], data[2], data[3]);\n    } else if (pathCommand === \"A\") {\n      point = getPointAtArcLength(\n        data[0],\n        data[1],\n        data[2],\n        data[3],\n        data[4],\n        data[5],\n        data[6],\n        data[7],\n        data[8],\n        distance - totalLength,\n      );\n      length = getArcLength(\n        data[0],\n        data[1],\n        data[2],\n        data[3],\n        data[4],\n        data[5],\n        data[6],\n        data[7],\n        data[8],\n      );\n    } else if (pathCommand === \"C\") {\n      point = getPointAtCubicLength(\n        data[0],\n        data[1],\n        data[2],\n        data[3],\n        data[4],\n        data[5],\n        data[6],\n        data[7],\n        distance - totalLength,\n      );\n      length = getCubicLength(\n        data[0],\n        data[1],\n        data[2],\n        data[3],\n        data[4],\n        data[5],\n        data[6],\n        data[7],\n      );\n    } else if (pathCommand === \"Q\") {\n      point = getPointAtQuadLength(\n        data[0],\n        data[1],\n        data[2],\n        data[3],\n        data[4],\n        data[5],\n        distance - totalLength,\n      );\n      length = getQuadLength(\n        data[0],\n        data[1],\n        data[2],\n        data[3],\n        data[4],\n        data[5],\n      );\n    } else if (pathCommand === \"Z\") {\n      data = [lastX, lastY, mx, my];\n      point = { x: mx, y: my };\n\n      length = getLineLength(data[0], data[1], data[2], data[3]);\n    }\n\n    [x, y] = data.slice(-2);\n\n    if (totalLength < distance) {\n      POINT = point;\n    } else {\n      // totalLength >= distance\n      // stop right here\n      // stop iterator now!\n      return false;\n    }\n\n    totalLength += length;\n    return;\n  });\n\n  // native `getPointAtLength` behavior when the given distance\n  // is higher than total length\n  if (distance > totalLength - DISTANCE_EPSILON) {\n    return { x, y };\n  }\n\n  return POINT;\n};\n\nexport default getPointAtLength;\n","import type { LSegment, MSegment, PathArray, PointTuple } from \"../types\";\nimport { getLineLength } from \"../math/lineTools\";\nimport { getArcLength } from \"../math/arcTools\";\nimport { getCubicLength } from \"../math/cubicTools\";\nimport { getQuadLength } from \"../math/quadTools\";\nimport iterate from \"../process/iterate\";\nimport parsePathString from \"../parser/parsePathString\";\nimport absolutizeSegment from \"../process/absolutizeSegment\";\n\n/**\n * Returns the shape total length, or the equivalent to `shape.getTotalLength()`.\n *\n * @param pathInput the target `pathArray`\n * @returns the shape total length\n */\nconst getTotalLength = (pathInput: string | PathArray) => {\n  const path = parsePathString(pathInput);\n  let paramX1 = 0;\n  let paramY1 = 0;\n  let paramX2 = 0;\n  let paramY2 = 0;\n  let paramQX = 0;\n  let paramQY = 0;\n  let pathCommand = \"M\";\n  let mx = 0;\n  let my = 0;\n  let totalLength = 0;\n\n  iterate(path, (seg, index, lastX, lastY) => {\n    [pathCommand] = seg;\n    const absCommand = pathCommand.toUpperCase();\n    const isRelative = absCommand !== pathCommand;\n    const absoluteSegment = isRelative\n      ? absolutizeSegment(seg, index, lastX, lastY)\n      : (seg.slice(0) as typeof seg);\n\n    const normalSegment = absCommand === \"V\"\n      ? ([\"L\", lastX, absoluteSegment[1]] as LSegment)\n      : absCommand === \"H\"\n      ? ([\"L\", absoluteSegment[1], lastY] as LSegment)\n      : absoluteSegment;\n    [pathCommand] = normalSegment;\n\n    if (!\"TQ\".includes(absCommand)) {\n      // optional but good to be cautious\n      paramQX = 0;\n      paramQY = 0;\n    }\n\n    // this segment is always ZERO\n    /* istanbul ignore else @preserve */\n    if (pathCommand === \"M\") {\n      // remember mx, my for Z\n      [, mx, my] = normalSegment as MSegment;\n    } else if (pathCommand === \"L\") {\n      totalLength += getLineLength(\n        lastX,\n        lastY,\n        normalSegment[1] as number,\n        normalSegment[2] as number,\n      );\n    } else if (pathCommand === \"A\") {\n      totalLength += getArcLength(\n        lastX,\n        lastY,\n        normalSegment[1] as number,\n        normalSegment[2] as number,\n        normalSegment[3] as number,\n        normalSegment[4] as number,\n        normalSegment[5] as number,\n        normalSegment[6] as number,\n        normalSegment[7] as number,\n      );\n    } else if (pathCommand === \"S\") {\n      const cp1x = paramX1 * 2 - paramX2;\n      const cp1y = paramY1 * 2 - paramY2;\n\n      totalLength += getCubicLength(\n        lastX,\n        lastY,\n        cp1x,\n        cp1y,\n        normalSegment[1] as number,\n        normalSegment[2] as number,\n        normalSegment[3] as number,\n        normalSegment[4] as number,\n      );\n    } else if (pathCommand === \"C\") {\n      totalLength += getCubicLength(\n        lastX,\n        lastY,\n        normalSegment[1] as number,\n        normalSegment[2] as number,\n        normalSegment[3] as number,\n        normalSegment[4] as number,\n        normalSegment[5] as number,\n        normalSegment[6] as number,\n      );\n    } else if (pathCommand === \"T\") {\n      paramQX = paramX1 * 2 - paramQX;\n      paramQY = paramY1 * 2 - paramQY;\n      totalLength += getQuadLength(\n        lastX,\n        lastY,\n        paramQX,\n        paramQY,\n        normalSegment[1] as number,\n        normalSegment[2] as number,\n      );\n    } else if (pathCommand === \"Q\") {\n      paramQX = normalSegment[1] as number;\n      paramQY = normalSegment[2] as number;\n      totalLength += getQuadLength(\n        lastX,\n        lastY,\n        normalSegment[1] as number,\n        normalSegment[2] as number,\n        normalSegment[3] as number,\n        normalSegment[4] as number,\n      );\n    } else if (pathCommand === \"Z\") {\n      totalLength += getLineLength(lastX, lastY, mx, my);\n    }\n\n    // update params\n    [paramX1, paramY1] = pathCommand === \"Z\"\n      ? [mx, my]\n      : (normalSegment.slice(-2) as PointTuple);\n    [paramX2, paramY2] = pathCommand === \"C\"\n      ? ([normalSegment[3], normalSegment[4]] as PointTuple)\n      : pathCommand === \"S\"\n      ? ([normalSegment[1], normalSegment[2]] as PointTuple)\n      : [paramX1, paramY1];\n  });\n\n  return totalLength;\n};\n\nexport default getTotalLength;\n","import type { PathArray, PathSegment } from \"../types\";\nimport type { SegmentProperties } from \"../interface\";\nimport parsePathString from \"../parser/parsePathString\";\nimport getTotalLength from \"./getTotalLength\";\n\n/**\n * Returns the segment, its index and length as well as\n * the length to that segment at a given length in a path.\n *\n * @param pathInput target `pathArray`\n * @param distance the given length\n * @returns the requested properties\n */\nconst getPropertiesAtLength = (\n  pathInput: string | PathArray,\n  distance?: number,\n): SegmentProperties => {\n  const pathArray = parsePathString(pathInput);\n\n  let pathTemp = pathArray.slice(0) as PathArray;\n  let pathLength = getTotalLength(pathTemp);\n  let index = pathTemp.length - 1;\n  let lengthAtSegment = 0;\n  let length = 0;\n  let segment = pathArray[0] as PathSegment;\n\n  // If the path is empty, return 0.\n  if (index <= 0 || !distance || !Number.isFinite(distance)) {\n    return {\n      segment,\n      index: 0,\n      length,\n      lengthAtSegment,\n    };\n  }\n\n  if (distance >= pathLength) {\n    pathTemp = pathArray.slice(0, -1) as PathArray;\n    lengthAtSegment = getTotalLength(pathTemp);\n    length = pathLength - lengthAtSegment;\n    segment = pathArray[index];\n    return {\n      segment,\n      index,\n      length,\n      lengthAtSegment,\n    };\n  }\n\n  const segments = [] as SegmentProperties[];\n  while (index > 0) {\n    segment = pathTemp[index];\n    pathTemp = pathTemp.slice(0, -1) as PathArray;\n    lengthAtSegment = getTotalLength(pathTemp);\n    length = pathLength - lengthAtSegment;\n    pathLength = lengthAtSegment;\n\n    segments.push({\n      segment,\n      index,\n      length,\n      lengthAtSegment,\n    });\n    index -= 1;\n  }\n\n  return segments.find(({ lengthAtSegment: l }) =>\n    l <= distance\n  ) as SegmentProperties;\n};\n\nexport default getPropertiesAtLength;\n","import type { PathArray, Point } from \"../types\";\nimport type { PointProperties } from \"../interface\";\nimport getPointAtLength from \"./getPointAtLength\";\nimport getPropertiesAtLength from \"./getPropertiesAtLength\";\nimport getTotalLength from \"./getTotalLength\";\nimport parsePathString from \"../parser/parsePathString\";\nimport normalizePath from \"../process/normalizePath\";\n\n/**\n * Returns the point and segment in path closest to a given point as well as\n * the distance to the path stroke.\n *\n * @see https://bl.ocks.org/mbostock/8027637\n *\n * @param pathInput target `pathArray`\n * @param point the given point\n * @returns the requested properties\n */\nconst getPropertiesAtPoint = (\n  pathInput: string | PathArray,\n  point: Point,\n): PointProperties => {\n  const path = parsePathString(pathInput);\n  const normalPath = normalizePath(path);\n  const pathLength = getTotalLength(normalPath);\n  const distanceTo = (p: Point) => {\n    const dx = p.x - point.x;\n    const dy = p.y - point.y;\n    return dx * dx + dy * dy;\n  };\n  let precision = 8;\n  let scan: Point;\n  let closest = { x: 0, y: 0 }; // make TS happy\n  let scanDistance = 0;\n  let bestLength = 0;\n  let bestDistance = Infinity;\n\n  // linear scan for coarse approximation\n  for (let scanLength = 0; scanLength <= pathLength; scanLength += precision) {\n    scan = getPointAtLength(normalPath, scanLength);\n    scanDistance = distanceTo(scan);\n\n    if (scanDistance < bestDistance) {\n      closest = scan;\n      bestLength = scanLength;\n      bestDistance = scanDistance;\n    }\n  }\n\n  // binary search for precise estimate\n  precision /= 2;\n  let before: { x: number; y: number };\n  let after: { x: number; y: number };\n  let beforeLength = 0;\n  let afterLength = 0;\n  let beforeDistance = 0;\n  let afterDistance = 0;\n\n  while (precision > 0.000001) {\n    beforeLength = bestLength - precision;\n    before = getPointAtLength(normalPath, beforeLength);\n    beforeDistance = distanceTo(before);\n    afterLength = bestLength + precision;\n    after = getPointAtLength(normalPath, afterLength);\n    afterDistance = distanceTo(after);\n\n    if (beforeLength >= 0 && beforeDistance < bestDistance) {\n      closest = before;\n      bestLength = beforeLength;\n      bestDistance = beforeDistance;\n    } else if (afterLength <= pathLength && afterDistance < bestDistance) {\n      closest = after;\n      bestLength = afterLength;\n      bestDistance = afterDistance;\n    } else {\n      precision /= 2;\n    }\n    if (precision < 0.00001) break;\n  }\n\n  const segment = getPropertiesAtLength(path, bestLength);\n  const distance = Math.sqrt(bestDistance);\n\n  return { closest, distance, segment };\n};\n\nexport default getPropertiesAtPoint;\n","import type { PathArray } from \"../types\";\nimport getPropertiesAtPoint from \"./getPropertiesAtPoint\";\n\n/**\n * Returns the point in path closest to a given point.\n *\n * @param pathInput target `pathArray`\n * @param point the given point\n * @returns the best match\n */\nconst getClosestPoint = (\n  pathInput: string | PathArray,\n  point: { x: number; y: number },\n) => {\n  return getPropertiesAtPoint(pathInput, point).closest;\n};\n\nexport default getClosestPoint;\n","import pathToCurve from \"../convert/pathToCurve\";\nimport type { PathArray, PointTuple } from \"../types\";\n\n/**\n * Returns the area of a single cubic-bezier segment.\n *\n * http://objectmix.com/graphics/133553-area-closed-bezier-curve.html\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param c1x the first control point X\n * @param c1y the first control point Y\n * @param c2x the second control point X\n * @param c2y the second control point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @returns the area of the cubic-bezier segment\n */\nconst getCubicSegArea = (\n  x1: number,\n  y1: number,\n  c1x: number,\n  c1y: number,\n  c2x: number,\n  c2y: number,\n  x2: number,\n  y2: number,\n) => {\n  return (\n    (3 *\n      ((y2 - y1) * (c1x + c2x) -\n        (x2 - x1) * (c1y + c2y) +\n        c1y * (x1 - c2x) -\n        c1x * (y1 - c2y) +\n        y2 * (c2x + x1 / 3) -\n        x2 * (c2y + y1 / 3))) /\n    20\n  );\n};\n\n/**\n * Returns the area of a shape.\n *\n * @author Jrg Lehni & Jonathan Puckey\n *\n * @see https://github.com/paperjs/paper.js/blob/develop/src/path/Path.js\n *\n * @param path the shape `pathArray`\n * @returns the length of the cubic-bezier segment\n */\nconst getPathArea = (path: PathArray) => {\n  let x = 0;\n  let y = 0;\n  let len = 0;\n\n  return pathToCurve(path)\n    .map((seg) => {\n      switch (seg[0]) {\n        case \"M\":\n          [, x, y] = seg;\n          return 0;\n        default:\n          len = getCubicSegArea(\n            x,\n            y,\n            seg[1],\n            seg[2],\n            seg[3],\n            seg[4],\n            seg[5],\n            seg[6],\n          );\n          [x, y] = seg.slice(-2) as PointTuple;\n          return len;\n      }\n    })\n    .reduce((a, b) => a + b, 0);\n};\nexport default getPathArea;\n","import getPathArea from \"./getPathArea\";\nimport pathToCurve from \"../convert/pathToCurve\";\nimport type { PathArray } from \"../types\";\n\n/**\n * Check if a path is drawn clockwise and returns true if so,\n * false otherwise.\n *\n * @param path the path string or `pathArray`\n * @returns true when clockwise or false if not\n */\nconst getDrawDirection = (path: string | PathArray) => {\n  return getPathArea(pathToCurve(path)) >= 0;\n};\n\nexport default getDrawDirection;\n","import iterate from \"../process/iterate\";\nimport { PathBBox } from \"../interface\";\nimport { LSegment, MSegment, PathArray, PointTuple } from \"../types\";\nimport { getLineBBox } from \"../math/lineTools\";\nimport { getArcBBox } from \"../math/arcTools\";\nimport { getCubicBBox } from \"../math/cubicTools\";\nimport { getQuadBBox } from \"../math/quadTools\";\nimport parsePathString from \"../parser/parsePathString\";\nimport absolutizeSegment from \"../process/absolutizeSegment\";\n\nconst getPathBBox = (pathInput: PathArray | string) => {\n  if (!pathInput) {\n    return {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0,\n      x2: 0,\n      y2: 0,\n      cx: 0,\n      cy: 0,\n      cz: 0,\n    };\n  }\n\n  const path = parsePathString(pathInput);\n  let pathCommand = \"M\";\n  let mx = 0;\n  let my = 0;\n  const { max, min } = Math;\n  let xMin = Infinity;\n  let yMin = Infinity;\n  let xMax = -Infinity;\n  let yMax = -Infinity;\n  let minX = 0;\n  let minY = 0;\n  let maxX = 0;\n  let maxY = 0;\n  let paramX1 = 0;\n  let paramY1 = 0;\n  let paramX2 = 0;\n  let paramY2 = 0;\n  let paramQX = 0;\n  let paramQY = 0;\n\n  iterate(path, (seg, index, lastX, lastY) => {\n    [pathCommand] = seg;\n    const absCommand = pathCommand.toUpperCase();\n    const isRelative = absCommand !== pathCommand;\n    const absoluteSegment = isRelative\n      ? absolutizeSegment(seg, index, lastX, lastY)\n      : (seg.slice(0) as typeof seg);\n\n    const normalSegment = absCommand === \"V\"\n      ? ([\"L\", lastX, absoluteSegment[1]] as LSegment)\n      : absCommand === \"H\"\n      ? ([\"L\", absoluteSegment[1], lastY] as LSegment)\n      : absoluteSegment;\n\n    [pathCommand] = normalSegment;\n\n    if (!\"TQ\".includes(absCommand)) {\n      // optional but good to be cautious\n      paramQX = 0;\n      paramQY = 0;\n    }\n\n    // this segment is always ZERO\n    /* istanbul ignore else @preserve */\n    if (pathCommand === \"M\") {\n      [, mx, my] = normalSegment as MSegment;\n      minX = mx;\n      minY = my;\n      maxX = mx;\n      maxY = my;\n    } else if (pathCommand === \"L\") {\n      [minX, minY, maxX, maxY] = getLineBBox(\n        lastX,\n        lastY,\n        normalSegment[1] as number,\n        normalSegment[2] as number,\n      );\n    } else if (pathCommand === \"A\") {\n      [minX, minY, maxX, maxY] = getArcBBox(\n        lastX,\n        lastY,\n        normalSegment[1] as number,\n        normalSegment[2] as number,\n        normalSegment[3] as number,\n        normalSegment[4] as number,\n        normalSegment[5] as number,\n        normalSegment[6] as number,\n        normalSegment[7] as number,\n      );\n    } else if (pathCommand === \"S\") {\n      const cp1x = paramX1 * 2 - paramX2;\n      const cp1y = paramY1 * 2 - paramY2;\n\n      [minX, minY, maxX, maxY] = getCubicBBox(\n        lastX,\n        lastY,\n        cp1x,\n        cp1y,\n        normalSegment[1] as number,\n        normalSegment[2] as number,\n        normalSegment[3] as number,\n        normalSegment[4] as number,\n      );\n    } else if (pathCommand === \"C\") {\n      [minX, minY, maxX, maxY] = getCubicBBox(\n        lastX,\n        lastY,\n        normalSegment[1] as number,\n        normalSegment[2] as number,\n        normalSegment[3] as number,\n        normalSegment[4] as number,\n        normalSegment[5] as number,\n        normalSegment[6] as number,\n      );\n    } else if (pathCommand === \"T\") {\n      paramQX = paramX1 * 2 - paramQX;\n      paramQY = paramY1 * 2 - paramQY;\n      [minX, minY, maxX, maxY] = getQuadBBox(\n        lastX,\n        lastY,\n        paramQX,\n        paramQY,\n        normalSegment[1] as number,\n        normalSegment[2] as number,\n      );\n    } else if (pathCommand === \"Q\") {\n      paramQX = normalSegment[1] as number;\n      paramQY = normalSegment[2] as number;\n      [minX, minY, maxX, maxY] = getQuadBBox(\n        lastX,\n        lastY,\n        normalSegment[1] as number,\n        normalSegment[2] as number,\n        normalSegment[3] as number,\n        normalSegment[4] as number,\n      );\n    } else if (pathCommand === \"Z\") {\n      [minX, minY, maxX, maxY] = getLineBBox(lastX, lastY, mx, my);\n    }\n    xMin = min(minX, xMin);\n    yMin = min(minY, yMin);\n    xMax = max(maxX, xMax);\n    yMax = max(maxY, yMax);\n\n    // update params\n    [paramX1, paramY1] = pathCommand === \"Z\"\n      ? [mx, my]\n      : (normalSegment.slice(-2) as PointTuple);\n    [paramX2, paramY2] = pathCommand === \"C\"\n      ? ([normalSegment[3], normalSegment[4]] as PointTuple)\n      : pathCommand === \"S\"\n      ? ([normalSegment[1], normalSegment[2]] as PointTuple)\n      : [paramX1, paramY1];\n  });\n\n  const width = xMax - xMin;\n  const height = yMax - yMin;\n\n  return {\n    width,\n    height,\n    x: xMin,\n    y: yMin,\n    x2: xMax,\n    y2: yMax,\n    cx: xMin + width / 2,\n    cy: yMin + height / 2,\n    // an estimated guess\n    cz: Math.max(width, height) + Math.min(width, height) / 2,\n  } satisfies PathBBox;\n};\n\nexport default getPathBBox;\n","import type { PathArray, PathSegment } from \"../types\";\nimport getPropertiesAtLength from \"./getPropertiesAtLength\";\n\n/**\n * Returns the segment at a given length.\n *\n * @param pathInput the target `pathArray`\n * @param distance the distance in path to look at\n * @returns the requested segment\n */\nconst getSegmentAtLength = (\n  pathInput: string | PathArray,\n  distance?: number,\n): PathSegment | undefined => {\n  return getPropertiesAtLength(pathInput, distance).segment;\n};\n\nexport default getSegmentAtLength;\n","import type { SegmentProperties } from \"../interface\";\nimport type { PathArray } from \"../types\";\nimport getPropertiesAtPoint from \"./getPropertiesAtPoint\";\n\n/**\n * Returns the path segment which contains a given point.\n *\n * @param path the `pathArray` to look into\n * @param point the point of the shape to look for\n * @returns the requested segment\n */\nconst getSegmentOfPoint = (\n  path: string | PathArray,\n  point: { x: number; y: number },\n): SegmentProperties | undefined => {\n  return getPropertiesAtPoint(path, point).segment;\n};\nexport default getSegmentOfPoint;\n","import type { PathArray, PathSegment, RelativeCommand } from \"../types\";\nimport paramsCount from \"../parser/paramsCount\";\n\n/**\n * Iterates an array to check if it's an actual `pathArray`.\n *\n * @param path the `pathArray` to be checked\n * @returns iteration result\n */\nconst isPathArray = (path: unknown): path is PathArray => {\n  return (\n    Array.isArray(path) &&\n    path.every((seg: PathSegment) => {\n      const lk = seg[0].toLowerCase() as RelativeCommand;\n      return (\n        paramsCount[lk] === seg.length - 1 &&\n        \"achlmqstvz\".includes(lk) &&\n        (seg.slice(1) as unknown[]).every(Number.isFinite)\n      );\n    }) &&\n    path.length > 0\n  );\n};\nexport default isPathArray;\n","import type { AbsoluteArray } from \"../types\";\nimport isPathArray from \"./isPathArray\";\n\n/**\n * Iterates an array to check if it's a `pathArray`\n * with all absolute values.\n *\n * @param path the `pathArray` to be checked\n * @returns iteration result\n */\nconst isAbsoluteArray = (path: unknown): path is AbsoluteArray => {\n  return (\n    isPathArray(path) &&\n    // `isPathArray` also checks if it's `Array`\n    path.every(([x]) => x === x.toUpperCase())\n  );\n};\nexport default isAbsoluteArray;\n","import type { NormalArray } from \"../types\";\nimport isAbsoluteArray from \"./isAbsoluteArray\";\n\n/**\n * Iterates an array to check if it's a `pathArray`\n * with all segments are in non-shorthand notation\n * with absolute values.\n *\n * @param {string | SVGPath.pathArray} path the `pathArray` to be checked\n * @returns {boolean} iteration result\n */\nconst isNormalizedArray = (path: unknown): path is NormalArray => {\n  // `isAbsoluteArray` also checks if it's `Array`\n  return isAbsoluteArray(path) && path.every(([pc]) => \"ACLMQZ\".includes(pc));\n};\nexport default isNormalizedArray;\n","import { CurveArray } from \"../types\";\nimport isNormalizedArray from \"./isNormalizedArray\";\n\n/**\n * Iterates an array to check if it's a `pathArray`\n * with all C (cubic bezier) segments.\n *\n * @param path the `Array` to be checked\n * @returns iteration result\n */\nconst isCurveArray = (path: unknown): path is CurveArray => {\n  // `isPathArray` also checks if it's `Array`\n  return isNormalizedArray(path) && path.every(([pc]) => \"MC\".includes(pc));\n};\nexport default isCurveArray;\n","import type { PathArray } from \"../types\";\nimport getPropertiesAtPoint from \"./getPropertiesAtPoint\";\nimport DISTANCE_EPSILON from \"./distanceEpsilon\";\n\n/**\n * Checks if a given point is in the stroke of a path.\n *\n * @param pathInput target path\n * @param point the given `{x,y}` point\n * @returns the query result\n */\nconst isPointInStroke = (\n  pathInput: string | PathArray,\n  point: { x: number; y: number },\n) => {\n  const { distance } = getPropertiesAtPoint(pathInput, point);\n  return Math.abs(distance) < DISTANCE_EPSILON; // 0.01 might be more permissive\n};\nexport default isPointInStroke;\n","import type { RelativeArray } from \"../types\";\nimport isPathArray from \"./isPathArray\";\n\n/**\n * Iterates an array to check if it's a `pathArray`\n * with relative values.\n *\n * @param path the `pathArray` to be checked\n * @returns iteration result\n */\nconst isRelativeArray = (path: unknown): path is RelativeArray => {\n  return (\n    isPathArray(path) &&\n    // `isPathArray` checks if it's `Array`\n    path.slice(1).every(([pc]) => pc === pc.toLowerCase())\n  );\n};\nexport default isRelativeArray;\n","import scanSegment from \"../parser/scanSegment\";\nimport skipSpaces from \"../parser/skipSpaces\";\nimport PathParser from \"../parser/pathParser\";\n\n/**\n * Parses a path string value to determine its validity\n * then returns true if it's valid or false otherwise.\n *\n * @param pathString the path string to be parsed\n * @returns the path string validity\n */\nconst isValidPath = (pathString: string) => {\n  if (typeof pathString !== \"string\" || !pathString.length) {\n    return false;\n  }\n\n  const path = new PathParser(pathString);\n\n  skipSpaces(path);\n\n  while (path.index < path.max && !path.err.length) {\n    scanSegment(path);\n  }\n\n  return !path.err.length && \"mM\".includes(path.segments[0][0]);\n};\nexport default isValidPath;\n","import type { ShapeParams } from \"../interface\";\n\n/**\n * Supported shapes and their specific parameters.\n */\nconst shapeParams: ShapeParams = {\n  line: [\"x1\", \"y1\", \"x2\", \"y2\"],\n  circle: [\"cx\", \"cy\", \"r\"],\n  ellipse: [\"cx\", \"cy\", \"rx\", \"ry\"],\n  rect: [\"width\", \"height\", \"x\", \"y\", \"rx\", \"ry\"],\n  polygon: [\"points\"],\n  polyline: [\"points\"],\n  glyph: [\"d\"],\n};\n\nexport default shapeParams;\n","const isElement = (node?: unknown): node is Element =>\n  node !== undefined && node !== null &&\n  typeof node === \"object\" &&\n  (node as Node).nodeType === 1; // ELEMENT_NODE\n\nexport default isElement;\n","import type {\n  CircleAttr,\n  EllipseAttr,\n  GlyphAttr,\n  LineAttr,\n  PolyAttr,\n  RectAttr,\n  ShapeParams,\n} from \"../interface\";\nimport type { PathArray, PathSegment, ShapeOps, ShapeTypes } from \"../types\";\nimport error from \"../parser/error\";\nimport parsePathString from \"../parser/parsePathString\";\nimport shapeParams from \"./shapeParams\";\nimport isPathArray from \"./isPathArray\";\nimport isElement from \"./isElement\";\n\n/**\n * Returns a new `pathArray` from line attributes.\n *\n * @param attr shape configuration\n * @returns a new line `pathArray`\n */\nexport const getLinePath = (attr: LineAttr): PathArray => {\n  let { x1, y1, x2, y2 } = attr;\n  [x1, y1, x2, y2] = [x1, y1, x2, y2].map((a) => +a);\n  return [\n    [\"M\", x1, y1],\n    [\"L\", x2, y2],\n  ];\n};\n\n/**\n * Returns a new `pathArray` like from polyline/polygon attributes.\n *\n * @param attr shape configuration\n * @return a new polygon/polyline `pathArray`\n */\nexport const getPolyPath = (attr: PolyAttr): PathArray => {\n  const pathArray = [] as PathSegment[];\n  const points = (attr.points || \"\")\n    .trim()\n    .split(/[\\s|,]/)\n    .map((a) => +a);\n\n  let index = 0;\n  while (index < points.length) {\n    pathArray.push([index ? \"L\" : \"M\", points[index], points[index + 1]]);\n    index += 2;\n  }\n\n  return (attr.type === \"polygon\"\n    ? [...pathArray, [\"z\"]]\n    : pathArray) as PathArray;\n};\n\n/**\n * Returns a new `pathArray` from circle attributes.\n *\n * @param attr shape configuration\n * @return a circle `pathArray`\n */\nexport const getCirclePath = (attr: CircleAttr): PathArray => {\n  let { cx, cy, r } = attr;\n  [cx, cy, r] = [cx, cy, r].map((a) => +a);\n\n  return [\n    [\"M\", cx - r, cy],\n    [\"a\", r, r, 0, 1, 0, 2 * r, 0],\n    [\"a\", r, r, 0, 1, 0, -2 * r, 0],\n  ];\n};\n\n/**\n * Returns a new `pathArray` from ellipse attributes.\n *\n * @param attr shape configuration\n * @return an ellipse `pathArray`\n */\nexport const getEllipsePath = (attr: EllipseAttr): PathArray => {\n  let { cx, cy } = attr;\n  let rx = attr.rx || 0;\n  let ry = attr.ry || rx;\n  [cx, cy, rx, ry] = [cx, cy, rx, ry].map((a) => +a);\n\n  return [\n    [\"M\", cx - rx, cy],\n    [\"a\", rx, ry, 0, 1, 0, 2 * rx, 0],\n    [\"a\", rx, ry, 0, 1, 0, -2 * rx, 0],\n  ];\n};\n\n/**\n * Returns a new `pathArray` like from rect attributes.\n *\n * @param attr object with properties above\n * @return a new `pathArray` from `<rect>` attributes\n */\nexport const getRectanglePath = (attr: RectAttr): PathArray => {\n  const x = +attr.x || 0;\n  const y = +attr.y || 0;\n  const w = +attr.width;\n  const h = +attr.height;\n  let rx = +(attr.rx || 0);\n  let ry = +(attr.ry || rx);\n\n  // Validity checks from http://www.w3.org/TR/SVG/shapes.html#RectElement:\n  if (rx || ry) {\n    // rx = !rx ? ry : rx;\n    // ry = !ry ? rx : ry;\n\n    /* istanbul ignore else @preserve */\n    if (rx * 2 > w) rx -= (rx * 2 - w) / 2;\n    /* istanbul ignore else @preserve */\n    if (ry * 2 > h) ry -= (ry * 2 - h) / 2;\n\n    return [\n      [\"M\", x + rx, y],\n      [\"h\", w - rx * 2],\n      [\"s\", rx, 0, rx, ry],\n      [\"v\", h - ry * 2],\n      [\"s\", 0, ry, -rx, ry],\n      [\"h\", -w + rx * 2],\n      [\"s\", -rx, 0, -rx, -ry],\n      [\"v\", -h + ry * 2],\n      [\"s\", 0, -ry, rx, -ry],\n    ];\n  }\n\n  return [[\"M\", x, y], [\"h\", w], [\"v\", h], [\"H\", x], [\"Z\"]];\n};\n\n/**\n * Returns a new `pathArray` created from attributes of a `<line>`, `<polyline>`,\n * `<polygon>`, `<rect>`, `<ellipse>`, `<circle>`, <path> or `<glyph>`.\n *\n * It can also work with an options object, see the type below\n * @see ShapeOps\n *\n * @param element target shape\n * @return the newly created `<path>` element\n */\nconst shapeToPathArray = (\n  element: ShapeTypes | ShapeOps,\n) => {\n  const supportedShapes = Object.keys(shapeParams) as (keyof ShapeParams)[];\n  const targetIsElement = isElement(element);\n  const tagName = targetIsElement ? element.tagName : null;\n\n  if (tagName && [...supportedShapes, \"path\"].every((s) => tagName !== s)) {\n    throw TypeError(`${error}: \"${tagName}\" is not SVGElement`);\n  }\n\n  const type =\n    (targetIsElement ? tagName : (element as ShapeOps).type) as ShapeOps[\n      \"type\"\n    ];\n  const shapeAttrs = shapeParams[type] as string[];\n  const config = { type } as Record<string, string>;\n\n  if (targetIsElement) {\n    shapeAttrs.forEach((p) => {\n      config[p] = element.getAttribute(p) as string;\n    });\n  } else {\n    Object.assign(config, element);\n  }\n\n  // set d\n  let pathArray = [] as unknown as PathArray;\n\n  /* istanbul ignore else */\n  if (type === \"circle\") {\n    pathArray = getCirclePath(config as unknown as CircleAttr);\n  } else if (type === \"ellipse\") {\n    pathArray = getEllipsePath(config as unknown as EllipseAttr);\n  } else if ([\"polyline\", \"polygon\"].includes(type)) {\n    pathArray = getPolyPath(config as unknown as PolyAttr);\n  } else if (type === \"rect\") {\n    pathArray = getRectanglePath(config as unknown as RectAttr);\n  } else if (type === \"line\") {\n    pathArray = getLinePath(config as unknown as LineAttr);\n  } else if ([\"glyph\", \"path\"].includes(type)) {\n    pathArray = parsePathString(\n      targetIsElement\n        ? element.getAttribute(\"d\") || /* istanbul ignore next @preserve */ \"\"\n        : (element as GlyphAttr).d || \"\",\n    );\n  }\n\n  // replace target element\n  if (isPathArray(pathArray) && pathArray.length) {\n    return pathArray;\n  }\n  return false;\n};\nexport default shapeToPathArray;\n","import type { ShapeParams } from \"../interface\";\nimport type { ShapeOps, ShapeTypes } from \"../types\";\nimport pathToString from \"../convert/pathToString\";\nimport defaultOptions from \"../options/options\";\nimport error from \"../parser/error\";\nimport isValidPath from \"./isValidPath\";\nimport isElement from \"./isElement\";\nimport shapeToPathArray from \"./shapeToPathArray\";\nimport shapeParams from \"./shapeParams\";\n\n/**\n * Returns a new `<path>` element created from attributes of a `<line>`, `<polyline>`,\n * `<polygon>`, `<rect>`, `<ellipse>`, `<circle>` or `<glyph>`. If `replace` parameter\n * is `true`, it will replace the target. The default `ownerDocument` is your current\n * `document` browser page, if you want to use in server-side using `jsdom`, you can\n * pass the `jsdom` `document` to `ownDocument`.\n *\n * It can also work with an options object, see the type below\n * @see ShapeOps\n *\n * The newly created `<path>` element keeps all non-specific\n * attributes like `class`, `fill`, etc.\n *\n * @param element target shape\n * @param replace option to replace target\n * @param ownerDocument document for create element\n * @return the newly created `<path>` element\n */\nconst shapeToPath = (\n  element: ShapeTypes | ShapeOps,\n  replace?: boolean,\n  ownerDocument?: Document,\n): SVGPathElement | false => {\n  const doc = ownerDocument || document;\n  const supportedShapes = Object.keys(shapeParams) as (keyof ShapeParams)[];\n  const targetIsElement = isElement(element);\n  const tagName = targetIsElement ? element.tagName : null;\n\n  if (tagName === \"path\") {\n    throw TypeError(`${error}: \"${tagName}\" is already SVGPathElement`);\n  }\n  if (tagName && supportedShapes.every((s) => tagName !== s)) {\n    throw TypeError(`${error}: \"${tagName}\" is not SVGElement`);\n  }\n\n  const path = doc.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n  const type =\n    (targetIsElement ? tagName : (element as ShapeOps).type) as ShapeOps[\n      \"type\"\n    ];\n  const shapeAttrs = shapeParams[type] as string[];\n  const config = { type } as Record<string, string>;\n\n  // set d\n  const round = defaultOptions.round as number;\n  const pathArray = shapeToPathArray(element);\n  const description = pathArray && pathArray.length\n    ? pathToString(pathArray, round)\n    : \"\";\n\n  if (targetIsElement) {\n    shapeAttrs.forEach((p) => {\n      config[p] = element.getAttribute(p) as string;\n    });\n    // set no-specific shape attributes: fill, stroke, etc\n    Object.values(element.attributes).forEach(({ name, value }) => {\n      if (!shapeAttrs.includes(name)) path.setAttribute(name, value);\n    });\n  } else {\n    Object.assign(config, element);\n    // set no-specific shape attributes: fill, stroke, etc\n    Object.keys(config).forEach((k) => {\n      if (!shapeAttrs.includes(k) && k !== \"type\") {\n        path.setAttribute(\n          k.replace(/[A-Z]/g, (m) => `-${m.toLowerCase()}`),\n          config[k],\n        );\n      }\n    });\n  }\n\n  // replace target element\n  if (isValidPath(description)) {\n    path.setAttribute(\"d\", description);\n    if (replace && targetIsElement) {\n      element.before(path, element);\n      element.remove();\n    }\n    return path;\n  }\n  return false;\n};\n\nexport default shapeToPath;\n","import CSSMatrix from \"@thednp/dommatrix\";\n// import type { TransformObject } from '../interface';\nimport type { TransformObjectValues } from \"../types\";\n\n/**\n * Returns a transformation matrix to apply to `<path>` elements.\n *\n * @see TransformObjectValues\n *\n * @param transform the `transformObject`\n * @returns a new transformation matrix\n */\nconst getSVGMatrix = (transform: TransformObjectValues): CSSMatrix => {\n  let matrix = new CSSMatrix();\n  const { origin } = transform;\n  const [originX, originY] = origin as [number, number, number];\n  const { translate } = transform;\n  const { rotate } = transform;\n  const { skew } = transform;\n  const { scale } = transform;\n\n  // set translate\n  if (\n    Array.isArray(translate) &&\n    translate.length >= 2 &&\n    translate.every((x) => !Number.isNaN(+x)) &&\n    translate.some((x) => x !== 0)\n  ) {\n    matrix = matrix.translate(...(translate as [number, number, number?]));\n  } else if (typeof translate === \"number\" && !Number.isNaN(translate)) {\n    matrix = matrix.translate(translate);\n  }\n\n  if (rotate || skew || scale) {\n    // set SVG transform-origin, always defined\n    matrix = matrix.translate(originX, originY);\n\n    // set rotation\n    if (\n      Array.isArray(rotate) &&\n      rotate.length >= 2 &&\n      rotate.every((x) => !Number.isNaN(+x)) &&\n      rotate.some((x) => x !== 0)\n    ) {\n      matrix = matrix.rotate(...(rotate as [number, number, number?]));\n    } else if (typeof rotate === \"number\" && !Number.isNaN(rotate)) {\n      matrix = matrix.rotate(rotate);\n    }\n\n    // set skew(s)\n    if (\n      Array.isArray(skew) && skew.length === 2 && skew.every((x) =>\n        !Number.isNaN(+x)\n      ) && skew.some((x) => x !== 0)\n    ) {\n      matrix = skew[0] ? matrix.skewX(skew[0]) : matrix;\n      matrix = skew[1] ? matrix.skewY(skew[1]) : matrix;\n    } else if (typeof skew === \"number\" && !Number.isNaN(skew)) {\n      matrix = matrix.skewX(skew);\n    }\n\n    // set scale\n    if (\n      Array.isArray(scale) && scale.length >= 2 && scale.every((x) =>\n        !Number.isNaN(+x)\n      ) && scale.some((x) => x !== 1)\n    ) {\n      matrix = matrix.scale(...(scale as [number, number, number?]));\n    } else if (typeof scale === \"number\" && !Number.isNaN(scale)) {\n      matrix = matrix.scale(scale);\n    }\n    // set SVG transform-origin\n    matrix = matrix.translate(-originX, -originY);\n  }\n\n  return matrix;\n};\nexport default getSVGMatrix;\n","import defaultOptions from \"../options/options\";\nimport type { ParserParams } from \"../interface\";\nimport roundTo from \"../math/roundTo\";\nimport type {\n  AbsoluteSegment,\n  NormalSegment,\n  PathCommand,\n  ShortSegment,\n  SSegment,\n  TSegment,\n} from \"../types\";\n\n/**\n * Shorten a single segment of a `pathArray` object.\n *\n * @param segment the `absoluteSegment` object\n * @param normalSegment the `normalSegment` object\n * @param params the coordinates of the previous segment\n * @param prevCommand the path command of the previous segment\n * @returns the shortened segment\n */\nconst shortenSegment = (\n  segment: AbsoluteSegment,\n  normalSegment: NormalSegment,\n  params: ParserParams,\n  prevCommand: PathCommand,\n): ShortSegment => {\n  const [pathCommand] = segment;\n  const { round: defaultRound } = defaultOptions;\n  const round = typeof defaultRound === \"number\"\n    ? defaultRound\n    : /* istanbul ignore next */ 4;\n  const normalValues = normalSegment.slice(1) as number[];\n  const { x1, y1, x2, y2, x, y } = params;\n  const [nx, ny] = normalValues.slice(-2);\n  const result = segment;\n\n  if (!\"TQ\".includes(pathCommand)) {\n    // optional but good to be cautious\n    params.qx = null;\n    params.qy = null;\n  }\n\n  if (pathCommand === \"L\") {\n    if (roundTo(x, round) === roundTo(nx, round)) {\n      return [\"V\", ny];\n    } else if (roundTo(y, round) === roundTo(ny, round)) {\n      return [\"H\", nx];\n    }\n  } else if (pathCommand === \"C\") {\n    const [nx1, ny1] = normalValues;\n    params.x1 = nx1;\n    params.y1 = ny1;\n\n    if (\n      \"CS\".includes(prevCommand) &&\n      ((roundTo(nx1, round) === roundTo(x1 * 2 - x2, round) &&\n        roundTo(ny1, round) === roundTo(y1 * 2 - y2, round)) ||\n        (roundTo(x1, round) === roundTo(x2 * 2 - x, round) &&\n          roundTo(y1, round) === roundTo(y2 * 2 - y, round)))\n    ) {\n      return [\n        \"S\",\n        normalValues[2],\n        normalValues[3],\n        normalValues[4],\n        normalValues[5],\n      ] as SSegment;\n    }\n  } else if (pathCommand === \"Q\") {\n    const [qx, qy] = normalValues;\n    params.qx = qx;\n    params.qy = qy;\n\n    if (\n      \"QT\".includes(prevCommand) &&\n      roundTo(qx, round) === roundTo(x1 * 2 - x2, round) &&\n      roundTo(qy, round) === roundTo(y1 * 2 - y2, round)\n    ) {\n      return [\"T\", normalValues[2], normalValues[3]] as TSegment;\n    }\n  }\n\n  // ['V', 'H', 'S', 'T', 'Z'].includes(pathCommand)\n  return result as ShortSegment;\n};\n\nexport default shortenSegment;\n","import type { PathCommand, PathSegment } from \"../types\";\nimport roundTo from \"../math/roundTo\";\n\nconst roundSegment = <T extends PathSegment>(\n  segment: T,\n  roundOption: number,\n) => {\n  const values = (segment.slice(1) as number[]).map((n) =>\n    roundTo(n, roundOption)\n  );\n  return [segment[0] as PathCommand | number].concat(values) as T;\n};\n\nexport default roundSegment;\n","import type { AbsoluteSegment, PathArray, PathCommand } from \"../types\";\nimport pathToAbsolute from \"../convert/pathToAbsolute\";\nimport shortenSegment from \"./shortenSegment\";\nimport paramsParser from \"../parser/paramsParser\";\nimport iterate from \"./iterate\";\nimport normalizeSegment from \"./normalizeSegment\";\nimport relativizeSegment from \"./relativizeSegment\";\nimport roundSegment from \"./roundSegment\";\n\n/**\n * Optimizes a `pathArray` object:\n * * convert segments to shorthand if possible\n * * select shortest segments from absolute and relative `pathArray`s\n *\n * @param pathInput a string or `pathArray`\n * @param roundOption the amount of decimals to round values to\n * @returns the optimized `pathArray`\n */\nconst optimizePath = (pathInput: PathArray, roundOption?: number) => {\n  const path = pathToAbsolute(pathInput);\n  // allow for ZERO decimals or use an aggressive value of 2\n  const round = typeof roundOption === \"number\" && roundOption >= 0\n    ? roundOption\n    : /* istanbul ignore next @preserve */ 2;\n  // this utility overrides the iterator params\n  const optimParams = { ...paramsParser };\n\n  const allPathCommands = [] as PathCommand[];\n  let pathCommand = \"M\" as PathCommand;\n  let prevCommand = \"Z\" as PathCommand;\n\n  return iterate(path, (seg, i, lastX, lastY) => {\n    optimParams.x = lastX;\n    optimParams.y = lastY;\n    const normalizedSegment = normalizeSegment(seg, optimParams);\n    let result = seg;\n    [pathCommand] = seg;\n\n    // Save current path command\n    allPathCommands[i] = pathCommand;\n    if (i) {\n      // Get previous path command for `shortenSegment`\n      prevCommand = allPathCommands[i - 1];\n      const shortSegment = shortenSegment(\n        seg as AbsoluteSegment,\n        normalizedSegment,\n        optimParams,\n        prevCommand,\n      );\n      const absSegment = roundSegment(shortSegment, round);\n      const absString = absSegment.join(\"\");\n      const relativeSegment = relativizeSegment(shortSegment, i, lastX, lastY);\n      const relSegment = roundSegment(relativeSegment, round);\n      const relString = relSegment.join(\"\");\n      result = absString.length < relString.length ? absSegment : relSegment;\n    }\n\n    const seglen = normalizedSegment.length;\n    optimParams.x1 = +normalizedSegment[seglen - 2];\n    optimParams.y1 = +normalizedSegment[seglen - 1];\n    optimParams.x2 = +normalizedSegment[seglen - 4] || optimParams.x1;\n    optimParams.y2 = +normalizedSegment[seglen - 3] || optimParams.y1;\n\n    return result;\n  });\n};\n\nexport default optimizePath;\n","import CSSMatrix from \"@thednp/dommatrix\";\nimport { type PointTuple } from \"../types\";\n\n/**\n * Transforms a specified point using a matrix, returning a new\n * Tuple *Object* comprising of the transformed point.\n * Neither the matrix nor the original point are altered.\n *\n * @copyright thednp  2021\n *\n * @param cssm CSSMatrix instance\n * @param v Tuple\n * @return the resulting Tuple\n */\nconst translatePoint = (\n  cssm: CSSMatrix,\n  v: [number, number, number, number],\n): [number, number, number, number] => {\n  let m = CSSMatrix.Translate(v[0], v[1], v[2]);\n\n  [, , , m.m44] = v;\n  m = cssm.multiply(m);\n\n  return [m.m41, m.m42, m.m43, m.m44];\n};\n\n/**\n * Returns the [x,y] projected coordinates for a given an [x,y] point\n * and an [x,y,z] perspective origin point.\n *\n * Equation found here =>\n * http://en.wikipedia.org/wiki/3D_projection#Diagram\n * Details =>\n * https://stackoverflow.com/questions/23792505/predicted-rendering-of-css-3d-transformed-pixel\n *\n * @param m the transformation matrix\n * @param point2D the initial [x,y] coordinates\n * @param origin the [x,y,z] transform origin\n * @returns the projected [x,y] coordinates\n */\nconst projection2d = (\n  m: CSSMatrix,\n  point2D: PointTuple,\n  origin: [number, number, number],\n): PointTuple => {\n  const [originX, originY, originZ] = origin;\n  const [x, y, z] = translatePoint(m, [point2D[0], point2D[1], 0, 1]);\n\n  const relativePositionX = x - originX;\n  const relativePositionY = y - originY;\n  const relativePositionZ = z - originZ;\n\n  return [\n    // protect against division by ZERO\n    relativePositionX * (Math.abs(originZ) / Math.abs(relativePositionZ) || 1) +\n    originX,\n    relativePositionY * (Math.abs(originZ) / Math.abs(relativePositionZ) || 1) +\n    originY,\n  ];\n};\nexport default projection2d;\n","import type { CSegment, CurveArray, MSegment, PathCommand } from \"../types\";\n\n/**\n * Reverses all segments of a `pathArray`\n * which consists of only C (cubic-bezier) path commands.\n *\n * @param path the source `pathArray`\n * @returns the reversed `pathArray`\n */\nconst reverseCurve = (path: CurveArray) => {\n  const rotatedCurve = path\n    .slice(1)\n    .map((x, i, curveOnly) =>\n      !i\n        ? path[0].slice(1).concat(x.slice(1) as number[])\n        : curveOnly[i - 1].slice(-2).concat(x.slice(1))\n    )\n    .map((x) => x.map((_, i) => x[x.length - i - 2 * (1 - (i % 2))]))\n    .reverse() as (MSegment | CSegment)[];\n\n  return [[\"M\" as PathCommand | number].concat(rotatedCurve[0].slice(0, 2))]\n    .concat(\n      rotatedCurve.map((x) => [\"C\" as PathCommand | number].concat(x.slice(2))),\n    ) as CurveArray;\n};\n\nexport default reverseCurve;\n","import type {\n  ASegment,\n  CSegment,\n  HSegment,\n  MSegment,\n  PathArray,\n  PathSegment,\n  PointTuple,\n  QSegment,\n  SSegment,\n  TSegment,\n  VSegment,\n} from \"../types\";\nimport pathToAbsolute from \"../convert/pathToAbsolute\";\nimport normalizePath from \"./normalizePath\";\nimport iterate from \"./iterate\";\n\n/**\n * Reverses all segments of a `pathArray` and returns a new `pathArray` instance\n * with absolute values.\n *\n * @param pathInput the source `pathArray`\n * @returns the reversed `pathArray`\n */\nconst reversePath = (pathInput: PathArray) => {\n  const absolutePath = pathToAbsolute(pathInput);\n  const normalizedPath = normalizePath(absolutePath);\n  const pLen = absolutePath.length;\n  const isClosed = absolutePath[pLen - 1][0] === \"Z\";\n\n  const reversedPath = iterate(absolutePath, (segment, i) => {\n    const normalizedSegment = normalizedPath[i];\n    const prevSeg = i && absolutePath[i - 1];\n    const prevCommand = prevSeg && prevSeg[0];\n    const nextSeg = absolutePath[i + 1];\n    const nextCommand = nextSeg && nextSeg[0];\n    const [pathCommand] = segment;\n    const [x, y] = normalizedPath[i ? i - 1 : pLen - 1].slice(-2) as PointTuple;\n    let result = segment;\n\n    switch (pathCommand) {\n      case \"M\":\n        result = (isClosed ? [\"Z\"] : [pathCommand, x, y]) as PathSegment;\n        break;\n      case \"A\":\n        result = [\n          pathCommand,\n          segment[1],\n          segment[2],\n          segment[3],\n          segment[4],\n          segment[5] === 1 ? 0 : 1,\n          x,\n          y,\n        ] as ASegment;\n        break;\n      case \"C\":\n        if (nextSeg && nextCommand === \"S\") {\n          result = [\"S\", segment[1], segment[2], x, y] as SSegment;\n        } else {\n          result = [\n            pathCommand,\n            segment[3],\n            segment[4],\n            segment[1],\n            segment[2],\n            x,\n            y,\n          ] as CSegment;\n        }\n        break;\n      case \"S\":\n        if (\n          prevCommand && \"CS\".includes(prevCommand) &&\n          (!nextSeg || nextCommand !== \"S\")\n        ) {\n          result = [\n            \"C\",\n            normalizedSegment[3],\n            normalizedSegment[4],\n            normalizedSegment[1],\n            normalizedSegment[2],\n            x,\n            y,\n          ] as CSegment;\n        } else {\n          result = [\n            pathCommand,\n            normalizedSegment[1],\n            normalizedSegment[2],\n            x,\n            y,\n          ] as SSegment;\n        }\n        break;\n      case \"Q\":\n        if (nextSeg && nextCommand === \"T\") {\n          result = [\"T\", x, y] as TSegment;\n        } else {\n          result = [pathCommand, segment[1], segment[2], x, y] as QSegment;\n        }\n        break;\n      case \"T\":\n        if (\n          prevCommand && \"QT\".includes(prevCommand) &&\n          (!nextSeg || nextCommand !== \"T\")\n        ) {\n          result = [\n            \"Q\",\n            normalizedSegment[1],\n            normalizedSegment[2],\n            x,\n            y,\n          ] as QSegment;\n        } else {\n          result = [pathCommand, x, y] as TSegment;\n        }\n        break;\n      case \"Z\":\n        result = [\"M\", x, y] as MSegment;\n        break;\n      case \"H\":\n        result = [pathCommand, x] as HSegment;\n        break;\n      case \"V\":\n        result = [pathCommand, y] as VSegment;\n        break;\n      default:\n        result = [pathCommand as typeof pathCommand | number].concat(\n          segment.slice(1, -2),\n          x,\n          y,\n        ) as PathSegment;\n    }\n\n    return result;\n  });\n\n  return (\n    isClosed\n      ? reversedPath.reverse()\n      : [reversedPath[0] as PathSegment].concat(reversedPath.slice(1).reverse())\n  ) as PathArray;\n};\n\nexport default reversePath;\n","import type { PathArray } from \"../types\";\nimport defaultOptions from \"../options/options\";\nimport iterate from \"./iterate\";\nimport roundSegment from \"./roundSegment\";\n\n/**\n * Rounds the values of a `pathArray` instance to\n * a specified amount of decimals and returns it.\n *\n * @param path the source `pathArray`\n * @param roundOption the amount of decimals to round numbers to\n * @returns the resulted `pathArray` with rounded values\n */\nconst roundPath = (path: PathArray, roundOption?: number | \"off\") => {\n  let { round } = defaultOptions;\n  // allow for ZERO decimals\n  round = roundOption === \"off\"\n    ? roundOption\n    : typeof roundOption === \"number\" && roundOption >= 0\n    ? roundOption\n    : typeof round === \"number\" && round >= 0\n    ? round\n    : /* istanbul ignore next @preserve */ \"off\";\n\n  /* istanbul ignore else @preserve */\n  if (round === \"off\") return path.slice(0) as PathArray;\n\n  return iterate<typeof path>(path, (segment) => {\n    return roundSegment(segment, round);\n  });\n};\nexport default roundPath;\n","import midPoint from \"../math/midPoint\";\nimport type { CubicSegment, PointTuple } from \"../types\";\n\n/**\n * Split a cubic-bezier segment into two.\n *\n * @param pts the cubic-bezier parameters\n * @param ratio the cubic-bezier parameters\n * @return two new cubic-bezier segments\n */\nconst splitCubic = (\n  pts: number[],\n  ratio = 0.5,\n): [CubicSegment, CubicSegment] => {\n  const t = ratio;\n  const p0 = pts.slice(0, 2) as PointTuple;\n  const p1 = pts.slice(2, 4) as PointTuple;\n  const p2 = pts.slice(4, 6) as PointTuple;\n  const p3 = pts.slice(6, 8) as PointTuple;\n  const p4 = midPoint(p0, p1, t);\n  const p5 = midPoint(p1, p2, t);\n  const p6 = midPoint(p2, p3, t);\n  const p7 = midPoint(p4, p5, t);\n  const p8 = midPoint(p5, p6, t);\n  const p9 = midPoint(p7, p8, t);\n\n  return [\n    [\"C\", p4[0], p4[1], p7[0], p7[1], p9[0], p9[1]],\n    [\"C\", p8[0], p8[1], p6[0], p6[1], p3[0], p3[1]],\n  ];\n};\nexport default splitCubic;\n","import paramsParser from \"../parser/paramsParser\";\nimport type {\n  AbsoluteCommand,\n  HSegment,\n  MSegment,\n  PathArray,\n  PointTuple,\n  RelativeCommand,\n  VSegment,\n} from \"../types\";\n\n/**\n * Split a path into an `Array` of sub-path strings.\n *\n * In the process, values are converted to absolute\n * for visual consistency.\n *\n * @param pathInput the source `pathArray`\n * @return an array with all sub-path strings\n */\nconst splitPath = (pathInput: PathArray): PathArray[] => {\n  const composite = [] as PathArray[];\n  let path: PathArray;\n  let pi = -1;\n  let x = 0;\n  let y = 0;\n  let mx = 0;\n  let my = 0;\n  const params = { ...paramsParser };\n\n  pathInput.forEach((seg) => {\n    const [pathCommand] = seg;\n    const absCommand = pathCommand.toUpperCase() as AbsoluteCommand;\n    const relCommand = pathCommand.toLowerCase() as RelativeCommand;\n    const isRelative = pathCommand === relCommand;\n    const values = seg.slice(1) as number[];\n\n    if (absCommand === \"M\") {\n      pi += 1;\n      [x, y] = values as PointTuple;\n      x += isRelative ? params.x : 0;\n      y += isRelative ? params.y : 0;\n      mx = x;\n      my = y;\n      path = [(isRelative ? [absCommand, mx, my] : seg) as MSegment];\n    } else {\n      if (absCommand === \"Z\") {\n        x = mx;\n        y = my;\n      } else if (absCommand === \"H\") {\n        [, x] = seg as HSegment;\n        x += isRelative ? params.x : /* istanbul ignore next @preserve */ 0;\n      } else if (absCommand === \"V\") {\n        [, y] = seg as VSegment;\n        y += isRelative ? params.y : /* istanbul ignore next @preserve */ 0;\n      } else {\n        [x, y] = seg.slice(-2) as PointTuple;\n        x += isRelative ? params.x : 0;\n        y += isRelative ? params.y : 0;\n      }\n      path.push(seg);\n    }\n\n    params.x = x;\n    params.y = y;\n    composite[pi] = path;\n  });\n\n  return composite;\n};\nexport default splitPath;\n","import getSVGMatrix from \"./getSVGMatrix\";\nimport projection2d from \"./projection2d\";\nimport defaultOptions from \"../options/options\";\nimport type {\n  AbsoluteArray,\n  AbsoluteSegment,\n  CSegment,\n  LSegment,\n  PathArray,\n  TransformObjectValues,\n} from \"../types\";\nimport type { TransformObject } from \"../interface\";\nimport iterate from \"./iterate\";\nimport parsePathString from \"../parser/parsePathString\";\nimport absolutizeSegment from \"./absolutizeSegment\";\nimport arcToCubic from \"./arcToCubic\";\n\n/**\n * Apply a 2D / 3D transformation to a `pathArray` instance.\n *\n * Since *SVGElement* doesn't support 3D transformation, this function\n * creates a 2D projection of the <path> element.\n *\n * @param path the `pathArray` to apply transformation\n * @param transform the transform functions `Object`\n * @returns the resulted `pathArray`\n */\nconst transformPath = (\n  pathInput: PathArray | string,\n  transform?: Partial<TransformObject>,\n) => {\n  // last x and y transformed values\n  let x = 0;\n  let y = 0;\n  // new x and y transformed\n  let lx = 0;\n  let ly = 0;\n  // segment params iteration index and length\n  let j = 0;\n  let jj = 0;\n  let pathCommand = \"M\";\n  // transform uses it's own set of params\n  const path = parsePathString(pathInput);\n  const transformProps = transform && Object.keys(transform);\n\n  // when used as a static method, invalidate somehow\n  if (!transform || (transformProps && !transformProps.length)) {\n    return path.slice(0) as typeof path;\n  }\n\n  // transform origin is extremely important\n  if (!transform.origin) {\n    Object.assign(transform, { origin: defaultOptions.origin });\n  }\n  const origin = transform.origin as [number, number, number];\n  const matrixInstance = getSVGMatrix(transform as TransformObjectValues);\n\n  if (matrixInstance.isIdentity) return path.slice(0) as typeof path;\n\n  return iterate<AbsoluteArray>(path, (seg, index, lastX, lastY) => {\n    [pathCommand] = seg;\n    const absCommand = pathCommand.toUpperCase();\n    const isRelative = absCommand !== pathCommand;\n    const absoluteSegment = isRelative\n      ? absolutizeSegment(seg, index, lastX, lastY)\n      : (seg.slice(0) as AbsoluteSegment);\n\n    let result = absCommand === \"A\"\n      // ? segmentToCubic(absoluteSegment, transformParams)\n      ? ([\"C\" as string | number].concat(\n        arcToCubic(\n          lastX,\n          lastY,\n          absoluteSegment[1] as number,\n          absoluteSegment[2] as number,\n          absoluteSegment[3] as number,\n          absoluteSegment[4] as number,\n          absoluteSegment[5] as number,\n          absoluteSegment[6] as number,\n          absoluteSegment[7] as number,\n        ),\n      ) as CSegment)\n      : absCommand === \"V\"\n      ? ([\"L\", lastX, absoluteSegment[1]] as LSegment)\n      : absCommand === \"H\"\n      ? ([\"L\", absoluteSegment[1], lastY] as LSegment)\n      : absoluteSegment;\n\n    // update pathCommand\n    pathCommand = result[0];\n    const isLongArc = pathCommand === \"C\" && result.length > 7;\n    const tempSegment =\n      (isLongArc ? result.slice(0, 7) : result.slice(0)) as AbsoluteSegment;\n\n    if (isLongArc) {\n      path.splice(\n        index + 1,\n        0,\n        [\"C\" as typeof pathCommand | number].concat(\n          result.slice(7),\n        ) as CSegment,\n      );\n      result = tempSegment as CSegment;\n    }\n\n    if (pathCommand === \"L\") {\n      [lx, ly] = projection2d(matrixInstance, [\n        (result as LSegment)[1],\n        (result as LSegment)[2],\n      ], origin);\n\n      /* istanbul ignore else @preserve */\n      if (x !== lx && y !== ly) {\n        result = [\"L\", lx, ly];\n      } else if (y === ly) {\n        result = [\"H\", lx];\n      } else if (x === lx) {\n        result = [\"V\", ly];\n      }\n    } else {\n      for (j = 1, jj = result.length; j < jj; j += 2) {\n        [lx, ly] = projection2d(\n          matrixInstance,\n          [+result[j], +result[j + 1]],\n          origin,\n        );\n        result[j] = lx;\n        result[j + 1] = ly;\n      }\n    }\n    // now update x and y\n    x = lx;\n    y = ly;\n\n    return result;\n  });\n};\n\nexport default transformPath;\n","\"use strict\";\nimport CSSMatrix from \"@thednp/dommatrix\";\nimport { PathArray, PointTuple, TransformObjectValues } from \"./types\";\nimport type { Options, TransformEntries, TransformObject } from \"./interface\";\nexport * from \"./types\";\nexport * from \"./interface\";\nimport defaultOptions from \"./options/options\";\n\nimport pathToAbsolute from \"./convert/pathToAbsolute\";\nimport pathToRelative from \"./convert/pathToRelative\";\nimport pathToCurve from \"./convert/pathToCurve\";\nimport pathToString from \"./convert/pathToString\";\nimport * as arcTools from \"./math/arcTools\";\nimport {\n  bezierLength,\n  calculateBezier,\n  CBEZIER_MINMAX_EPSILON,\n  computeBezier,\n  Cvalues,\n  deriveBezier,\n  getBezierLength,\n  minmaxC,\n  minmaxQ,\n  Tvalues,\n} from \"./math/bezier\";\nimport {\n  getCubicBBox,\n  getCubicLength,\n  getPointAtCubicLength,\n  getPointAtCubicSegmentLength,\n} from \"./math/cubicTools\";\nimport {\n  getLineBBox,\n  getLineLength,\n  getPointAtLineLength,\n} from \"./math/lineTools\";\nimport {\n  getPointAtQuadLength,\n  getPointAtQuadSegmentLength,\n  getQuadBBox,\n  getQuadLength,\n} from \"./math/quadTools\";\nimport { polygonArea, polygonLength } from \"./math/polygonTools\";\n\nimport distanceSquareRoot from \"./math/distanceSquareRoot\";\nimport midPoint from \"./math/midPoint\";\nimport rotateVector from \"./math/rotateVector\";\nimport roundTo from \"./math/roundTo\";\n\nimport error from \"./parser/error\";\nimport parsePathString from \"./parser/parsePathString\";\nimport finalizeSegment from \"./parser/finalizeSegment\";\nimport invalidPathValue from \"./parser/invalidPathValue\";\nimport isArcCommand from \"./parser/isArcCommand\";\nimport isDigit from \"./parser/isDigit\";\nimport isDigitStart from \"./parser/isDigitStart\";\nimport isMoveCommand from \"./parser/isMoveCommand\";\nimport isPathCommand from \"./parser/isPathCommand\";\nimport isSpace from \"./parser/isSpace\";\nimport paramsCount from \"./parser/paramsCount\";\nimport paramsParser from \"./parser/paramsParser\";\nimport pathParser from \"./parser/pathParser\";\nimport scanFlag from \"./parser/scanFlag\";\nimport scanParam from \"./parser/scanParam\";\nimport scanSegment from \"./parser/scanSegment\";\nimport skipSpaces from \"./parser/skipSpaces\";\n\nimport distanceEpsilon from \"./util/distanceEpsilon\";\nimport getClosestPoint from \"./util/getClosestPoint\";\nimport getDrawDirection from \"./util/getDrawDirection\";\nimport getPathArea from \"./util/getPathArea\";\nimport getPathBBox from \"./util/getPathBBox\";\nimport getPointAtLength from \"./util/getPointAtLength\";\nimport getPropertiesAtLength from \"./util/getPropertiesAtLength\";\nimport getPropertiesAtPoint from \"./util/getPropertiesAtPoint\";\nimport getSegmentAtLength from \"./util/getSegmentAtLength\";\nimport getSegmentOfPoint from \"./util/getSegmentOfPoint\";\nimport getTotalLength from \"./util/getTotalLength\";\n\nimport isAbsoluteArray from \"./util/isAbsoluteArray\";\nimport isCurveArray from \"./util/isCurveArray\";\nimport isNormalizedArray from \"./util/isNormalizedArray\";\nimport isPathArray from \"./util/isPathArray\";\nimport isPointInStroke from \"./util/isPointInStroke\";\nimport isRelativeArray from \"./util/isRelativeArray\";\nimport isValidPath from \"./util/isValidPath\";\nimport shapeParams from \"./util/shapeParams\";\nimport shapeToPath from \"./util/shapeToPath\";\nimport shapeToPathArray from \"./util/shapeToPathArray\";\n\nimport absolutizeSegment from \"./process/absolutizeSegment\";\nimport arcToCubic from \"./process/arcToCubic\";\nimport getSVGMatrix from \"./process/getSVGMatrix\";\nimport iterate from \"./process/iterate\";\nimport lineToCubic from \"./process/lineToCubic\";\nimport normalizePath from \"./process/normalizePath\";\nimport normalizeSegment from \"./process/normalizeSegment\";\nimport optimizePath from \"./process/optimizePath\";\nimport projection2d from \"./process/projection2d\";\nimport quadToCubic from \"./process/quadToCubic\";\nimport relativizeSegment from \"./process/relativizeSegment\";\nimport reverseCurve from \"./process/reverseCurve\";\nimport reversePath from \"./process/reversePath\";\nimport roundPath from \"./process/roundPath\";\nimport roundSegment from \"./process/roundSegment\";\nimport segmentToCubic from \"./process/segmentToCubic\";\nimport shortenSegment from \"./process/shortenSegment\";\nimport splitCubic from \"./process/splitCubic\";\nimport splitPath from \"./process/splitPath\";\nimport transformPath from \"./process/transformPath\";\n\n/**\n * Creates a new SVGPathCommander instance with the following properties:\n * * segments: `pathArray`\n * * round: number\n * * origin: [number, number, number?]\n *\n * @class\n * @author thednp <https://github.com/thednp/svg-path-commander>\n * @returns a new SVGPathCommander instance\n */\nclass SVGPathCommander {\n  public static CSSMatrix = CSSMatrix;\n  public static pathToAbsolute = pathToAbsolute;\n  public static pathToRelative = pathToRelative;\n  public static pathToCurve = pathToCurve;\n  public static pathToString = pathToString;\n  public static arcTools = arcTools;\n  public static bezierTools = {\n    Cvalues,\n    Tvalues,\n    minmaxC,\n    minmaxQ,\n    getBezierLength,\n    bezierLength,\n    calculateBezier,\n    computeBezier,\n    deriveBezier,\n    CBEZIER_MINMAX_EPSILON,\n  };\n  public static cubicTools = {\n    getCubicLength,\n    getCubicBBox,\n    getPointAtCubicLength,\n    getPointAtCubicSegmentLength,\n  };\n  public static lineTools = {\n    getPointAtLineLength,\n    getLineBBox,\n    getLineLength,\n  };\n  public static quadTools = {\n    getPointAtQuadSegmentLength,\n    getQuadLength,\n    getQuadBBox,\n    getPointAtQuadLength,\n  };\n  public static polygonTools = { polygonArea, polygonLength };\n  public static distanceSquareRoot = distanceSquareRoot;\n  public static distanceEpsilon = distanceEpsilon;\n  public static midPoint = midPoint;\n  public static rotateVector = rotateVector;\n  public static roundTo = roundTo;\n  public static finalizeSegment = finalizeSegment;\n  public static invalidPathValue = invalidPathValue;\n  public static isArcCommand = isArcCommand;\n  public static isDigit = isDigit;\n  public static isDigitStart = isDigitStart;\n  public static isMoveCommand = isMoveCommand;\n  public static isPathCommand = isPathCommand;\n  public static isSpace = isSpace;\n  public static paramsCount = paramsCount;\n  public static paramsParser = paramsParser;\n  public static pathParser = pathParser;\n  public static scanFlag = scanFlag;\n  public static scanParam = scanParam;\n  public static scanSegment = scanSegment;\n  public static skipSpaces = skipSpaces;\n  public static getPathBBox = getPathBBox;\n  public static getPathArea = getPathArea;\n  public static getTotalLength = getTotalLength;\n  public static getDrawDirection = getDrawDirection;\n  public static getPointAtLength = getPointAtLength;\n  public static getPropertiesAtLength = getPropertiesAtLength;\n  public static getPropertiesAtPoint = getPropertiesAtPoint;\n  public static getClosestPoint = getClosestPoint;\n  public static getSegmentOfPoint = getSegmentOfPoint;\n  public static getSegmentAtLength = getSegmentAtLength;\n  public static isPointInStroke = isPointInStroke;\n  public static isValidPath = isValidPath;\n  public static isPathArray = isPathArray;\n  public static isAbsoluteArray = isAbsoluteArray;\n  public static isRelativeArray = isRelativeArray;\n  public static isCurveArray = isCurveArray;\n  public static isNormalizedArray = isNormalizedArray;\n  public static shapeToPath = shapeToPath;\n  public static shapeToPathArray = shapeToPathArray;\n  public static shapeParams = shapeParams;\n  public static parsePathString = parsePathString;\n  public static absolutizeSegment = absolutizeSegment;\n  public static arcToCubic = arcToCubic;\n  public static getSVGMatrix = getSVGMatrix;\n  public static iterate = iterate;\n  public static lineToCubic = lineToCubic;\n  public static normalizePath = normalizePath;\n  public static normalizeSegment = normalizeSegment;\n  public static optimizePath = optimizePath;\n  public static projection2d = projection2d;\n  public static quadToCubic = quadToCubic;\n  public static relativizeSegment = relativizeSegment;\n  public static reverseCurve = reverseCurve;\n  public static reversePath = reversePath;\n  public static roundPath = roundPath;\n  public static roundSegment = roundSegment;\n  public static segmentToCubic = segmentToCubic;\n  public static shortenSegment = shortenSegment;\n  public static splitCubic = splitCubic;\n  public static splitPath = splitPath;\n  public static transformPath = transformPath;\n  // declare class properties\n  declare segments: PathArray;\n  declare round: number | \"off\";\n  declare origin: [number, number, number];\n\n  /**\n   * @constructor\n   * @param pathValue the path string\n   * @param config instance options\n   */\n  constructor(pathValue: string, config?: Partial<Options>) {\n    const instanceOptions = config || {};\n    const undefPath = typeof pathValue === \"undefined\";\n\n    if (undefPath || !pathValue.length) {\n      throw TypeError(\n        `${error}: \"pathValue\" is ${undefPath ? \"undefined\" : \"empty\"}`,\n      );\n    }\n\n    this.segments = parsePathString(pathValue);\n\n    // // set instance options.round\n    const { round: roundOption, origin: originOption } = instanceOptions;\n    let round: number | \"off\";\n\n    if (Number.isInteger(roundOption) || roundOption === \"off\") {\n      round = roundOption as number | \"off\";\n    } else {\n      round = defaultOptions.round as number;\n    }\n\n    // set instance options.origin\n    // the SVGPathCommander class will always override the default origin\n    let origin = defaultOptions.origin as [number, number, number];\n    /* istanbul ignore else @preserve */\n    if (Array.isArray(originOption) && originOption.length >= 2) {\n      const [originX, originY, originZ] = originOption.map(Number);\n      origin = [\n        !Number.isNaN(originX) ? originX : 0,\n        !Number.isNaN(originY) ? originY : 0,\n        !Number.isNaN(originZ) ? originZ : 0,\n      ];\n    }\n\n    this.round = round;\n    this.origin = origin;\n\n    return this;\n  }\n  get bbox() {\n    return getPathBBox(this.segments);\n  }\n  get length() {\n    return getTotalLength(this.segments);\n  }\n\n  /**\n   * Returns the path bounding box, equivalent to native `path.getBBox()`.\n   *\n   * @public\n   * @returns the pathBBox\n   */\n  getBBox() {\n    return this.bbox;\n  }\n\n  /**\n   * Returns the total path length, equivalent to native `path.getTotalLength()`.\n   *\n   * @public\n   * @returns the path total length\n   */\n  getTotalLength() {\n    return this.length;\n  }\n\n  /**\n   * Returns an `{x,y}` point in the path stroke at a given length,\n   * equivalent to the native `path.getPointAtLength()`.\n   *\n   * @public\n   * @param length the length\n   * @returns the requested point\n   */\n  getPointAtLength(length: number) {\n    return getPointAtLength(this.segments, length);\n  }\n\n  /**\n   * Convert path to absolute values\n   *\n   * @public\n   */\n  toAbsolute() {\n    const { segments } = this;\n    this.segments = pathToAbsolute(segments);\n    return this;\n  }\n\n  /**\n   * Convert path to relative values\n   *\n   * @public\n   */\n  toRelative() {\n    const { segments } = this;\n    this.segments = pathToRelative(segments);\n    return this;\n  }\n\n  /**\n   * Convert path to cubic-bezier values. In addition, un-necessary `Z`\n   * segment is removed if previous segment extends to the `M` segment.\n   *\n   * @public\n   */\n  toCurve() {\n    const { segments } = this;\n    this.segments = pathToCurve(segments);\n    return this;\n  }\n\n  /**\n   * Reverse the order of the segments and their values.\n   *\n   * @param onlySubpath option to reverse all sub-paths except first\n   * @public\n   */\n  reverse(onlySubpath?: boolean) {\n    const { segments } = this;\n    const split = splitPath(segments);\n    const subPath = split.length > 1 ? split : false;\n\n    const absoluteMultiPath = subPath\n      ? subPath.map((x, i) => {\n        if (onlySubpath) {\n          return i ? reversePath(x) : x.slice(0);\n        }\n        return reversePath(x);\n      })\n      : segments.slice(0);\n\n    let path = [] as unknown as PathArray;\n    if (subPath) {\n      path = absoluteMultiPath.flat(1) as PathArray;\n    } else {\n      path = onlySubpath ? segments : reversePath(segments);\n    }\n\n    this.segments = path.slice(0) as PathArray;\n    return this;\n  }\n\n  /**\n   * Normalize path in 2 steps:\n   * * convert `pathArray`(s) to absolute values\n   * * convert shorthand notation to standard notation\n   *\n   * @public\n   */\n  normalize() {\n    const { segments } = this;\n    this.segments = normalizePath(segments);\n    return this;\n  }\n\n  /**\n   * Optimize `pathArray` values:\n   * * convert segments to absolute and/or relative values\n   * * select segments with shortest resulted string\n   * * round values to the specified `decimals` option value\n   *\n   * @public\n   */\n  optimize() {\n    const { segments } = this;\n    const round = this.round === \"off\" ? 2 : this.round;\n\n    this.segments = optimizePath(segments, round);\n    return this;\n  }\n\n  /**\n   * Transform path using values from an `Object` defined as `transformObject`.\n   *\n   * @see TransformObject for a quick refference\n   *\n   * @param source a `transformObject`as described above\n   * @public\n   */\n  transform(source?: Partial<TransformObject>) {\n    if (\n      !source ||\n      typeof source !== \"object\" ||\n      (typeof source === \"object\" &&\n        ![\"translate\", \"rotate\", \"skew\", \"scale\"].some((x) => x in source))\n    ) {\n      return this;\n    }\n\n    const {\n      segments,\n      origin: [cx, cy, cz],\n    } = this;\n    const transform = {} as TransformObjectValues;\n    for (const [k, v] of Object.entries(source) as TransformEntries) {\n      // istanbul ignore else @preserve\n      if (k === \"skew\" && Array.isArray(v)) {\n        transform[k] = v.map(Number) as PointTuple;\n      } else if (\n        (k === \"rotate\" || k === \"translate\" || k === \"origin\" ||\n          k === \"scale\") && Array.isArray(v)\n      ) {\n        transform[k] = v.map(Number) as [number, number, number];\n      } else if (k !== \"origin\" && typeof Number(v) === \"number\") {\n        transform[k] = Number(v);\n      }\n    }\n\n    // if origin is not specified\n    // it's important that we have one\n    const { origin } = transform;\n\n    if (Array.isArray(origin) && origin.length >= 2) {\n      const [originX, originY, originZ] = origin.map(Number);\n      transform.origin = [\n        !Number.isNaN(originX) ? originX : cx,\n        !Number.isNaN(originY) ? originY : cy,\n        originZ || cz,\n      ];\n    } else {\n      transform.origin = [cx, cy, cz];\n    }\n\n    this.segments = transformPath(segments, transform);\n    return this;\n  }\n\n  /**\n   * Rotate path 180deg vertically\n   *\n   * @public\n   */\n  flipX() {\n    const { cx, cy } = this.bbox;\n    this.transform({ rotate: [0, 180, 0], origin: [cx, cy, 0] });\n    return this;\n  }\n\n  /**\n   * Rotate path 180deg horizontally\n   *\n   * @public\n   */\n  flipY() {\n    const { cx, cy } = this.bbox;\n    this.transform({ rotate: [180, 0, 0], origin: [cx, cy, 0] });\n    return this;\n  }\n\n  /**\n   * Export the current path to be used\n   * for the `d` (description) attribute.\n   *\n   * @public\n   * @return the path string\n   */\n  toString() {\n    return pathToString(this.segments, this.round);\n  }\n\n  /**\n   * Remove the instance.\n   *\n   * @public\n   * @return void\n   */\n  dispose() {\n    Object.keys(this).forEach((key) => delete this[key as keyof typeof this]);\n  }\n}\n\nexport default SVGPathCommander;\n"],"names":["Z","z","s","e","p","$","E","P","y","g","n","i","r","a","m","h","c","u","f","w","o","d","b","X","O","x","Y","F","T","k","I","v","R","D","N","defaultOptions","paramsCount","finalizeSegment","path","pathCommand","relativeCommand","data","error","scanFlag","index","pathValue","code","isDigit","invalidPathValue","scanParam","max","start","zeroFirst","hasCeiling","hasDecimal","hasDot","ch","isSpace","skipSpaces","isPathCommand","isDigitStart","isArcCommand","isMoveCommand","scanSegment","segments","cmdCode","reqParams","paramCounts","lastSegment","_a","PathParser","pathString","parsePathString","pathInput","absolutizeSegment","segment","lastX","lastY","absCommand","absValues","seglen","j","iterate","iterator","pathLen","isRelative","mx","my","segLen","iteratorResult","pathToAbsolute","relativizeSegment","relCommand","relValues","pathToRelative","rotateVector","rad","sin","cos","arcToCubic","X1","Y1","RX","RY","angle","LAF","SF","X2","Y2","recursive","x1","y1","rx","ry","x2","y2","d120","res","xy","f1","f2","cx","cy","rx2","ry2","df","f2old","x2old","y2old","c1","s1","c2","s2","t","hx","hy","m1","m2","m3","m4","newres","ii","quadToCubic","qx","qy","r13","r23","midPoint","ax","ay","bx","by","lineToCubic","segmentToCubic","params","values","px1","py1","px","py","normalizeSegment","px2","py2","nqx","nqy","paramsParser","pathToCurve","seg","normalSegment","result","roundTo","round","pow","pathToString","roundOption","valLen","distanceSquareRoot","getLineLength","getPointAtLineLength","distance","point","length","getLineBBox","min","arcLength","theta","halfTheta","sinHalfTheta","cosHalfTheta","term1","term2","arcPoint","alpha","cosA","sinA","angleBetween","v0","v1","v0x","v0y","v1x","v1y","getArcProps","abs","sqrt","PI","xRotRad","dx","dy","transformedPoint","radiiCheck","cSquareNumerator","cSquareRootDenom","cRadicand","cCoef","transformedCenter","center","startVector","startAngle","endVector","sweepAngle","endAngle","getArcLength","getPointAtArcLength","ellipseComponentX","ellipseComponentY","getArcBBox","deltaAngle","tan","atan2","tangent","angle1","angle2","angle3","angle4","xMin","xMax","yMin","yMax","angleAfterStart","pP2","angleBeforeEnd","pP3","pxy","Tvalues","Cvalues","deriveBezier","points","dpoints","list","computeBezier","order","mt","mt2","t2","calculateBezier","derivativeFn","l","bezierLength","len","sum","getBezierLength","curve","idx","step","CBEZIER_MINMAX_EPSILON","minmaxQ","cp","v2","minmaxC","cp1","cp2","K","S","L","Q","getPointAtCubicSegmentLength","c1x","c1y","c2x","c2y","t1","getCubicLength","getPointAtCubicLength","distanceIsNumber","currentLength","getCubicBBox","cxMinMax","cyMinMax","getPointAtQuadSegmentLength","getQuadLength","getPointAtQuadLength","getQuadBBox","polygonArea","polygon","area","polygonLength","DISTANCE_EPSILON","normalizePath","_","getPointAtLength","isM","POINT","totalLength","getTotalLength","paramX1","paramY1","paramX2","paramY2","paramQX","paramQY","absoluteSegment","cp1x","cp1y","getPropertiesAtLength","pathArray","pathTemp","pathLength","lengthAtSegment","getPropertiesAtPoint","normalPath","distanceTo","precision","scan","closest","scanDistance","bestLength","bestDistance","scanLength","before","after","beforeLength","afterLength","beforeDistance","afterDistance","getClosestPoint","getCubicSegArea","getPathArea","getDrawDirection","getPathBBox","minX","minY","maxX","maxY","width","height","getSegmentAtLength","getSegmentOfPoint","isPathArray","lk","isAbsoluteArray","isNormalizedArray","pc","isCurveArray","isPointInStroke","isRelativeArray","isValidPath","shapeParams","isElement","node","getLinePath","attr","getPolyPath","getCirclePath","getEllipsePath","getRectanglePath","shapeToPathArray","element","supportedShapes","targetIsElement","tagName","type","shapeAttrs","config","shapeToPath","replace","ownerDocument","doc","description","name","value","getSVGMatrix","transform","matrix","CSSMatrix","origin","originX","originY","translate","rotate","skew","scale","shortenSegment","prevCommand","defaultRound","normalValues","nx","ny","nx1","ny1","roundSegment","optimizePath","optimParams","allPathCommands","normalizedSegment","shortSegment","absSegment","absString","relativeSegment","relSegment","relString","translatePoint","cssm","projection2d","point2D","originZ","relativePositionX","relativePositionY","relativePositionZ","reverseCurve","rotatedCurve","curveOnly","reversePath","absolutePath","normalizedPath","pLen","isClosed","reversedPath","prevSeg","nextSeg","nextCommand","roundPath","splitCubic","pts","ratio","p0","p1","p2","p3","p4","p5","p6","p7","p8","p9","splitPath","composite","pi","transformPath","lx","ly","jj","transformProps","matrixInstance","isLongArc","tempSegment","SVGPathCommander","instanceOptions","undefPath","originOption","onlySubpath","split","subPath","absoluteMultiPath","source","cz","key","__publicField","arcTools","distanceEpsilon","pathParser"],"mappings":"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","x_google_ignoreList":[0]}