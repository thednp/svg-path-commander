{"version":3,"sources":["../../src/util.ts","../../src/math/arcTools.ts","../../src/math/lineTools.ts","../../src/math/midPoint.ts","../../src/math/distanceSquareRoot.ts","../../src/math/bezier.ts","../../src/math/cubicTools.ts","../../src/math/quadTools.ts","../../src/math/polygonTools.ts","../../src/parser/paramsCount.ts","../../src/parser/finalizeSegment.ts","../../src/parser/error.ts","../../src/parser/scanFlag.ts","../../src/parser/isDigit.ts","../../src/parser/invalidPathValue.ts","../../src/parser/scanParam.ts","../../src/parser/isSpace.ts","../../src/parser/skipSpaces.ts","../../src/parser/isPathCommand.ts","../../src/parser/isDigitStart.ts","../../src/parser/isArcCommand.ts","../../src/parser/isMoveCommand.ts","../../src/parser/scanSegment.ts","../../src/parser/pathParser.ts","../../src/parser/parsePathString.ts","../../src/process/absolutizeSegment.ts","../../src/process/iterate.ts","../../src/convert/pathToAbsolute.ts","../../src/process/relativizeSegment.ts","../../src/convert/pathToRelative.ts","../../src/math/rotateVector.ts","../../src/process/arcToCubic.ts","../../src/process/quadToCubic.ts","../../src/process/lineToCubic.ts","../../src/process/segmentToCubic.ts","../../src/process/normalizeSegment.ts","../../src/parser/paramsParser.ts","../../src/convert/pathToCurve.ts","../../src/options/options.ts","../../src/math/roundTo.ts","../../src/convert/pathToString.ts","../../src/util/distanceEpsilon.ts","../../src/process/normalizePath.ts","../../src/util/getPointAtLength.ts","../../src/util/getTotalLength.ts","../../src/util/getPropertiesAtLength.ts","../../src/util/getPropertiesAtPoint.ts","../../src/util/getClosestPoint.ts","../../src/util/getPathArea.ts","../../src/util/getDrawDirection.ts","../../src/util/getPathBBox.ts","../../src/util/getSegmentAtLength.ts","../../src/util/getSegmentOfPoint.ts","../../src/util/isPathArray.ts","../../src/util/isAbsoluteArray.ts","../../src/util/isNormalizedArray.ts","../../src/util/isCurveArray.ts","../../src/util/isPointInStroke.ts","../../src/util/isRelativeArray.ts","../../src/util/isValidPath.ts","../../src/util/shapeParams.ts","../../src/util/isElement.ts","../../src/util/shapeToPathArray.ts","../../src/util/shapeToPath.ts","../../src/process/getSVGMatrix.ts","../../src/process/shortenSegment.ts","../../src/process/roundSegment.ts","../../src/process/optimizePath.ts","../../src/process/projection2d.ts","../../src/process/reverseCurve.ts","../../src/process/reversePath.ts","../../src/process/roundPath.ts","../../src/process/splitCubic.ts","../../src/process/splitPath.ts","../../src/process/transformPath.ts"],"names":["arcTools_exports","__export","angleBetween","arcLength","arcPoint","getArcBBox","getArcLength","getArcProps","getPointAtArcLength","lineTools_exports","getLineBBox","getLineLength","getPointAtLineLength","midPoint","a","b","t","ax","ay","bx","by","midPoint_default","distanceSquareRoot","distanceSquareRoot_default","x1","y1","x2","y2","distance","point","length","x","y","min","max","rx","ry","theta","halfTheta","sinHalfTheta","cosHalfTheta","term1","term2","cx","cy","alpha","sin","cos","cosA","sinA","v0","v1","v0x","v0y","v1x","v1y","p","n","RX","RY","angle","LAF","SF","abs","sqrt","PI","xRotRad","dx","dy","transformedPoint","radiiCheck","cSquareNumerator","cSquareRootDenom","cRadicand","cCoef","transformedCenter","center","startVector","startAngle","endVector","sweepAngle","endAngle","ellipseComponentX","ellipseComponentY","deltaAngle","tan","atan2","tangent","angle1","angle2","angle3","angle4","xArray","yArray","xMin","xMax","yMin","yMax","angleAfterStart","pP2","angleBeforeEnd","pP3","p1","p2","p4","p3","bezier_exports","CBEZIER_MINMAX_EPSILON","Cvalues","Tvalues","bezierLength","calculateBezier","computeBezier","deriveBezier","getBezierLength","minmaxC","minmaxQ","points","dpoints","d","c","list","j","order","mt","mt2","t2","derivativeFn","l","len","sum","i","curve","idx","step","cp","v2","E","cp1","cp2","K","T","S","L","R","Q","cubicTools_exports","getCubicBBox","getCubicLength","getPointAtCubicLength","getPointAtCubicSegmentLength","c1x","c1y","c2x","c2y","t1","distanceIsNumber","currentLength","cxMinMax","cyMinMax","quadTools_exports","getPointAtQuadLength","getPointAtQuadSegmentLength","getQuadBBox","getQuadLength","polygonTools_exports","polygonArea","polygonLength","polygon","area","paramsCount","paramsCount_default","finalizeSegment","path","pathCommand","relativeCommand","data","finalizeSegment_default","error","error_default","scanFlag","index","pathValue","code","scanFlag_default","isDigit","isDigit_default","invalidPathValue","invalidPathValue_default","scanParam","start","zeroFirst","hasCeiling","hasDecimal","hasDot","ch","scanParam_default","isSpace","isSpace_default","skipSpaces","skipSpaces_default","isPathCommand","isPathCommand_default","isDigitStart","isDigitStart_default","isArcCommand","isArcCommand_default","isMoveCommand","isMoveCommand_default","scanSegment","segments","cmdCode","reqParams","lastSegment","scanSegment_default","PathParser","pathString","parsePathString","pathInput","parsePathString_default","absolutizeSegment","segment","lastX","lastY","absCommand","isAbsolute","absValues","seglen","absolutizeSegment_default","iterate","iterator","pathLen","isRelative","mx","my","segLen","iteratorResult","iterate_default","pathToAbsolute","pathToAbsolute_default","relativizeSegment","relCommand","relValues","relativizeSegment_default","pathToRelative","pathToRelative_default","rotateVector","rad","X","Y","rotateVector_default","arcToCubic","X1","Y1","X2","Y2","recursive","d120","res","xy","f1","f2","h","rx2","ry2","k","df","f2old","x2old","y2old","c1","s1","c2","s2","hx","hy","m1","m2","m3","m4","newres","ii","arcToCubic_default","quadToCubic","qx","qy","r13","r23","quadToCubic_default","lineToCubic","lineToCubic_default","segmentToCubic","params","values","px1","py1","px","py","segmentToCubic_default","normalizeSegment","px2","py2","nqx","nqy","normalizeSegment_default","paramsParser","paramsParser_default","pathToCurve","seg","normalSegment","result","pathToCurve_default","defaultOptions","options_default","roundTo","round","pow","roundTo_default","pathToString","roundOption","valLen","pathToString_default","distanceEpsilon_default","normalizePath","_","normalizePath_default","getPointAtLength","isM","POINT","totalLength","getPointAtLength_default","getTotalLength","paramX1","paramY1","paramX2","paramY2","paramQX","paramQY","absoluteSegment","cp1x","cp1y","getTotalLength_default","getPropertiesAtLength","pathArray","pathTemp","pathLength","lengthAtSegment","getPropertiesAtLength_default","getPropertiesAtPoint","normalPath","distanceTo","precision","scan","closest","scanDistance","bestLength","bestDistance","scanLength","before","after","beforeLength","afterLength","beforeDistance","afterDistance","getPropertiesAtPoint_default","getClosestPoint","getClosestPoint_default","getCubicSegArea","getPathArea","getPathArea_default","getDrawDirection","getDrawDirection_default","getPathBBox","minX","minY","maxX","maxY","width","height","getPathBBox_default","getSegmentAtLength","getSegmentAtLength_default","getSegmentOfPoint","getSegmentOfPoint_default","isPathArray","lk","isPathArray_default","isAbsoluteArray","isAbsoluteArray_default","isNormalizedArray","pc","isNormalizedArray_default","isCurveArray","isCurveArray_default","isPointInStroke","isPointInStroke_default","isRelativeArray","isRelativeArray_default","isValidPath","isValidPath_default","shapeParams","shapeParams_default","isElement","node","isElement_default","getLinePath","attr","getPolyPath","getCirclePath","r","getEllipsePath","getRectanglePath","w","shapeToPathArray","element","supportedShapes","targetIsElement","tagName","s","type","shapeAttrs","config","shapeToPathArray_default","shapeToPath","replace","ownerDocument","doc","description","name","value","m","shapeToPath_default","getSVGMatrix","transform","matrix","CSSMatrix","origin","originX","originY","translate","rotate","skew","scale","getSVGMatrix_default","shortenSegment","prevCommand","defaultRound","normalValues","nx","ny","nx1","ny1","shortenSegment_default","roundSegment","roundSegment_default","optimizePath","optimParams","allPathCommands","normalizedSegment","shortSegment","absSegment","absString","relativeSegment","relSegment","relString","optimizePath_default","translatePoint","cssm","v","projection2d","point2D","originZ","z","relativePositionX","relativePositionY","relativePositionZ","projection2d_default","reverseCurve","rotatedCurve","curveOnly","reverseCurve_default","reversePath","absolutePath","normalizedPath","pLen","isClosed","reversedPath","prevSeg","nextSeg","nextCommand","reversePath_default","roundPath","roundPath_default","splitCubic","pts","ratio","p0","p5","p6","p7","p8","p9","splitCubic_default","splitPath","composite","pi","splitPath_default","transformPath","lx","ly","jj","transformProps","matrixInstance","isLongArc","tempSegment","transformPath_default"],"mappings":"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","file":"util.cjs","sourcesContent":["export { default as CSSMatrix } from \"@thednp/dommatrix\";\n// export type { PathArray, PointTuple, TransformObjectValues } from \"./types\";\n// export type { Options, TransformEntries, TransformObject } from \"./interface\";\n// export * from \"./types\";\n// export * from \"./interface\";\n\nimport * as arcTools from \"./math/arcTools\";\nimport * as bezierTools from \"./math/bezier\";\nimport * as cubicTools from \"./math/cubicTools\";\nimport * as lineTools from \"./math/lineTools\";\nimport * as quadTools from \"./math/quadTools\";\nimport * as polygonTools from \"./math/polygonTools\";\nexport {\n  arcTools,\n  bezierTools,\n  cubicTools,\n  lineTools,\n  polygonTools,\n  quadTools,\n};\n\n// export * from \"./math/arcTools\";\n// export * from \"./math/bezier\";\n// export * from \"./math/cubicTools\";\n// export * from \"./math/lineTools\";\n// export * from \"./math/quadTools\";\n// export * from \"./math/polygonTools\";\n\nexport { default as pathToAbsolute } from \"./convert/pathToAbsolute\";\nexport { default as pathToRelative } from \"./convert/pathToRelative\";\nexport { default as pathToCurve } from \"./convert/pathToCurve\";\nexport { default as pathToString } from \"./convert/pathToString\";\n\nexport { default as distanceSquareRoot } from \"./math/distanceSquareRoot\";\nexport { default as midPoint } from \"./math/midPoint\";\nexport { default as rotateVector } from \"./math/rotateVector\";\nexport { default as roundTo } from \"./math/roundTo\";\n\nexport { default as parsePathString } from \"./parser/parsePathString\";\nexport { default as finalizeSegment } from \"./parser/finalizeSegment\";\nexport { default as invalidPathValue } from \"./parser/invalidPathValue\";\nexport { default as isArcCommand } from \"./parser/isArcCommand\";\nexport { default as isDigit } from \"./parser/isDigit\";\nexport { default as isDigitStart } from \"./parser/isDigitStart\";\nexport { default as isMoveCommand } from \"./parser/isMoveCommand\";\nexport { default as isPathCommand } from \"./parser/isPathCommand\";\nexport { default as isSpace } from \"./parser/isSpace\";\nexport { default as paramsCount } from \"./parser/paramsCount\";\nexport { default as paramsParser } from \"./parser/paramsParser\";\nexport { default as pathParser } from \"./parser/pathParser\";\nexport { default as scanFlag } from \"./parser/scanFlag\";\nexport { default as scanParam } from \"./parser/scanParam\";\nexport { default as scanSegment } from \"./parser/scanSegment\";\nexport { default as skipSpaces } from \"./parser/skipSpaces\";\n\nexport { default as distanceEpsilon } from \"./util/distanceEpsilon\";\nexport { default as getClosestPoint } from \"./util/getClosestPoint\";\nexport { default as getDrawDirection } from \"./util/getDrawDirection\";\nexport { default as getPathArea } from \"./util/getPathArea\";\nexport { default as getPathBBox } from \"./util/getPathBBox\";\nexport { default as getPointAtLength } from \"./util/getPointAtLength\";\nexport { default as getPropertiesAtLength } from \"./util/getPropertiesAtLength\";\nexport { default as getPropertiesAtPoint } from \"./util/getPropertiesAtPoint\";\nexport { default as getSegmentAtLength } from \"./util/getSegmentAtLength\";\nexport { default as getSegmentOfPoint } from \"./util/getSegmentOfPoint\";\nexport { default as getTotalLength } from \"./util/getTotalLength\";\n\nexport { default as isAbsoluteArray } from \"./util/isAbsoluteArray\";\nexport { default as isCurveArray } from \"./util/isCurveArray\";\nexport { default as isNormalizedArray } from \"./util/isNormalizedArray\";\nexport { default as isPathArray } from \"./util/isPathArray\";\nexport { default as isPointInStroke } from \"./util/isPointInStroke\";\nexport { default as isRelativeArray } from \"./util/isRelativeArray\";\nexport { default as isValidPath } from \"./util/isValidPath\";\nexport { default as shapeParams } from \"./util/shapeParams\";\nexport { default as shapeToPath } from \"./util/shapeToPath\";\nexport { default as shapeToPathArray } from \"./util/shapeToPathArray\";\n\nexport { default as absolutizeSegment } from \"./process/absolutizeSegment\";\nexport { default as arcToCubic } from \"./process/arcToCubic\";\nexport { default as getSVGMatrix } from \"./process/getSVGMatrix\";\nexport { default as iterate } from \"./process/iterate\";\nexport { default as lineToCubic } from \"./process/lineToCubic\";\nexport { default as normalizePath } from \"./process/normalizePath\";\nexport { default as normalizeSegment } from \"./process/normalizeSegment\";\nexport { default as optimizePath } from \"./process/optimizePath\";\nexport { default as projection2d } from \"./process/projection2d\";\nexport { default as quadToCubic } from \"./process/quadToCubic\";\nexport { default as relativizeSegment } from \"./process/relativizeSegment\";\nexport { default as reverseCurve } from \"./process/reverseCurve\";\nexport { default as reversePath } from \"./process/reversePath\";\nexport { default as roundPath } from \"./process/roundPath\";\nexport { default as roundSegment } from \"./process/roundSegment\";\nexport { default as segmentToCubic } from \"./process/segmentToCubic\";\nexport { default as shortenSegment } from \"./process/shortenSegment\";\nexport { default as splitCubic } from \"./process/splitCubic\";\nexport { default as splitPath } from \"./process/splitPath\";\nexport { default as transformPath } from \"./process/transformPath\";\n","import { getPointAtLineLength } from \"./lineTools\";\nimport type { Point, PointTuple } from \"../types\";\n\n/**\n * Returns the Arc segment length.\n * @param rx radius along X axis\n * @param ry radius along Y axis\n * @param theta the angle in radians\n * @returns the arc length\n */\nconst arcLength = (rx: number, ry: number, theta: number) => {\n  const halfTheta = theta / 2;\n  const sinHalfTheta = Math.sin(halfTheta);\n  const cosHalfTheta = Math.cos(halfTheta);\n  const term1 = rx ** 2 * sinHalfTheta ** 2;\n  const term2 = ry ** 2 * cosHalfTheta ** 2;\n  const length = Math.sqrt(term1 + term2) * theta;\n  return Math.abs(length);\n};\n\n/**\n * Find point on ellipse at given angle around ellipse (theta);\n * @param cx the center X\n * @param cy the center Y\n * @param rx the radius X\n * @param ry the radius Y\n * @param alpha the arc rotation angle in radians\n * @param theta the arc sweep angle in radians\n * @returns a point around ellipse at given angle\n */\nconst arcPoint = (\n  cx: number,\n  cy: number,\n  rx: number,\n  ry: number,\n  alpha: number,\n  theta: number,\n) => {\n  const { sin, cos } = Math;\n  // theta is angle in radians around arc\n  // alpha is angle of rotation of ellipse in radians\n  const cosA = cos(alpha);\n  const sinA = sin(alpha);\n  const x = rx * cos(theta);\n  const y = ry * sin(theta);\n\n  return [cx + cosA * x - sinA * y, cy + sinA * x + cosA * y] as PointTuple;\n};\n\n/**\n * Returns the angle between two points.\n * @param v0 starting point\n * @param v1 ending point\n * @returns the angle in radian\n */\nconst angleBetween = (v0: Point, v1: Point) => {\n  const { x: v0x, y: v0y } = v0;\n  const { x: v1x, y: v1y } = v1;\n  const p = v0x * v1x + v0y * v1y;\n  const n = Math.sqrt((v0x ** 2 + v0y ** 2) * (v1x ** 2 + v1y ** 2));\n  const sign = v0x * v1y - v0y * v1x < 0 ? -1 : 1;\n  return sign * Math.acos(p / n);\n};\n\n/**\n * Returns the following properties for an Arc segment: center, start angle,\n * end angle, and radiuses on X and Y axis.\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param RX the radius on X axis\n * @param RY the radius on Y axis\n * @param angle the ellipse rotation in degrees\n * @param LAF the large arc flag\n * @param SF the sweep flag\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @returns properties specific to Arc segments\n */\nconst getArcProps = (\n  x1: number,\n  y1: number,\n  RX: number,\n  RY: number,\n  angle: number,\n  LAF: number,\n  SF: number,\n  x: number,\n  y: number,\n) => {\n  const { abs, sin, cos, sqrt, PI } = Math;\n  let rx = abs(RX);\n  let ry = abs(RY);\n  const xRot = ((angle % 360) + 360) % 360;\n  const xRotRad = xRot * (PI / 180);\n\n  // istanbul ignore next @preserve\n  if (x1 === x && y1 === y) {\n    return {\n      rx,\n      ry,\n      startAngle: 0,\n      endAngle: 0,\n      center: { x, y },\n    };\n  }\n\n  if (rx === 0 || ry === 0) {\n    return {\n      rx,\n      ry,\n      startAngle: 0,\n      endAngle: 0,\n      center: { x: (x + x1) / 2, y: (y + y1) / 2 },\n    };\n  }\n\n  const dx = (x1 - x) / 2;\n  const dy = (y1 - y) / 2;\n\n  const transformedPoint = {\n    x: cos(xRotRad) * dx + sin(xRotRad) * dy,\n    y: -sin(xRotRad) * dx + cos(xRotRad) * dy,\n  };\n\n  const radiiCheck = transformedPoint.x ** 2 / rx ** 2 +\n    transformedPoint.y ** 2 / ry ** 2;\n\n  if (radiiCheck > 1) {\n    rx *= sqrt(radiiCheck);\n    ry *= sqrt(radiiCheck);\n  }\n\n  const cSquareNumerator = rx ** 2 * ry ** 2 -\n    rx ** 2 * transformedPoint.y ** 2 - ry ** 2 * transformedPoint.x ** 2;\n  const cSquareRootDenom = rx ** 2 * transformedPoint.y ** 2 +\n    ry ** 2 * transformedPoint.x ** 2;\n\n  let cRadicand = cSquareNumerator / cSquareRootDenom;\n  /* istanbul ignore next @preserve */\n  cRadicand = cRadicand < 0 ? 0 : cRadicand;\n  const cCoef = (LAF !== SF ? 1 : -1) * sqrt(cRadicand);\n  const transformedCenter = {\n    x: cCoef * ((rx * transformedPoint.y) / ry),\n    y: cCoef * (-(ry * transformedPoint.x) / rx),\n  };\n\n  const center = {\n    x: cos(xRotRad) * transformedCenter.x - sin(xRotRad) * transformedCenter.y +\n      (x1 + x) / 2,\n    y: sin(xRotRad) * transformedCenter.x + cos(xRotRad) * transformedCenter.y +\n      (y1 + y) / 2,\n  };\n\n  const startVector = {\n    x: (transformedPoint.x - transformedCenter.x) / rx,\n    y: (transformedPoint.y - transformedCenter.y) / ry,\n  };\n\n  const startAngle = angleBetween({ x: 1, y: 0 }, startVector);\n\n  const endVector = {\n    x: (-transformedPoint.x - transformedCenter.x) / rx,\n    y: (-transformedPoint.y - transformedCenter.y) / ry,\n  };\n\n  let sweepAngle = angleBetween(startVector, endVector);\n  if (!SF && sweepAngle > 0) {\n    sweepAngle -= 2 * PI;\n  } else if (SF && sweepAngle < 0) {\n    sweepAngle += 2 * PI;\n  }\n  sweepAngle %= 2 * PI;\n\n  const endAngle = startAngle + sweepAngle;\n\n  // point.ellipticalArcStartAngle = startAngle;\n  // point.ellipticalArcEndAngle = startAngle + sweepAngle;\n  // point.ellipticalArcAngle = alpha;\n\n  // point.ellipticalArcCenter = center;\n  // point.resultantRx = rx;\n  // point.resultantRy = ry;\n\n  return {\n    center,\n    startAngle,\n    endAngle,\n    rx,\n    ry,\n  };\n};\n\n/**\n * Returns the length of an Arc segment.\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param c1x the first control point X\n * @param c1y the first control point Y\n * @param c2x the second control point X\n * @param c2y the second control point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @returns the length of the Arc segment\n */\nconst getArcLength = (\n  x1: number,\n  y1: number,\n  RX: number,\n  RY: number,\n  angle: number,\n  LAF: number,\n  SF: number,\n  x: number,\n  y: number,\n) => {\n  const { rx, ry, startAngle, endAngle } = getArcProps(\n    x1,\n    y1,\n    RX,\n    RY,\n    angle,\n    LAF,\n    SF,\n    x,\n    y,\n  );\n  return arcLength(rx, ry, endAngle - startAngle);\n};\n\n/**\n * Returns a point along an Arc segment at a given distance.\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param RX the radius on X axis\n * @param RY the radius on Y axis\n * @param angle the ellipse rotation in degrees\n * @param LAF the large arc flag\n * @param SF the sweep flag\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @param distance a [0-1] ratio\n * @returns a point along the Arc segment\n */\nconst getPointAtArcLength = (\n  x1: number,\n  y1: number,\n  RX: number,\n  RY: number,\n  angle: number,\n  LAF: number,\n  SF: number,\n  x: number,\n  y: number,\n  distance?: number,\n) => {\n  let point = { x: x1, y: y1 };\n  const { center, rx, ry, startAngle, endAngle } = getArcProps(\n    x1,\n    y1,\n    RX,\n    RY,\n    angle,\n    LAF,\n    SF,\n    x,\n    y,\n  );\n\n  /* istanbul ignore else @preserve */\n  if (typeof distance === \"number\") {\n    const length = arcLength(rx, ry, endAngle - startAngle);\n    if (distance <= 0) {\n      point = { x: x1, y: y1 };\n    } else if (distance >= length) {\n      point = { x, y };\n    } else {\n      /* istanbul ignore next @preserve */\n      if (x1 === x && y1 === y) {\n        return { x, y };\n      }\n      /* istanbul ignore next @preserve */\n      if (rx === 0 || ry === 0) {\n        return getPointAtLineLength(x1, y1, x, y, distance);\n      }\n      const { PI, cos, sin } = Math;\n      const sweepAngle = endAngle - startAngle;\n      const xRot = ((angle % 360) + 360) % 360;\n      const xRotRad = xRot * (PI / 180);\n      const alpha = startAngle + sweepAngle * (distance / length);\n      const ellipseComponentX = rx * cos(alpha);\n      const ellipseComponentY = ry * sin(alpha);\n\n      point = {\n        x: cos(xRotRad) * ellipseComponentX - sin(xRotRad) * ellipseComponentY +\n          center.x,\n        y: sin(xRotRad) * ellipseComponentX + cos(xRotRad) * ellipseComponentY +\n          center.y,\n      };\n    }\n  }\n\n  return point;\n};\n\n/**\n * Returns the extrema for an Arc segment in the following format:\n * [MIN_X, MIN_Y, MAX_X, MAX_Y]\n *\n * @see https://github.com/herrstrietzel/svg-pathdata-getbbox\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param RX the radius on X axis\n * @param RY the radius on Y axis\n * @param angle the ellipse rotation in degrees\n * @param LAF the large arc flag\n * @param SF the sweep flag\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @returns the extrema of the Arc segment\n */\nconst getArcBBox = (\n  x1: number,\n  y1: number,\n  RX: number,\n  RY: number,\n  angle: number,\n  LAF: number,\n  SF: number,\n  x: number,\n  y: number,\n) => {\n  const { center, rx, ry, startAngle, endAngle } = getArcProps(\n    x1,\n    y1,\n    RX,\n    RY,\n    angle,\n    LAF,\n    SF,\n    x,\n    y,\n  );\n  const deltaAngle = endAngle - startAngle;\n  const { min, max, tan, atan2, PI } = Math;\n\n  // circle/elipse center coordinates\n  const { x: cx, y: cy } = center;\n\n  // rotation to radians\n  const alpha = (angle * PI) / 180;\n  const tangent = tan(alpha);\n\n  /**\n   * find min/max from zeroes of directional derivative along x and y\n   * along x axis\n   */\n  const theta = atan2(-ry * tangent, rx);\n  const angle1 = theta;\n  const angle2 = theta + PI;\n  const angle3 = atan2(ry, rx * tangent);\n  const angle4 = angle3 + PI;\n  const xArray = [x];\n  const yArray = [y];\n\n  // inner bounding box\n  let xMin = min(x1, x);\n  let xMax = max(x1, x);\n  let yMin = min(y1, y);\n  let yMax = max(y1, y);\n\n  // on path point close after start\n  const angleAfterStart = endAngle - deltaAngle * 0.00001;\n  const pP2 = arcPoint(cx, cy, rx, ry, alpha, angleAfterStart);\n\n  // on path point close before end\n  const angleBeforeEnd = endAngle - deltaAngle * 0.99999;\n  const pP3 = arcPoint(cx, cy, rx, ry, alpha, angleBeforeEnd);\n\n  /**\n   * expected extremes\n   * if leaving inner bounding box\n   * (between segment start and end point)\n   * otherwise exclude elliptic extreme points\n   */\n\n  // right\n  if (pP2[0] > xMax || pP3[0] > xMax) {\n    // get point for this theta\n    const p1 = arcPoint(cx, cy, rx, ry, alpha, angle1);\n    xArray.push(p1[0]);\n    yArray.push(p1[1]);\n  }\n\n  // left\n  if (pP2[0] < xMin || pP3[0] < xMin) {\n    // get anti-symmetric point\n    const p2 = arcPoint(cx, cy, rx, ry, alpha, angle2);\n    xArray.push(p2[0]);\n    yArray.push(p2[1]);\n  }\n\n  // top\n  if (pP2[1] < yMin || pP3[1] < yMin) {\n    // get anti-symmetric point\n    const p4 = arcPoint(cx, cy, rx, ry, alpha, angle4);\n    xArray.push(p4[0]);\n    yArray.push(p4[1]);\n  }\n\n  // bottom\n  if (pP2[1] > yMax || pP3[1] > yMax) {\n    // get point for this theta\n    const p3 = arcPoint(cx, cy, rx, ry, alpha, angle3);\n    xArray.push(p3[0]);\n    yArray.push(p3[1]);\n  }\n\n  xMin = min.apply([], xArray);\n  yMin = min.apply([], yArray);\n  xMax = max.apply([], xArray);\n  yMax = max.apply([], yArray);\n\n  return [xMin, yMin, xMax, yMax] as [number, number, number, number];\n};\n\nexport {\n  angleBetween,\n  arcLength,\n  arcPoint,\n  getArcBBox,\n  getArcLength,\n  getArcProps,\n  getPointAtArcLength,\n};\n","import midPoint from \"./midPoint\";\nimport distanceSquareRoot from \"./distanceSquareRoot\";\n\n/**\n * Returns length for line segments (MoveTo, LineTo).\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @returns the line segment length\n */\nconst getLineLength = (x1: number, y1: number, x2: number, y2: number) => {\n  return distanceSquareRoot([x1, y1], [x2, y2]);\n};\n\n/**\n * Returns a point along the line segments (MoveTo, LineTo).\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @param distance the distance to point in [0-1] range\n * @returns the point at length\n */\nconst getPointAtLineLength = (\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  distance?: number,\n) => {\n  let point = { x: x1, y: y1 };\n\n  /* istanbul ignore else @preserve */\n  if (typeof distance === \"number\") {\n    const length = distanceSquareRoot([x1, y1], [x2, y2]);\n    if (distance <= 0) {\n      point = { x: x1, y: y1 };\n    } else if (distance >= length) {\n      point = { x: x2, y: y2 };\n    } else {\n      const [x, y] = midPoint([x1, y1], [x2, y2], distance / length);\n      point = { x, y };\n    }\n  }\n  return point;\n};\n\n/**\n * Returns bounding box for line segments (MoveTo, LineTo).\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @param distance the distance to point in [0-1] range\n * @returns the extrema for line segments\n */\nconst getLineBBox = (x1: number, y1: number, x2: number, y2: number) => {\n  const { min, max } = Math;\n\n  return [min(x1, x2), min(y1, y2), max(x1, x2), max(y1, y2)] as [\n    number,\n    number,\n    number,\n    number,\n  ];\n};\n\nexport { getLineBBox, getLineLength, getPointAtLineLength };\n","import { PointTuple } from \"../types\";\n\n/**\n * Returns the coordinates of a specified distance\n * ratio between two points.\n *\n * @param a the first point coordinates\n * @param b the second point coordinates\n * @param t the ratio\n * @returns the midpoint coordinates\n */\nconst midPoint = (a: PointTuple, b: PointTuple, t: number): PointTuple => {\n  const [ax, ay] = a;\n  const [bx, by] = b;\n  return [ax + (bx - ax) * t, ay + (by - ay) * t];\n};\n\nexport default midPoint;\n","import { type PointTuple } from \"../types\";\n\n/**\n * Returns the square root of the distance\n * between two given points.\n *\n * @param a the first point coordinates\n * @param b the second point coordinates\n * @returns the distance value\n */\nconst distanceSquareRoot = (a: PointTuple, b: PointTuple) => {\n  return Math.sqrt(\n    (a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1]),\n  );\n};\n\nexport default distanceSquareRoot;\n","import type {\n  CubicCoordinates,\n  CubicPoints,\n  DeriveCallback,\n  DerivedCubicPoints,\n  DerivedPoint,\n  DerivedQuadPoints,\n  PointTuple,\n  QuadCoordinates,\n  QuadPoints,\n} from \"../types\";\n\n/**\n * Tools from bezier.js by Mike 'Pomax' Kamermans\n * @see https://github.com/Pomax/bezierjs\n */\n\nconst Tvalues = [\n  -0.0640568928626056260850430826247450385909,\n  0.0640568928626056260850430826247450385909,\n  -0.1911188674736163091586398207570696318404,\n  0.1911188674736163091586398207570696318404,\n  -0.3150426796961633743867932913198102407864,\n  0.3150426796961633743867932913198102407864,\n  -0.4337935076260451384870842319133497124524,\n  0.4337935076260451384870842319133497124524,\n  -0.5454214713888395356583756172183723700107,\n  0.5454214713888395356583756172183723700107,\n  -0.6480936519369755692524957869107476266696,\n  0.6480936519369755692524957869107476266696,\n  -0.7401241915785543642438281030999784255232,\n  0.7401241915785543642438281030999784255232,\n  -0.8200019859739029219539498726697452080761,\n  0.8200019859739029219539498726697452080761,\n  -0.8864155270044010342131543419821967550873,\n  0.8864155270044010342131543419821967550873,\n  -0.9382745520027327585236490017087214496548,\n  0.9382745520027327585236490017087214496548,\n  -0.9747285559713094981983919930081690617411,\n  0.9747285559713094981983919930081690617411,\n  -0.9951872199970213601799974097007368118745,\n  0.9951872199970213601799974097007368118745,\n];\n\nconst Cvalues = [\n  0.1279381953467521569740561652246953718517,\n  0.1279381953467521569740561652246953718517,\n  0.1258374563468282961213753825111836887264,\n  0.1258374563468282961213753825111836887264,\n  0.121670472927803391204463153476262425607,\n  0.121670472927803391204463153476262425607,\n  0.1155056680537256013533444839067835598622,\n  0.1155056680537256013533444839067835598622,\n  0.1074442701159656347825773424466062227946,\n  0.1074442701159656347825773424466062227946,\n  0.0976186521041138882698806644642471544279,\n  0.0976186521041138882698806644642471544279,\n  0.086190161531953275917185202983742667185,\n  0.086190161531953275917185202983742667185,\n  0.0733464814110803057340336152531165181193,\n  0.0733464814110803057340336152531165181193,\n  0.0592985849154367807463677585001085845412,\n  0.0592985849154367807463677585001085845412,\n  0.0442774388174198061686027482113382288593,\n  0.0442774388174198061686027482113382288593,\n  0.0285313886289336631813078159518782864491,\n  0.0285313886289336631813078159518782864491,\n  0.0123412297999871995468056670700372915759,\n  0.0123412297999871995468056670700372915759,\n];\n\n/**\n * @param points\n * @returns\n */\nconst deriveBezier = (points: QuadPoints | CubicPoints) => {\n  const dpoints = [] as (DerivedCubicPoints | DerivedQuadPoints)[];\n  for (let p = points, d = p.length, c = d - 1; d > 1; d -= 1, c -= 1) {\n    const list = [] as unknown as DerivedCubicPoints | DerivedQuadPoints;\n    for (let j = 0; j < c; j += 1) {\n      list.push({\n        x: c * (p[j + 1].x - p[j].x),\n        y: c * (p[j + 1].y - p[j].y),\n        t: 0,\n      });\n    }\n    dpoints.push(list);\n    p = list;\n  }\n  return dpoints;\n};\n\n/**\n * @param points\n * @param t\n */\nconst computeBezier = (\n  points: DerivedQuadPoints | DerivedCubicPoints,\n  t: number,\n) => {\n  // shortcuts\n  /* istanbul ignore next @preserve */\n  if (t === 0) {\n    points[0].t = 0;\n    return points[0];\n  }\n\n  const order = points.length - 1;\n\n  /* istanbul ignore next @preserve */\n  if (t === 1) {\n    points[order].t = 1;\n    return points[order];\n  }\n\n  const mt = 1 - t;\n  let p = points as typeof points | [\n    DerivedPoint,\n    DerivedPoint,\n    DerivedPoint,\n    DerivedPoint,\n  ];\n\n  // constant?\n  /* istanbul ignore next @preserve */\n  if (order === 0) {\n    points[0].t = t;\n    return points[0];\n  }\n\n  // linear?\n  /* istanbul ignore else @preserve */\n  if (order === 1) {\n    return {\n      x: mt * p[0].x + t * p[1].x,\n      y: mt * p[0].y + t * p[1].y,\n      t,\n    };\n  }\n\n  // quadratic/cubic curve?\n  const mt2 = mt * mt;\n  const t2 = t * t;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  /* istanbul ignore else @preserve */\n  if (order === 2) {\n    p = [p[0], p[1], p[2], { x: 0, y: 0 } as DerivedPoint];\n    a = mt2;\n    b = mt * t * 2;\n    c = t2;\n  } else if (order === 3) {\n    a = mt2 * mt;\n    b = mt2 * t * 3;\n    c = mt * t2 * 3;\n    d = t * t2;\n  }\n  return {\n    x: a * p[0].x + b * p[1].x + c * p[2].x + d * p[3].x,\n    y: a * p[0].y + b * p[1].y + c * p[2].y + d * p[3].y,\n    t,\n  };\n};\n\nconst calculateBezier = (derivativeFn: DeriveCallback, t: number) => {\n  const d = derivativeFn(t);\n  const l = d.x * d.x + d.y * d.y;\n\n  return Math.sqrt(l);\n};\n\nconst bezierLength = (derivativeFn: DeriveCallback) => {\n  const z = 0.5;\n  const len = Tvalues.length;\n\n  let sum = 0;\n\n  for (let i = 0, t; i < len; i++) {\n    t = z * Tvalues[i] + z;\n    sum += Cvalues[i] * calculateBezier(derivativeFn, t);\n  }\n  return z * sum;\n};\n\n/**\n * Returns the length of CubicBezier / Quad segment.\n * @param curve cubic / quad bezier segment\n */\nconst getBezierLength = (curve: CubicCoordinates | QuadCoordinates) => {\n  const points = [] as unknown as CubicPoints | QuadPoints;\n  for (let idx = 0, len = curve.length, step = 2; idx < len; idx += step) {\n    points.push({\n      x: curve[idx],\n      y: curve[idx + 1],\n    });\n  }\n  const dpoints = deriveBezier(points);\n  return bezierLength((t: number) => {\n    return computeBezier(dpoints[0], t);\n  });\n};\n\n// Precision for consider cubic polynom as quadratic one\nconst CBEZIER_MINMAX_EPSILON = 0.00000001;\n\n/**\n * Returns the most extreme points in a Quad Bezier segment.\n * @param A an array which consist of X/Y values\n */\n// https://github.com/kpym/SVGPathy/blob/acd1a50c626b36d81969f6e98e8602e128ba4302/lib/box.js#L89\nconst minmaxQ = ([v1, cp, v2]: [number, number, number]) => {\n  const min = Math.min(v1, v2);\n  const max = Math.max(v1, v2);\n\n  /* istanbul ignore next @preserve */\n  if (cp >= v1 ? v2 >= cp : v2 <= cp) {\n    // if no extremum in ]0,1[\n    return [min, max] as PointTuple;\n  }\n\n  // check if the extremum E is min or max\n  const E = (v1 * v2 - cp * cp) / (v1 - 2 * cp + v2);\n  return (E < min ? [E, max] : [min, E]) as PointTuple;\n};\n\n/**\n * Returns the most extreme points in a Cubic Bezier segment.\n * @param A an array which consist of X/Y values\n * @see https://github.com/kpym/SVGPathy/blob/acd1a50c626b36d81969f6e98e8602e128ba4302/lib/box.js#L127\n */\nconst minmaxC = ([v1, cp1, cp2, v2]: [number, number, number, number]) => {\n  const K = v1 - 3 * cp1 + 3 * cp2 - v2;\n\n  // if the polynomial is (almost) quadratic and not cubic\n  /* istanbul ignore next @preserve */\n  if (Math.abs(K) < CBEZIER_MINMAX_EPSILON) {\n    if (v1 === v2 && v1 === cp1) {\n      // no curve, point targeting same location\n      return [v1, v2] as PointTuple;\n    }\n\n    return minmaxQ([v1, -0.5 * v1 + 1.5 * cp1, v1 - 3 * cp1 + 3 * cp2]);\n  }\n\n  // the reduced discriminant of the derivative\n  const T = -v1 * cp2 + v1 * v2 - cp1 * cp2 - cp1 * v2 + cp1 * cp1 + cp2 * cp2;\n\n  // if the polynomial is monotone in [0,1]\n  if (T <= 0) {\n    return [Math.min(v1, v2), Math.max(v1, v2)] as PointTuple;\n  }\n  const S = Math.sqrt(T);\n\n  // potential extrema\n  let min = Math.min(v1, v2);\n  let max = Math.max(v1, v2);\n\n  const L = v1 - 2 * cp1 + cp2;\n  // check local extrema\n  for (let R = (L + S) / K, i = 1; i <= 2; R = (L - S) / K, i++) {\n    // istanbul ignore next @preserve\n    if (R > 0 && R < 1) {\n      // if the extrema is for R in [0,1]\n      const Q = v1 * (1 - R) * (1 - R) * (1 - R) +\n        cp1 * 3 * (1 - R) * (1 - R) * R + cp2 * 3 * (1 - R) * R * R +\n        v2 * R * R * R;\n      if (Q < min) {\n        min = Q;\n      }\n      if (Q > max) {\n        max = Q;\n      }\n    }\n  }\n\n  return [min, max] as PointTuple;\n};\n\nexport {\n  bezierLength,\n  calculateBezier,\n  CBEZIER_MINMAX_EPSILON,\n  computeBezier,\n  Cvalues,\n  deriveBezier,\n  getBezierLength,\n  minmaxC,\n  minmaxQ,\n  Tvalues,\n};\n","import { getBezierLength, minmaxC } from \"./bezier\";\nimport { type CubicCoordinates } from \"../types\";\n\n/**\n * Returns a point at a given length of a CubicBezier segment.\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param c1x the first control point X\n * @param c1y the first control point Y\n * @param c2x the second control point X\n * @param c2y the second control point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @param t a [0-1] ratio\n * @returns the point at cubic-bezier segment length\n */\nconst getPointAtCubicSegmentLength = (\n  [x1, y1, c1x, c1y, c2x, c2y, x2, y2]: CubicCoordinates,\n  t: number,\n) => {\n  const t1 = 1 - t;\n  return {\n    x: t1 ** 3 * x1 + 3 * t1 ** 2 * t * c1x + 3 * t1 * t ** 2 * c2x +\n      t ** 3 * x2,\n    y: t1 ** 3 * y1 + 3 * t1 ** 2 * t * c1y + 3 * t1 * t ** 2 * c2y +\n      t ** 3 * y2,\n  };\n};\n\n/**\n * Returns the length of a CubicBezier segment.\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param c1x the first control point X\n * @param c1y the first control point Y\n * @param c2x the second control point X\n * @param c2y the second control point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @returns the CubicBezier segment length\n */\nconst getCubicLength = (\n  x1: number,\n  y1: number,\n  c1x: number,\n  c1y: number,\n  c2x: number,\n  c2y: number,\n  x2: number,\n  y2: number,\n) => {\n  return getBezierLength([x1, y1, c1x, c1y, c2x, c2y, x2, y2]);\n};\n\n/**\n * Returns the point along a CubicBezier segment at a given distance.\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param c1x the first control point X\n * @param c1y the first control point Y\n * @param c2x the second control point X\n * @param c2y the second control point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @param distance the distance to look at\n * @returns the point at CubicBezier length\n */\nconst getPointAtCubicLength = (\n  x1: number,\n  y1: number,\n  c1x: number,\n  c1y: number,\n  c2x: number,\n  c2y: number,\n  x2: number,\n  y2: number,\n  distance?: number,\n) => {\n  const distanceIsNumber = typeof distance === \"number\";\n  let point = { x: x1, y: y1 };\n  /* istanbul ignore else @preserve */\n  if (distanceIsNumber) {\n    const currentLength = getBezierLength([x1, y1, c1x, c1y, c2x, c2y, x2, y2]);\n    if (distance <= 0) {\n      // first point already defined\n    } else if (distance >= currentLength) {\n      point = { x: x2, y: y2 };\n    } else {\n      point = getPointAtCubicSegmentLength(\n        [x1, y1, c1x, c1y, c2x, c2y, x2, y2],\n        distance / currentLength,\n      );\n    }\n  }\n  return point;\n};\n\n/**\n * Returns the boundig box of a CubicBezier segment in the following format:\n * [MIN_X, MIN_Y, MAX_X, MAX_Y]\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param c1x the first control point X\n * @param c1y the first control point Y\n * @param c2x the second control point X\n * @param c2y the second control point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @returns the extrema of the CubicBezier segment\n */\nconst getCubicBBox = (\n  x1: number,\n  y1: number,\n  c1x: number,\n  c1y: number,\n  c2x: number,\n  c2y: number,\n  x2: number,\n  y2: number,\n) => {\n  const cxMinMax = minmaxC([x1, c1x, c2x, x2]);\n  const cyMinMax = minmaxC([y1, c1y, c2y, y2]);\n\n  return [cxMinMax[0], cyMinMax[0], cxMinMax[1], cyMinMax[1]] as [\n    number,\n    number,\n    number,\n    number,\n  ];\n};\n\nexport {\n  getCubicBBox,\n  getCubicLength,\n  getPointAtCubicLength,\n  getPointAtCubicSegmentLength,\n};\n","import { getBezierLength, minmaxQ } from \"./bezier\";\nimport { type QuadCoordinates } from \"../types\";\n\n/**\n * Returns the {x,y} coordinates of a point at a\n * given length of a quadratic-bezier segment.\n *\n * @see https://github.com/substack/point-at-length\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param cx the control point X\n * @param cy the control point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @param t a [0-1] ratio\n * @returns the requested {x,y} coordinates\n */\nconst getPointAtQuadSegmentLength = (\n  [x1, y1, cx, cy, x2, y2]: QuadCoordinates,\n  t: number,\n) => {\n  const t1 = 1 - t;\n  return {\n    x: t1 ** 2 * x1 + 2 * t1 * t * cx + t ** 2 * x2,\n    y: t1 ** 2 * y1 + 2 * t1 * t * cy + t ** 2 * y2,\n  };\n};\n\n/**\n * Returns the length of a QuadraticBezier segment.\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param cx the control point X\n * @param cy the control point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @returns the QuadraticBezier segment length\n */\nconst getQuadLength = (\n  x1: number,\n  y1: number,\n  cx: number,\n  cy: number,\n  x2: number,\n  y2: number,\n) => {\n  return getBezierLength([x1, y1, cx, cy, x2, y2]);\n};\n\n/**\n * Returns the point along a QuadraticBezier segment at a given distance.\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param cx the control point X\n * @param cy the control point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @param distance the distance to look at\n * @returns the point at QuadraticBezier length\n */\nconst getPointAtQuadLength = (\n  x1: number,\n  y1: number,\n  cx: number,\n  cy: number,\n  x2: number,\n  y2: number,\n  distance?: number,\n) => {\n  const distanceIsNumber = typeof distance === \"number\";\n  let point = { x: x1, y: y1 };\n\n  /* istanbul ignore else @preserve */\n  if (distanceIsNumber) {\n    const currentLength = getBezierLength([x1, y1, cx, cy, x2, y2]);\n    if (distance <= 0) {\n      // first point already defined\n    } else if (distance >= currentLength) {\n      point = { x: x2, y: y2 };\n    } else {\n      point = getPointAtQuadSegmentLength(\n        [x1, y1, cx, cy, x2, y2],\n        distance / currentLength,\n      );\n    }\n  }\n  return point;\n};\n\n/**\n * Returns the boundig box of a QuadraticBezier segment in the following format:\n * [MIN_X, MIN_Y, MAX_X, MAX_Y]\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param cx the control point X\n * @param cy the control point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @returns the extrema of the QuadraticBezier segment\n */\nconst getQuadBBox = (\n  x1: number,\n  y1: number,\n  cx: number,\n  cy: number,\n  x2: number,\n  y2: number,\n) => {\n  const cxMinMax = minmaxQ([x1, cx, x2]);\n  const cyMinMax = minmaxQ([y1, cy, y2]);\n  return [cxMinMax[0], cyMinMax[0], cxMinMax[1], cyMinMax[1]] as [\n    number,\n    number,\n    number,\n    number,\n  ];\n};\n\nexport {\n  getPointAtQuadLength,\n  getPointAtQuadSegmentLength,\n  getQuadBBox,\n  getQuadLength,\n};\n","import distanceSquareRoot from \"./distanceSquareRoot\";\nimport { type PointTuple } from \"../types\";\n\n/**\n * d3-polygon-area\n * https://github.com/d3/d3-polygon\n *\n * Returns the area of a polygon.\n *\n * @param polygon an array of coordinates\n * @returns the polygon area\n */\nconst polygonArea = (polygon: PointTuple[]) => {\n  const n = polygon.length;\n  let i = -1;\n  let a: PointTuple;\n  let b = polygon[n - 1];\n  let area = 0;\n\n  /* eslint-disable-next-line */\n  while (++i < n) {\n    a = b;\n    b = polygon[i];\n    area += a[1] * b[0] - a[0] * b[1];\n  }\n\n  return area / 2;\n};\n\n/**\n * d3-polygon-length\n * https://github.com/d3/d3-polygon\n *\n * Returns the perimeter of a polygon.\n *\n * @param polygon an array of coordinates\n * @returns the polygon length\n */\nconst polygonLength = (polygon: PointTuple[]) => {\n  return polygon.reduce((length, point, i) => {\n    if (i) {\n      return length + distanceSquareRoot(polygon[i - 1], point);\n    }\n    return 0;\n  }, 0);\n};\n\nexport { polygonArea, polygonLength };\n","/** Segment params length */\nconst paramsCount = {\n  a: 7,\n  c: 6,\n  h: 1,\n  l: 2,\n  m: 2,\n  r: 4,\n  q: 4,\n  s: 4,\n  t: 2,\n  v: 1,\n  z: 0,\n};\n\nexport default paramsCount;\n","import paramsCount from \"./paramsCount\";\nimport PathParser from \"./pathParser\";\nimport type { PathCommand, PathSegment, RelativeCommand } from \"../types\";\n\n/**\n * Breaks the parsing of a pathString once a segment is finalized.\n *\n * @param path the `PathParser` instance\n */\nconst finalizeSegment = (path: PathParser) => {\n  let pathCommand = path.pathValue[path.segmentStart] as PathCommand;\n  let relativeCommand = pathCommand.toLowerCase() as RelativeCommand;\n  const { data } = path;\n\n  while (data.length >= paramsCount[relativeCommand]) {\n    // overloaded `moveTo`\n    // https://github.com/rveciana/svg-path-properties/blob/master/src/parse.ts\n    if (relativeCommand === \"m\" && data.length > 2) {\n      path.segments.push(\n        [pathCommand as PathCommand | number].concat(\n          data.splice(0, 2) as number[],\n        ) as PathSegment,\n      );\n      relativeCommand = \"l\";\n      pathCommand = pathCommand === \"m\" ? \"l\" : \"L\";\n    } else {\n      path.segments.push(\n        [pathCommand as PathCommand | number].concat(\n          data.splice(0, paramsCount[relativeCommand]) as number[],\n        ) as PathSegment,\n      );\n    }\n\n    if (!paramsCount[relativeCommand]) {\n      break;\n    }\n  }\n};\nexport default finalizeSegment;\n","const error = \"SVGPathCommander Error\";\nexport default error;\n","import error from \"./error\";\nimport type PathParser from \"./pathParser\";\n\n/**\n * Validates an A (arc-to) specific path command value.\n * Usually a `large-arc-flag` or `sweep-flag`.\n *\n * @param path the `PathParser` instance\n */\nconst scanFlag = (path: PathParser) => {\n  const { index, pathValue } = path;\n  const code = pathValue.charCodeAt(index);\n\n  if (code === 0x30 /* 0 */) {\n    path.param = 0;\n    path.index += 1;\n    return;\n  }\n\n  if (code === 0x31 /* 1 */) {\n    path.param = 1;\n    path.index += 1;\n    return;\n  }\n\n  path.err = `${error}: invalid Arc flag \"${\n    pathValue[index]\n  }\", expecting 0 or 1 at index ${index}`;\n};\n\nexport default scanFlag;\n","import { DigitNumber } from \"../types\";\n\n/**\n * Checks if a character is a digit.\n *\n * @param code the character to check\n * @returns check result\n */\nconst isDigit = (code: number): code is DigitNumber => {\n  return code >= 48 && code <= 57; // 0..9\n};\nexport default isDigit;\n","const invalidPathValue = \"Invalid path value\";\nexport default invalidPathValue;\n","import isDigit from \"./isDigit\";\nimport invalidPathValue from \"./invalidPathValue\";\nimport error from \"./error\";\nimport type PathParser from \"./pathParser\";\n\n/**\n * Validates every character of the path string,\n * every path command, negative numbers or floating point numbers.\n *\n * @param path the `PathParser` instance\n */\nconst scanParam = (path: PathParser) => {\n  const { max, pathValue, index: start } = path;\n  let index = start;\n  let zeroFirst = false;\n  let hasCeiling = false;\n  let hasDecimal = false;\n  let hasDot = false;\n  let ch;\n\n  if (index >= max) {\n    path.err =\n      `${error}: ${invalidPathValue} at index ${index}, \"pathValue\" is missing param`;\n    return;\n  }\n  ch = pathValue.charCodeAt(index);\n\n  if (ch === 0x2b /* + */ || ch === 0x2d /* - */) {\n    index += 1;\n    // ch = (index < max) ? pathValue.charCodeAt(index) : 0;\n    ch = pathValue.charCodeAt(index);\n  }\n\n  // This logic is shamelessly borrowed from Esprima\n  // https://github.com/ariya/esprimas\n  if (!isDigit(ch) && ch !== 0x2e /* . */) {\n    // path.err = 'SvgPath: param should start with 0..9 or `.` (at pos ' + index + ')';\n    path.err = `${error}: ${invalidPathValue} at index ${index}, \"${\n      pathValue[index]\n    }\" is not a number`;\n    return;\n  }\n\n  if (ch !== 0x2e /* . */) {\n    zeroFirst = ch === 0x30 /* 0 */;\n    index += 1;\n\n    ch = pathValue.charCodeAt(index);\n\n    if (zeroFirst && index < max) {\n      // decimal number starts with '0' such as '09' is illegal.\n      if (ch && isDigit(ch)) {\n        // path.err = 'SvgPath: numbers started with `0` such as `09`\n        // are illegal (at pos ' + start + ')';\n        path.err = `${error}: ${invalidPathValue} at index ${start}, \"${\n          pathValue[start]\n        }\" illegal number`;\n        return;\n      }\n    }\n\n    while (index < max && isDigit(pathValue.charCodeAt(index))) {\n      index += 1;\n      hasCeiling = true;\n    }\n\n    ch = pathValue.charCodeAt(index);\n  }\n\n  if (ch === 0x2e /* . */) {\n    hasDot = true;\n    index += 1;\n    while (isDigit(pathValue.charCodeAt(index))) {\n      index += 1;\n      hasDecimal = true;\n    }\n\n    ch = pathValue.charCodeAt(index);\n  }\n\n  if (ch === 0x65 /* e */ || ch === 0x45 /* E */) {\n    if (hasDot && !hasCeiling && !hasDecimal) {\n      path.err = `${error}: ${invalidPathValue} at index ${index}, \"${\n        pathValue[index]\n      }\" invalid float exponent`;\n      return;\n    }\n\n    index += 1;\n\n    ch = pathValue.charCodeAt(index);\n\n    if (ch === 0x2b /* + */ || ch === 0x2d /* - */) {\n      index += 1;\n    }\n    if (index < max && isDigit(pathValue.charCodeAt(index))) {\n      while (index < max && isDigit(pathValue.charCodeAt(index))) {\n        index += 1;\n      }\n    } else {\n      path.err = `${error}: ${invalidPathValue} at index ${index}, \"${\n        pathValue[index]\n      }\" invalid integer exponent`;\n      return;\n    }\n  }\n\n  path.index = index;\n  path.param = +path.pathValue.slice(start, index);\n};\nexport default scanParam;\n","import type { SpaceNumber } from \"../types\";\n\n/**\n * Checks if the character is a space.\n *\n * @param ch the character to check\n * @returns check result\n */\n\nconst isSpace = (ch: number): ch is SpaceNumber => {\n  const allSpaces = [\n    // Special spaces\n    0x1680,\n    0x180e,\n    0x2000,\n    0x2001,\n    0x2002,\n    0x2003,\n    0x2004,\n    0x2005,\n    0x2006,\n    0x2007,\n    0x2008,\n    0x2009,\n    0x200a,\n    0x202f,\n    0x205f,\n    0x3000,\n    0xfeff,\n    // Line terminators\n    0x0a,\n    0x0d,\n    0x2028,\n    0x2029,\n    // White spaces\n    0x20,\n    0x09,\n    0x0b,\n    0x0c,\n    0xa0,\n  ];\n\n  return allSpaces.includes(ch);\n};\nexport default isSpace;\n","import isSpace from \"./isSpace\";\nimport type PathParser from \"./pathParser\";\n\n/**\n * Points the parser to the next character in the\n * path string every time it encounters any kind of\n * space character.\n *\n * @param path the `PathParser` instance\n */\nconst skipSpaces = (path: PathParser) => {\n  const { pathValue, max } = path;\n  while (path.index < max && isSpace(pathValue.charCodeAt(path.index))) {\n    path.index += 1;\n  }\n};\nexport default skipSpaces;\n","import type { PathCommandNumber } from \"../types\";\n\n/**\n * Checks if the character is a path command.\n *\n * @param code the character to check\n * @returns check result\n */\nconst isPathCommand = (code: number): code is PathCommandNumber => {\n  // eslint-disable-next-line no-bitwise -- Impossible to satisfy\n  switch (code | 0x20) {\n    case 0x6d /* m */:\n    case 0x7a /* z */:\n    case 0x6c /* l */:\n    case 0x68 /* h */:\n    case 0x76 /* v */:\n    case 0x63 /* c */:\n    case 0x73 /* s */:\n    case 0x71 /* q */:\n    case 0x74 /* t */:\n    case 0x61 /* a */:\n      // case 0x72/* r */:\n      return true;\n    default:\n      return false;\n  }\n};\nexport default isPathCommand;\n","import isDigit from \"./isDigit\";\nimport type { DigitNumber } from \"../types\";\n\n/**\n * Checks if the character is or belongs to a number.\n * [0-9]|+|-|.\n *\n * @param code the character to check\n * @returns check result\n */\nconst isDigitStart = (\n  code: number,\n): code is DigitNumber | 0x2b | 0x2d | 0x2e => {\n  return isDigit(code) /* 0..9 */ || code === 0x2b /* + */ ||\n    code === 0x2d /* - */ || code === 0x2e; /* . */\n};\nexport default isDigitStart;\n","/**\n * Checks if the character is an A (arc-to) path command.\n *\n * @param code the character to check\n * @returns check result\n */\nconst isArcCommand = (code: number): code is 0x61 => {\n  // eslint-disable-next-line no-bitwise -- Impossible to satisfy\n  return (code | 0x20) === 0x61;\n};\nexport default isArcCommand;\n","/**\n * Checks if the character is a MoveTo command.\n *\n * @param code the character to check\n * @returns check result\n */\nconst isMoveCommand = (code: number): code is 0x6d | 0x4d => {\n  // eslint-disable-next-line no-bitwise -- Impossible to satisfy\n  switch (code | 0x20) {\n    case 0x6d /* m */:\n    case 0x4d /* M */:\n      return true;\n    default:\n      return false;\n  }\n};\nexport default isMoveCommand;\n","import finalizeSegment from \"./finalizeSegment\";\nimport paramCounts from \"./paramsCount\";\nimport scanFlag from \"./scanFlag\";\nimport scanParam from \"./scanParam\";\nimport skipSpaces from \"./skipSpaces\";\nimport isPathCommand from \"./isPathCommand\";\nimport isDigitStart from \"./isDigitStart\";\nimport isArcCommand from \"./isArcCommand\";\nimport isMoveCommand from \"./isMoveCommand\";\nimport invalidPathValue from \"./invalidPathValue\";\nimport error from \"./error\";\n\nimport type PathParser from \"./pathParser\";\nimport type { PathSegment, RelativeCommand } from \"../types\";\n\n/**\n * Scans every character in the path string to determine\n * where a segment starts and where it ends.\n *\n * @param path the `PathParser` instance\n */\nconst scanSegment = (path: PathParser) => {\n  const { max, pathValue, index, segments } = path;\n  const cmdCode = pathValue.charCodeAt(index);\n  const reqParams =\n    paramCounts[pathValue[index].toLowerCase() as RelativeCommand];\n\n  path.segmentStart = index;\n\n  // segments always start with a path command\n  if (!isPathCommand(cmdCode)) {\n    path.err = `${error}: ${invalidPathValue} \"${\n      pathValue[index]\n    }\" is not a path command at index ${index}`;\n    return;\n  }\n\n  // after a Z segment, we only expect a MoveTo path command\n  const lastSegment = segments[segments.length - 1] as PathSegment | undefined;\n  if (\n    !isMoveCommand(cmdCode) && lastSegment?.[0]?.toLocaleLowerCase() === \"z\"\n  ) {\n    path.err = `${error}: ${invalidPathValue} \"${\n      pathValue[index]\n    }\" is not a MoveTo path command at index ${index}`;\n    return;\n  }\n\n  path.index += 1;\n  skipSpaces(path);\n\n  path.data = [];\n\n  if (!reqParams) {\n    // Z\n    finalizeSegment(path);\n    return;\n  }\n\n  for (;;) {\n    for (let i = reqParams; i > 0; i -= 1) {\n      if (isArcCommand(cmdCode) && (i === 3 || i === 4)) scanFlag(path);\n      else scanParam(path);\n\n      if (path.err.length) {\n        return;\n      }\n      path.data.push(path.param);\n\n      skipSpaces(path);\n\n      // after ',' param is mandatory\n      if (\n        path.index < max && pathValue.charCodeAt(path.index) === 0x2c /* , */\n      ) {\n        path.index += 1;\n        skipSpaces(path);\n      }\n    }\n\n    if (path.index >= path.max) {\n      break;\n    }\n\n    // Stop on next segment\n    if (!isDigitStart(pathValue.charCodeAt(path.index))) {\n      break;\n    }\n  }\n\n  finalizeSegment(path);\n};\nexport default scanSegment;\n","import type { PathArray, PathSegment } from \"../types\";\n\n/**\n * The `PathParser` is used by the `parsePathString` static method\n * to generate a `pathArray`.\n *\n * @param pathString\n */\nexport default class PathParser {\n  declare segments: PathArray | PathSegment[];\n  declare pathValue: string;\n  declare max: number;\n  declare index: number;\n  declare param: number;\n  declare segmentStart: number;\n  declare data: (string | number)[];\n  declare err: string;\n\n  constructor(pathString: string) {\n    this.segments = [];\n    this.pathValue = pathString;\n    this.max = pathString.length;\n    this.index = 0;\n    this.param = 0.0;\n    this.segmentStart = 0;\n    this.data = [];\n    this.err = \"\";\n  }\n}\n","import scanSegment from \"./scanSegment\";\nimport skipSpaces from \"./skipSpaces\";\nimport PathParser from \"./pathParser\";\nimport type { PathArray } from \"../types\";\n\n/**\n * Parses a path string value and returns an array\n * of segments we like to call `pathArray`.\n *\n * @param pathInput the string to be parsed\n * @returns the resulted `pathArray` or error string\n */\nconst parsePathString = <T extends PathArray>(pathInput: string | T) => {\n  if (typeof pathInput !== \"string\") {\n    return pathInput.slice(0) as typeof pathInput;\n  }\n\n  const path = new PathParser(pathInput);\n\n  skipSpaces(path);\n\n  while (path.index < path.max && !path.err.length) {\n    scanSegment(path);\n  }\n\n  // handle valid paths first\n  // handle errors second\n  if (!path.err.length) {\n    if (path.segments.length) {\n      /**\n       * force absolute first M\n       * getPathBBox calculation requires first segment to be absolute\n       * @see https://github.com/thednp/svg-path-commander/pull/49\n       */\n      path.segments[0][0] = \"M\";\n    }\n  } else {\n    throw TypeError(path.err);\n  }\n\n  return path.segments as PathArray;\n};\n\nexport default parsePathString;\n","import type {\n  AbsoluteCommand,\n  AbsoluteSegment,\n  ASegment,\n  CSegment,\n  HSegment,\n  LSegment,\n  MSegment,\n  PathSegment,\n  QSegment,\n  SSegment,\n  TSegment,\n  VSegment,\n} from \"../types\";\n\n/**\n * Returns an absolute segment of a `PathArray` object.\n *\n * @param segment the segment object\n * @param index the segment index\n * @param lastX the last known X value\n * @param lastY the last known Y value\n * @returns the absolute segment\n */\nconst absolutizeSegment = (\n  segment: PathSegment,\n  index: number,\n  lastX: number,\n  lastY: number,\n) => {\n  const [pathCommand] = segment;\n  const absCommand = pathCommand.toUpperCase() as AbsoluteCommand;\n  const isAbsolute = absCommand === pathCommand;\n\n  /* istanbul ignore else @preserve */\n  if (index === 0 || isAbsolute) return segment as MSegment | AbsoluteSegment;\n  // const values = segment.slice(1) as number[];\n  if (absCommand === \"A\") {\n    return [\n      absCommand,\n      segment[1],\n      segment[2],\n      segment[3],\n      segment[4],\n      segment[5],\n      (segment as ASegment)[6] + lastX,\n      (segment as ASegment)[7] + lastY,\n    ] as ASegment;\n  } else if (absCommand === \"V\") {\n    return [absCommand, (segment as VSegment)[1] + lastY] as VSegment;\n  } else if (absCommand === \"H\") {\n    return [absCommand, (segment as HSegment)[1] + lastX] as HSegment;\n  } else if (absCommand === \"L\") {\n    return [\n      absCommand,\n      (segment as LSegment)[1] + lastX,\n      (segment as LSegment)[2] + lastY,\n    ] as LSegment;\n  } else {\n    // use brakets for `eslint: no-case-declaration`\n    // https://stackoverflow.com/a/50753272/803358\n    const absValues = [] as number[];\n    const seglen = segment.length;\n    for (let j = 1; j < seglen; j += 1) {\n      absValues.push((segment[j] as number) + (j % 2 ? lastX : lastY));\n    }\n    // for c, s, q, t\n    return [absCommand as typeof absCommand | number].concat(absValues) as\n      | MSegment\n      | QSegment\n      | TSegment\n      | SSegment\n      | CSegment;\n  }\n};\nexport default absolutizeSegment;\n","// import paramsParser from '../parser/paramsParser';\nimport type {\n  AbsoluteCommand,\n  IteratorCallback,\n  PathArray,\n  PathCommand,\n  PathSegment,\n} from \"../types\";\n\nconst iterate = <T extends PathArray>(\n  path: PathArray,\n  iterator: IteratorCallback,\n) => {\n  let pathLen = path.length;\n  let segment: PathSegment;\n  let pathCommand = \"M\" as PathCommand;\n  let absCommand = \"M\" as AbsoluteCommand;\n  let isRelative = false;\n  let x = 0;\n  let y = 0;\n  let mx = 0;\n  let my = 0;\n  let segLen = 0;\n\n  for (let i = 0; i < pathLen; i += 1) {\n    segment = path[i];\n    [pathCommand] = segment;\n    segLen = segment.length;\n    absCommand = pathCommand.toUpperCase() as AbsoluteCommand;\n    isRelative = absCommand !== pathCommand;\n\n    const iteratorResult = iterator(segment, i, x, y);\n    // some methods like getPointAtLength would like to break\n    // when task is complete\n    if (iteratorResult === false) {\n      break;\n    }\n\n    // segment = path[i];\n    if (absCommand === \"Z\") {\n      x = mx;\n      y = my;\n    } else if (absCommand === \"H\") {\n      x = (segment[1] as number) + (isRelative ? x : 0);\n    } else if (absCommand === \"V\") {\n      y = (segment[1] as number) + (isRelative ? y : 0);\n    } else {\n      x = (segment[segLen - 2] as number) + (isRelative ? x : 0);\n      y = (segment[segLen - 1] as number) + (isRelative ? y : 0);\n\n      if (absCommand === \"M\") {\n        mx = x;\n        my = y;\n      }\n    }\n\n    if (iteratorResult) {\n      path[i] = iteratorResult;\n      if (iteratorResult[0] === \"C\") {\n        pathLen = path.length;\n      }\n    }\n  }\n  return path as T;\n};\n\nexport default iterate;\n","import parsePathString from \"../parser/parsePathString\";\nimport absolutizeSegment from \"../process/absolutizeSegment\";\nimport type { AbsoluteArray, PathArray } from \"../types\";\nimport iterate from \"../process/iterate\";\n\n/**\n * Parses a path string value or object and returns an array\n * of segments, all converted to absolute values.\n *\n * @param pathInput the path string | object\n * @returns the resulted `pathArray` with absolute values\n */\nconst pathToAbsolute = (pathInput: string | PathArray) => {\n  const path = parsePathString(pathInput);\n\n  return iterate<AbsoluteArray>(path, absolutizeSegment);\n};\nexport default pathToAbsolute;\n","import type {\n  aSegment,\n  cSegment,\n  hSegment,\n  lSegment,\n  MSegment,\n  PathSegment,\n  qSegment,\n  RelativeCommand,\n  RelativeSegment,\n  sSegment,\n  tSegment,\n  vSegment,\n} from \"../types\";\n\n/**\n * Returns a relative segment of a `PathArray` object.\n *\n * @param segment the segment object\n * @param index the segment index\n * @param lastX the last known X value\n * @param lastY the last known Y value\n * @returns the relative segment\n */\nconst relativizeSegment = (\n  segment: PathSegment,\n  index: number,\n  lastX: number,\n  lastY: number,\n) => {\n  const [pathCommand] = segment;\n  const relCommand = pathCommand.toLowerCase() as RelativeCommand;\n  const isRelative = pathCommand === relCommand;\n\n  /* istanbul ignore else @preserve */\n  if (index === 0 || isRelative) return segment as MSegment | RelativeSegment;\n\n  if (relCommand === \"a\") {\n    return [\n      relCommand,\n      segment[1],\n      segment[2],\n      segment[3],\n      segment[4],\n      segment[5],\n      (segment as aSegment)[6] - lastX,\n      (segment as aSegment)[7] - lastY,\n    ] as aSegment;\n  } else if (relCommand === \"v\") {\n    return [relCommand, (segment as vSegment)[1] - lastY] as vSegment;\n  } else if (relCommand === \"h\") {\n    return [relCommand, (segment as hSegment)[1] - lastX] as hSegment;\n  } else if (relCommand === \"l\") {\n    return [\n      relCommand,\n      (segment as lSegment)[1] - lastX,\n      (segment as lSegment)[2] - lastY,\n    ] as lSegment;\n  } else {\n    // use brakets for `eslint: no-case-declaration`\n    // https://stackoverflow.com/a/50753272/803358\n    const relValues = [] as number[];\n    const seglen = segment.length;\n    for (let j = 1; j < seglen; j += 1) {\n      relValues.push((segment[j] as number) - (j % 2 ? lastX : lastY));\n    }\n    // for c, s, q, t\n    return [relCommand as RelativeCommand | number].concat(relValues) as\n      | qSegment\n      | tSegment\n      | sSegment\n      | cSegment;\n  }\n};\n\nexport default relativizeSegment;\n","import type { PathArray, RelativeArray } from \"../types\";\nimport parsePathString from \"../parser/parsePathString\";\nimport iterate from \"../process/iterate\";\nimport relativizeSegment from \"../process/relativizeSegment\";\n\n/**\n * Parses a path string value or object and returns an array\n * of segments, all converted to relative values.\n *\n * @param pathInput the path string | object\n * @returns the resulted `pathArray` with relative values\n */\nconst pathToRelative = (pathInput: string | PathArray): RelativeArray => {\n  const path = parsePathString(pathInput);\n\n  return iterate<RelativeArray>(path, relativizeSegment);\n};\nexport default pathToRelative;\n","/**\n * Returns an {x,y} vector rotated by a given\n * angle in radian.\n *\n * @param x the initial vector x\n * @param y the initial vector y\n * @param rad the radian vector angle\n * @returns the rotated vector\n */\nconst rotateVector = (\n  x: number,\n  y: number,\n  rad: number,\n): { x: number; y: number } => {\n  const { sin, cos } = Math;\n  const X = x * cos(rad) - y * sin(rad);\n  const Y = x * sin(rad) + y * cos(rad);\n  return { x: X, y: Y };\n};\n\nexport default rotateVector;\n","import rotateVector from \"../math/rotateVector\";\n\n/**\n * Converts A (arc-to) segments to C (cubic-bezier-to).\n *\n * For more information of where this math came from visit:\n * http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n *\n * @param X1 the starting x position\n * @param Y1 the starting y position\n * @param RX x-radius of the arc\n * @param RY y-radius of the arc\n * @param angle x-axis-rotation of the arc\n * @param LAF large-arc-flag of the arc\n * @param SF sweep-flag of the arc\n * @param X2 the ending x position\n * @param Y2 the ending y position\n * @param recursive the parameters needed to split arc into 2 segments\n * @return the resulting cubic-bezier segment(s)\n */\nconst arcToCubic = (\n  X1: number,\n  Y1: number,\n  RX: number,\n  RY: number,\n  angle: number,\n  LAF: number,\n  SF: number,\n  X2: number,\n  Y2: number,\n  recursive?: [number, number, number, number],\n): number[] => {\n  let x1 = X1;\n  let y1 = Y1;\n  let rx = RX;\n  let ry = RY;\n  let x2 = X2;\n  let y2 = Y2;\n  // for more information of where this Math came from visit:\n  // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n  const d120 = (Math.PI * 120) / 180;\n\n  const rad = (Math.PI / 180) * (+angle || 0);\n  let res = [] as number[];\n  let xy;\n  let f1;\n  let f2;\n  let cx;\n  let cy;\n\n  if (!recursive) {\n    xy = rotateVector(x1, y1, -rad);\n    x1 = xy.x;\n    y1 = xy.y;\n    xy = rotateVector(x2, y2, -rad);\n    x2 = xy.x;\n    y2 = xy.y;\n\n    const x = (x1 - x2) / 2;\n    const y = (y1 - y2) / 2;\n    let h = (x * x) / (rx * rx) + (y * y) / (ry * ry);\n    if (h > 1) {\n      h = Math.sqrt(h);\n      rx *= h;\n      ry *= h;\n    }\n    const rx2 = rx * rx;\n    const ry2 = ry * ry;\n\n    const k = (LAF === SF ? -1 : 1) *\n      Math.sqrt(\n        Math.abs(\n          (rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x),\n        ),\n      );\n\n    cx = (k * rx * y) / ry + (x1 + x2) / 2;\n    cy = (k * -ry * x) / rx + (y1 + y2) / 2;\n    // eslint-disable-next-line no-bitwise -- Impossible to satisfy no-bitwise\n    f1 = Math.asin(((((y1 - cy) / ry) * 10 ** 9) >> 0) / 10 ** 9);\n    // eslint-disable-next-line no-bitwise -- Impossible to satisfy no-bitwise\n    f2 = Math.asin(((((y2 - cy) / ry) * 10 ** 9) >> 0) / 10 ** 9);\n\n    f1 = x1 < cx ? Math.PI - f1 : f1;\n    f2 = x2 < cx ? Math.PI - f2 : f2;\n    if (f1 < 0) f1 = Math.PI * 2 + f1;\n    if (f2 < 0) f2 = Math.PI * 2 + f2;\n    if (SF && f1 > f2) {\n      f1 -= Math.PI * 2;\n    }\n    if (!SF && f2 > f1) {\n      f2 -= Math.PI * 2;\n    }\n  } else {\n    [f1, f2, cx, cy] = recursive;\n  }\n  let df = f2 - f1;\n  if (Math.abs(df) > d120) {\n    const f2old = f2;\n    const x2old = x2;\n    const y2old = y2;\n    f2 = f1 + d120 * (SF && f2 > f1 ? 1 : -1);\n    x2 = cx + rx * Math.cos(f2);\n    y2 = cy + ry * Math.sin(f2);\n    res = arcToCubic(x2, y2, rx, ry, angle, 0, SF, x2old, y2old, [\n      f2,\n      f2old,\n      cx,\n      cy,\n    ]);\n  }\n  df = f2 - f1;\n  const c1 = Math.cos(f1);\n  const s1 = Math.sin(f1);\n  const c2 = Math.cos(f2);\n  const s2 = Math.sin(f2);\n  const t = Math.tan(df / 4);\n  const hx = (4 / 3) * rx * t;\n  const hy = (4 / 3) * ry * t;\n  const m1 = [x1, y1];\n  const m2 = [x1 + hx * s1, y1 - hy * c1];\n  const m3 = [x2 + hx * s2, y2 - hy * c2];\n  const m4 = [x2, y2];\n  m2[0] = 2 * m1[0] - m2[0];\n  m2[1] = 2 * m1[1] - m2[1];\n  if (recursive) {\n    return [m2[0], m2[1], m3[0], m3[1], m4[0], m4[1]].concat(res);\n  }\n  res = [m2[0], m2[1], m3[0], m3[1], m4[0], m4[1]].concat(res);\n  const newres = [];\n  for (let i = 0, ii = res.length; i < ii; i += 1) {\n    newres[i] = i % 2\n      ? rotateVector(res[i - 1], res[i], rad).y\n      : rotateVector(res[i], res[i + 1], rad).x;\n  }\n  return newres;\n};\nexport default arcToCubic;\n","/**\n * Converts a Q (quadratic-bezier) segment to C (cubic-bezier).\n *\n * @param x1 curve start x\n * @param y1 curve start y\n * @param qx control point x\n * @param qy control point y\n * @param x2 curve end x\n * @param y2 curve end y\n * @returns the cubic-bezier segment\n */\nconst quadToCubic = (\n  x1: number,\n  y1: number,\n  qx: number,\n  qy: number,\n  x2: number,\n  y2: number,\n): [number, number, number, number, number, number] => {\n  const r13 = 1 / 3;\n  const r23 = 2 / 3;\n  return [\n    r13 * x1 + r23 * qx, // cpx1\n    r13 * y1 + r23 * qy, // cpy1\n    r13 * x2 + r23 * qx, // cpx2\n    r13 * y2 + r23 * qy, // cpy2\n    x2,\n    y2, // x,y\n  ];\n};\nexport default quadToCubic;\n","import midPoint from \"../math/midPoint\";\n\n/**\n * Converts an L (line-to) segment to C (cubic-bezier).\n *\n * @param x1 line start x\n * @param y1 line start y\n * @param x2 line end x\n * @param y2 line end y\n * @returns the cubic-bezier segment\n */\nconst lineToCubic = (x1: number, y1: number, x2: number, y2: number) => {\n  const c1 = midPoint([x1, y1], [x2, y2], 1.0 / 3.0);\n  const c2 = midPoint([x1, y1], [x2, y2], 2.0 / 3.0);\n  return [c1[0], c1[1], c2[0], c2[1], x2, y2];\n};\nexport default lineToCubic;\n","import arcToCubic from \"./arcToCubic\";\nimport quadToCubic from \"./quadToCubic\";\nimport lineToCubic from \"./lineToCubic\";\nimport type { CSegment, MSegment, PathSegment } from \"../types\";\nimport type { ParserParams } from \"../interface\";\n\n/**\n * Converts any segment to C (cubic-bezier).\n *\n * @param segment the source segment\n * @param params the source segment parameters\n * @returns the cubic-bezier segment\n */\nconst segmentToCubic = (segment: PathSegment, params: ParserParams) => {\n  const [pathCommand] = segment;\n  const values = segment.slice(1).map(Number);\n  const [x, y] = values;\n  // let args;\n  const { x1: px1, y1: py1, x: px, y: py } = params;\n\n  if (!\"TQ\".includes(pathCommand)) {\n    params.qx = null;\n    params.qy = null;\n  }\n\n  if (pathCommand === \"M\") {\n    params.x = x;\n    params.y = y;\n    return segment;\n  } else if (pathCommand === \"A\") {\n    return [\"C\" as string | number].concat(\n      arcToCubic(\n        px1,\n        py1,\n        values[0],\n        values[1],\n        values[2],\n        values[3],\n        values[4],\n        values[5],\n        values[6],\n      ),\n    ) as CSegment;\n  } else if (pathCommand === \"Q\") {\n    params.qx = x;\n    params.qy = y;\n    return [\"C\" as string | number].concat(\n      quadToCubic(px1, py1, values[0], values[1], values[2], values[3]),\n    ) as CSegment;\n  } else if (pathCommand === \"L\") {\n    return [\"C\" as string | number].concat(\n      lineToCubic(px1, py1, x, y),\n    ) as CSegment;\n  } else if (pathCommand === \"Z\") {\n    return [\"C\" as string | number].concat(\n      lineToCubic(px1, py1, px, py),\n    ) as CSegment;\n  }\n\n  return segment as MSegment | CSegment;\n};\nexport default segmentToCubic;\n","import type { ParserParams } from \"../interface\";\nimport type {\n  ASegment,\n  CSegment,\n  HSegment,\n  LSegment,\n  MSegment,\n  NormalSegment,\n  PathCommand,\n  PathSegment,\n  PointTuple,\n  QSegment,\n  VSegment,\n} from \"../types\";\n\n/**\n * Normalizes a single segment of a `pathArray` object.\n *\n * @param segment the segment object\n * @param params the normalization parameters\n * @returns the normalized segment\n */\nconst normalizeSegment = (segment: PathSegment, params: ParserParams) => {\n  const [pathCommand] = segment;\n  const absCommand = pathCommand.toUpperCase();\n  const isRelative = pathCommand !== absCommand;\n  const { x1: px1, y1: py1, x2: px2, y2: py2, x, y } = params;\n  const values = segment.slice(1) as number[];\n  let absValues = values.map((n, j) => n + (isRelative ? (j % 2 ? y : x) : 0));\n\n  if (!\"TQ\".includes(absCommand)) {\n    // optional but good to be cautious\n    params.qx = null;\n    params.qy = null;\n  }\n\n  // istanbul ignore else @preserve\n  if (absCommand === \"A\") {\n    absValues = values.slice(0, -2).concat(\n      values[5] + (isRelative ? x : 0),\n      values[6] + (isRelative ? y : 0),\n    );\n\n    return [\"A\" as PathCommand | number].concat(absValues) as ASegment;\n  } else if (absCommand === \"H\") {\n    return [\n      \"L\",\n      (segment as HSegment)[1] + (isRelative ? x : 0),\n      py1,\n    ] as LSegment;\n  } else if (absCommand === \"V\") {\n    return [\n      \"L\",\n      px1,\n      (segment as VSegment)[1] + (isRelative ? y : 0),\n    ] as LSegment;\n  } else if (absCommand === \"L\") {\n    return [\n      \"L\",\n      (segment as LSegment)[1] + (isRelative ? x : 0),\n      (segment as LSegment)[2] + (isRelative ? y : 0),\n    ] as LSegment;\n  } else if (absCommand === \"M\") {\n    return [\n      \"M\",\n      (segment as MSegment)[1] + (isRelative ? x : 0),\n      (segment as MSegment)[2] + (isRelative ? y : 0),\n    ] as MSegment;\n  } else if (absCommand === \"C\") {\n    return [\"C\" as PathCommand | number].concat(absValues) as CSegment;\n  } else if (absCommand === \"S\") {\n    const x1 = px1 * 2 - px2;\n    const y1 = py1 * 2 - py2;\n    params.x1 = x1;\n    params.y1 = y1;\n    return [\"C\", x1, y1].concat(absValues) as CSegment;\n  } else if (absCommand === \"T\") {\n    const qx = px1 * 2 - (params.qx ? params.qx : /* istanbul ignore next */ 0);\n    const qy = py1 * 2 - (params.qy ? params.qy : /* istanbul ignore next */ 0);\n    params.qx = qx;\n    params.qy = qy;\n    return [\"Q\", qx, qy].concat(absValues) as QSegment;\n  } else if (absCommand === \"Q\") {\n    const [nqx, nqy] = absValues as PointTuple;\n    params.qx = nqx;\n    params.qy = nqy;\n    return [\"Q\" as PathCommand | number].concat(absValues) as QSegment;\n  } else if (absCommand === \"Z\") {\n    return [\"Z\"] as NormalSegment;\n  }\n\n  // istanbul ignore next @preserve\n  return segment as NormalSegment;\n};\nexport default normalizeSegment;\n","import type { ParserParams } from \"../interface\";\n\nconst paramsParser: ParserParams = {\n  x1: 0,\n  y1: 0,\n  x2: 0,\n  y2: 0,\n  x: 0,\n  y: 0,\n  qx: null,\n  qy: null,\n};\n\nexport default paramsParser;\n","import segmentToCubic from \"../process/segmentToCubic\";\nimport { AbsoluteCommand, CSegment, CurveArray, PathArray } from \"../types\";\nimport iterate from \"../process/iterate\";\nimport parsePathString from \"../parser/parsePathString\";\nimport normalizeSegment from \"../process/normalizeSegment\";\nimport paramsParser from \"../parser/paramsParser\";\n\n/**\n * Parses a path string value or 'pathArray' and returns a new one\n * in which all segments are converted to cubic-bezier.\n *\n * In addition, un-necessary `Z` segment is removed if previous segment\n * extends to the `M` segment.\n *\n * @param pathInput the string to be parsed or 'pathArray'\n * @returns the resulted `pathArray` converted to cubic-bezier\n */\nconst pathToCurve = (pathInput: string | PathArray): CurveArray => {\n  const params = { ...paramsParser };\n  const path = parsePathString(pathInput);\n\n  return iterate<CurveArray>(path, (seg, index, lastX, lastY) => {\n    params.x = lastX;\n    params.y = lastY;\n    const normalSegment = normalizeSegment(seg, params);\n    let result = segmentToCubic(normalSegment, params);\n    const isLongArc = result[0] === \"C\" && result.length > 7;\n\n    if (isLongArc) {\n      path.splice(\n        index + 1,\n        0,\n        [\"C\" as AbsoluteCommand | number].concat(result.slice(7)) as CSegment,\n      );\n      result = result.slice(0, 7) as CSegment;\n    }\n\n    const seglen = result.length;\n    params.x1 = +result[seglen - 2];\n    params.y1 = +result[seglen - 1];\n    params.x2 = +result[seglen - 4] || params.x1;\n    params.y2 = +result[seglen - 3] || params.y1;\n\n    return result;\n  });\n};\nexport default pathToCurve;\n","import { Options } from \"../interface\";\n\n/** SVGPathCommander default options */\nconst defaultOptions: Options = {\n  origin: [0, 0, 0],\n  round: 4,\n};\n\nexport default defaultOptions;\n","const roundTo = (n: number, round: number) => {\n  const pow = round >= 1 ? 10 ** round : 1;\n\n  return round > 0 ? Math.round(n * pow) / pow : Math.round(n);\n};\n\nexport default roundTo;\n","import type { PathArray, PathSegment } from \"../types\";\nimport defaultOptions from \"../options/options\";\nimport roundTo from \"../math/roundTo\";\n\n/**\n * Returns a valid `d` attribute string value created\n * by rounding values and concatenating the `pathArray` segments.\n *\n * @param path the `pathArray` object\n * @param roundOption amount of decimals to round values to\n * @returns the concatenated path string\n */\nconst pathToString = (\n  path: PathArray,\n  roundOption?: number | \"off\",\n): string => {\n  const pathLen = path.length;\n  let { round } = defaultOptions;\n  let segment = path[0] as PathSegment;\n  let result = \"\";\n\n  // allow for ZERO decimals\n  round = roundOption === \"off\"\n    ? roundOption\n    : typeof roundOption === \"number\" && roundOption >= 0\n    ? roundOption\n    : typeof round === \"number\" && round >= 0\n    ? round\n    : /* istanbul ignore next @preserve */ \"off\";\n\n  for (let i = 0; i < pathLen; i += 1) {\n    segment = path[i];\n    const [pathCommand] = segment;\n    const values = segment.slice(1) as number[];\n    result += pathCommand;\n    if (round === \"off\") {\n      result += values.join(\" \");\n    } else {\n      let j = 0;\n      const valLen = values.length;\n      while (j < valLen) {\n        result += roundTo(values[j], round);\n        if (j !== valLen - 1) result += \" \";\n        j += 1;\n      }\n    }\n  }\n\n  return result;\n};\n\nexport default pathToString;\n","const DISTANCE_EPSILON = 0.00001;\n\nexport default DISTANCE_EPSILON;\n","import normalizeSegment from \"./normalizeSegment\";\nimport type { NormalArray, PathArray } from \"../types\";\nimport iterate from \"./iterate\";\nimport parsePathString from \"../parser/parsePathString\";\nimport paramsParser from \"../parser/paramsParser\";\n\n/**\n * Normalizes a `pathArray` object for further processing:\n * * convert segments to absolute values\n * * convert shorthand path commands to their non-shorthand notation\n *\n * @param pathInput the string to be parsed or 'pathArray'\n * @returns the normalized `pathArray`\n */\nconst normalizePath = (pathInput: string | PathArray) => {\n  const path = parsePathString(pathInput);\n  const params = { ...paramsParser };\n\n  return iterate<NormalArray>(path, (seg, _, lastX, lastY) => {\n    params.x = lastX;\n    params.y = lastY;\n    const result = normalizeSegment(seg, params);\n\n    const seglen = result.length;\n    params.x1 = +result[seglen - 2];\n    params.y1 = +result[seglen - 1];\n    params.x2 = +result[seglen - 4] || params.x1;\n    params.y2 = +result[seglen - 3] || params.y1;\n\n    return result;\n  });\n};\nexport default normalizePath;\n","import DISTANCE_EPSILON from \"./distanceEpsilon\";\nimport type { MSegment, PathArray, PointTuple } from \"../types\";\nimport iterate from \"../process/iterate\";\nimport { getLineLength, getPointAtLineLength } from \"../math/lineTools\";\nimport { getArcLength, getPointAtArcLength } from \"../math/arcTools\";\nimport { getCubicLength, getPointAtCubicLength } from \"../math/cubicTools\";\nimport { getPointAtQuadLength, getQuadLength } from \"../math/quadTools\";\nimport normalizePath from \"../process/normalizePath\";\n\n/**\n * Returns [x,y] coordinates of a point at a given length of a shape.\n *\n * @param pathInput the `pathArray` to look into\n * @param distance the length of the shape to look at\n * @returns the requested {x, y} point coordinates\n */\nconst getPointAtLength = (pathInput: string | PathArray, distance?: number) => {\n  const path = normalizePath(pathInput);\n  let isM = false;\n  let data = [] as number[];\n  let pathCommand = \"M\";\n  let x = 0;\n  let y = 0;\n  let [mx, my] = path[0].slice(1) as PointTuple;\n  const distanceIsNumber = typeof distance === \"number\";\n  let point = { x: mx, y: my };\n  let length = 0;\n  let POINT = point;\n  let totalLength = 0;\n\n  if (!distanceIsNumber || distance < DISTANCE_EPSILON) return point;\n\n  // for (let i = 0; i < pathLen; i += 1) {\n  iterate(path, (seg, _, lastX, lastY) => {\n    [pathCommand] = seg;\n    isM = pathCommand === \"M\";\n    data = !isM ? [lastX, lastY].concat(seg.slice(1) as number[]) : data;\n\n    // this segment is always ZERO\n    /* istanbul ignore else @preserve */\n    if (isM) {\n      // remember mx, my for Z\n      [, mx, my] = seg as MSegment;\n      point = { x: mx, y: my };\n      length = 0;\n    } else if (pathCommand === \"L\") {\n      point = getPointAtLineLength(\n        data[0],\n        data[1],\n        data[2],\n        data[3],\n        distance - totalLength,\n      );\n      length = getLineLength(data[0], data[1], data[2], data[3]);\n    } else if (pathCommand === \"A\") {\n      point = getPointAtArcLength(\n        data[0],\n        data[1],\n        data[2],\n        data[3],\n        data[4],\n        data[5],\n        data[6],\n        data[7],\n        data[8],\n        distance - totalLength,\n      );\n      length = getArcLength(\n        data[0],\n        data[1],\n        data[2],\n        data[3],\n        data[4],\n        data[5],\n        data[6],\n        data[7],\n        data[8],\n      );\n    } else if (pathCommand === \"C\") {\n      point = getPointAtCubicLength(\n        data[0],\n        data[1],\n        data[2],\n        data[3],\n        data[4],\n        data[5],\n        data[6],\n        data[7],\n        distance - totalLength,\n      );\n      length = getCubicLength(\n        data[0],\n        data[1],\n        data[2],\n        data[3],\n        data[4],\n        data[5],\n        data[6],\n        data[7],\n      );\n    } else if (pathCommand === \"Q\") {\n      point = getPointAtQuadLength(\n        data[0],\n        data[1],\n        data[2],\n        data[3],\n        data[4],\n        data[5],\n        distance - totalLength,\n      );\n      length = getQuadLength(\n        data[0],\n        data[1],\n        data[2],\n        data[3],\n        data[4],\n        data[5],\n      );\n    } else if (pathCommand === \"Z\") {\n      data = [lastX, lastY, mx, my];\n      point = { x: mx, y: my };\n\n      length = getLineLength(data[0], data[1], data[2], data[3]);\n    }\n\n    [x, y] = data.slice(-2);\n\n    if (totalLength < distance) {\n      POINT = point;\n    } else {\n      // totalLength >= distance\n      // stop right here\n      // stop iterator now!\n      return false;\n    }\n\n    totalLength += length;\n    return;\n  });\n\n  // native `getPointAtLength` behavior when the given distance\n  // is higher than total length\n  if (distance > totalLength - DISTANCE_EPSILON) {\n    return { x, y };\n  }\n\n  return POINT;\n};\n\nexport default getPointAtLength;\n","import type { LSegment, MSegment, PathArray, PointTuple } from \"../types\";\nimport { getLineLength } from \"../math/lineTools\";\nimport { getArcLength } from \"../math/arcTools\";\nimport { getCubicLength } from \"../math/cubicTools\";\nimport { getQuadLength } from \"../math/quadTools\";\nimport iterate from \"../process/iterate\";\nimport parsePathString from \"../parser/parsePathString\";\nimport absolutizeSegment from \"../process/absolutizeSegment\";\n\n/**\n * Returns the shape total length, or the equivalent to `shape.getTotalLength()`.\n *\n * @param pathInput the target `pathArray`\n * @returns the shape total length\n */\nconst getTotalLength = (pathInput: string | PathArray) => {\n  const path = parsePathString(pathInput);\n  let paramX1 = 0;\n  let paramY1 = 0;\n  let paramX2 = 0;\n  let paramY2 = 0;\n  let paramQX = 0;\n  let paramQY = 0;\n  let pathCommand = \"M\";\n  let mx = 0;\n  let my = 0;\n  let totalLength = 0;\n\n  iterate(path, (seg, index, lastX, lastY) => {\n    [pathCommand] = seg;\n    const absCommand = pathCommand.toUpperCase();\n    const isRelative = absCommand !== pathCommand;\n    const absoluteSegment = isRelative\n      ? absolutizeSegment(seg, index, lastX, lastY)\n      : (seg.slice(0) as typeof seg);\n\n    const normalSegment = absCommand === \"V\"\n      ? ([\"L\", lastX, absoluteSegment[1]] as LSegment)\n      : absCommand === \"H\"\n      ? ([\"L\", absoluteSegment[1], lastY] as LSegment)\n      : absoluteSegment;\n    [pathCommand] = normalSegment;\n\n    if (!\"TQ\".includes(absCommand)) {\n      // optional but good to be cautious\n      paramQX = 0;\n      paramQY = 0;\n    }\n\n    // this segment is always ZERO\n    /* istanbul ignore else @preserve */\n    if (pathCommand === \"M\") {\n      // remember mx, my for Z\n      [, mx, my] = normalSegment as MSegment;\n    } else if (pathCommand === \"L\") {\n      totalLength += getLineLength(\n        lastX,\n        lastY,\n        normalSegment[1] as number,\n        normalSegment[2] as number,\n      );\n    } else if (pathCommand === \"A\") {\n      totalLength += getArcLength(\n        lastX,\n        lastY,\n        normalSegment[1] as number,\n        normalSegment[2] as number,\n        normalSegment[3] as number,\n        normalSegment[4] as number,\n        normalSegment[5] as number,\n        normalSegment[6] as number,\n        normalSegment[7] as number,\n      );\n    } else if (pathCommand === \"S\") {\n      const cp1x = paramX1 * 2 - paramX2;\n      const cp1y = paramY1 * 2 - paramY2;\n\n      totalLength += getCubicLength(\n        lastX,\n        lastY,\n        cp1x,\n        cp1y,\n        normalSegment[1] as number,\n        normalSegment[2] as number,\n        normalSegment[3] as number,\n        normalSegment[4] as number,\n      );\n    } else if (pathCommand === \"C\") {\n      totalLength += getCubicLength(\n        lastX,\n        lastY,\n        normalSegment[1] as number,\n        normalSegment[2] as number,\n        normalSegment[3] as number,\n        normalSegment[4] as number,\n        normalSegment[5] as number,\n        normalSegment[6] as number,\n      );\n    } else if (pathCommand === \"T\") {\n      paramQX = paramX1 * 2 - paramQX;\n      paramQY = paramY1 * 2 - paramQY;\n      totalLength += getQuadLength(\n        lastX,\n        lastY,\n        paramQX,\n        paramQY,\n        normalSegment[1] as number,\n        normalSegment[2] as number,\n      );\n    } else if (pathCommand === \"Q\") {\n      paramQX = normalSegment[1] as number;\n      paramQY = normalSegment[2] as number;\n      totalLength += getQuadLength(\n        lastX,\n        lastY,\n        normalSegment[1] as number,\n        normalSegment[2] as number,\n        normalSegment[3] as number,\n        normalSegment[4] as number,\n      );\n    } else if (pathCommand === \"Z\") {\n      totalLength += getLineLength(lastX, lastY, mx, my);\n    }\n\n    // update params\n    [paramX1, paramY1] = pathCommand === \"Z\"\n      ? [mx, my]\n      : (normalSegment.slice(-2) as PointTuple);\n    [paramX2, paramY2] = pathCommand === \"C\"\n      ? ([normalSegment[3], normalSegment[4]] as PointTuple)\n      : pathCommand === \"S\"\n      ? ([normalSegment[1], normalSegment[2]] as PointTuple)\n      : [paramX1, paramY1];\n  });\n\n  return totalLength;\n};\n\nexport default getTotalLength;\n","import type { PathArray, PathSegment } from \"../types\";\nimport type { SegmentProperties } from \"../interface\";\nimport parsePathString from \"../parser/parsePathString\";\nimport getTotalLength from \"./getTotalLength\";\n\n/**\n * Returns the segment, its index and length as well as\n * the length to that segment at a given length in a path.\n *\n * @param pathInput target `pathArray`\n * @param distance the given length\n * @returns the requested properties\n */\nconst getPropertiesAtLength = (\n  pathInput: string | PathArray,\n  distance?: number,\n): SegmentProperties => {\n  const pathArray = parsePathString(pathInput);\n\n  let pathTemp = pathArray.slice(0) as PathArray;\n  let pathLength = getTotalLength(pathTemp);\n  let index = pathTemp.length - 1;\n  let lengthAtSegment = 0;\n  let length = 0;\n  let segment = pathArray[0] as PathSegment;\n\n  // If the path is empty, return 0.\n  if (index <= 0 || !distance || !Number.isFinite(distance)) {\n    return {\n      segment,\n      index: 0,\n      length,\n      lengthAtSegment,\n    };\n  }\n\n  if (distance >= pathLength) {\n    pathTemp = pathArray.slice(0, -1) as PathArray;\n    lengthAtSegment = getTotalLength(pathTemp);\n    length = pathLength - lengthAtSegment;\n    segment = pathArray[index];\n    return {\n      segment,\n      index,\n      length,\n      lengthAtSegment,\n    };\n  }\n\n  const segments = [] as SegmentProperties[];\n  while (index > 0) {\n    segment = pathTemp[index];\n    pathTemp = pathTemp.slice(0, -1) as PathArray;\n    lengthAtSegment = getTotalLength(pathTemp);\n    length = pathLength - lengthAtSegment;\n    pathLength = lengthAtSegment;\n\n    segments.push({\n      segment,\n      index,\n      length,\n      lengthAtSegment,\n    });\n    index -= 1;\n  }\n\n  return segments.find(({ lengthAtSegment: l }) =>\n    l <= distance\n  ) as SegmentProperties;\n};\n\nexport default getPropertiesAtLength;\n","import type { PathArray, Point } from \"../types\";\nimport type { PointProperties } from \"../interface\";\nimport getPointAtLength from \"./getPointAtLength\";\nimport getPropertiesAtLength from \"./getPropertiesAtLength\";\nimport getTotalLength from \"./getTotalLength\";\nimport parsePathString from \"../parser/parsePathString\";\nimport normalizePath from \"../process/normalizePath\";\n\n/**\n * Returns the point and segment in path closest to a given point as well as\n * the distance to the path stroke.\n *\n * @see https://bl.ocks.org/mbostock/8027637\n *\n * @param pathInput target `pathArray`\n * @param point the given point\n * @returns the requested properties\n */\nconst getPropertiesAtPoint = (\n  pathInput: string | PathArray,\n  point: Point,\n): PointProperties => {\n  const path = parsePathString(pathInput);\n  const normalPath = normalizePath(path);\n  const pathLength = getTotalLength(normalPath);\n  const distanceTo = (p: Point) => {\n    const dx = p.x - point.x;\n    const dy = p.y - point.y;\n    return dx * dx + dy * dy;\n  };\n  let precision = 8;\n  let scan: Point;\n  let closest = { x: 0, y: 0 }; // make TS happy\n  let scanDistance = 0;\n  let bestLength = 0;\n  let bestDistance = Infinity;\n\n  // linear scan for coarse approximation\n  for (let scanLength = 0; scanLength <= pathLength; scanLength += precision) {\n    scan = getPointAtLength(normalPath, scanLength);\n    scanDistance = distanceTo(scan);\n\n    if (scanDistance < bestDistance) {\n      closest = scan;\n      bestLength = scanLength;\n      bestDistance = scanDistance;\n    }\n  }\n\n  // binary search for precise estimate\n  precision /= 2;\n  let before: { x: number; y: number };\n  let after: { x: number; y: number };\n  let beforeLength = 0;\n  let afterLength = 0;\n  let beforeDistance = 0;\n  let afterDistance = 0;\n\n  while (precision > 0.000001) {\n    beforeLength = bestLength - precision;\n    before = getPointAtLength(normalPath, beforeLength);\n    beforeDistance = distanceTo(before);\n    afterLength = bestLength + precision;\n    after = getPointAtLength(normalPath, afterLength);\n    afterDistance = distanceTo(after);\n\n    if (beforeLength >= 0 && beforeDistance < bestDistance) {\n      closest = before;\n      bestLength = beforeLength;\n      bestDistance = beforeDistance;\n    } else if (afterLength <= pathLength && afterDistance < bestDistance) {\n      closest = after;\n      bestLength = afterLength;\n      bestDistance = afterDistance;\n    } else {\n      precision /= 2;\n    }\n    if (precision < 0.00001) break;\n  }\n\n  const segment = getPropertiesAtLength(path, bestLength);\n  const distance = Math.sqrt(bestDistance);\n\n  return { closest, distance, segment };\n};\n\nexport default getPropertiesAtPoint;\n","import type { PathArray } from \"../types\";\nimport getPropertiesAtPoint from \"./getPropertiesAtPoint\";\n\n/**\n * Returns the point in path closest to a given point.\n *\n * @param pathInput target `pathArray`\n * @param point the given point\n * @returns the best match\n */\nconst getClosestPoint = (\n  pathInput: string | PathArray,\n  point: { x: number; y: number },\n) => {\n  return getPropertiesAtPoint(pathInput, point).closest;\n};\n\nexport default getClosestPoint;\n","import pathToCurve from \"../convert/pathToCurve\";\nimport type { PathArray, PointTuple } from \"../types\";\n\n/**\n * Returns the area of a single cubic-bezier segment.\n *\n * http://objectmix.com/graphics/133553-area-closed-bezier-curve.html\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param c1x the first control point X\n * @param c1y the first control point Y\n * @param c2x the second control point X\n * @param c2y the second control point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @returns the area of the cubic-bezier segment\n */\nconst getCubicSegArea = (\n  x1: number,\n  y1: number,\n  c1x: number,\n  c1y: number,\n  c2x: number,\n  c2y: number,\n  x2: number,\n  y2: number,\n) => {\n  return (\n    (3 *\n      ((y2 - y1) * (c1x + c2x) -\n        (x2 - x1) * (c1y + c2y) +\n        c1y * (x1 - c2x) -\n        c1x * (y1 - c2y) +\n        y2 * (c2x + x1 / 3) -\n        x2 * (c2y + y1 / 3))) /\n    20\n  );\n};\n\n/**\n * Returns the area of a shape.\n *\n * @author Jürg Lehni & Jonathan Puckey\n *\n * @see https://github.com/paperjs/paper.js/blob/develop/src/path/Path.js\n *\n * @param path the shape `pathArray`\n * @returns the length of the cubic-bezier segment\n */\nconst getPathArea = (path: PathArray) => {\n  let x = 0;\n  let y = 0;\n  let len = 0;\n\n  return pathToCurve(path)\n    .map((seg) => {\n      switch (seg[0]) {\n        case \"M\":\n          [, x, y] = seg;\n          return 0;\n        default:\n          len = getCubicSegArea(\n            x,\n            y,\n            seg[1],\n            seg[2],\n            seg[3],\n            seg[4],\n            seg[5],\n            seg[6],\n          );\n          [x, y] = seg.slice(-2) as PointTuple;\n          return len;\n      }\n    })\n    .reduce((a, b) => a + b, 0);\n};\nexport default getPathArea;\n","import getPathArea from \"./getPathArea\";\nimport pathToCurve from \"../convert/pathToCurve\";\nimport type { PathArray } from \"../types\";\n\n/**\n * Check if a path is drawn clockwise and returns true if so,\n * false otherwise.\n *\n * @param path the path string or `pathArray`\n * @returns true when clockwise or false if not\n */\nconst getDrawDirection = (path: string | PathArray) => {\n  return getPathArea(pathToCurve(path)) >= 0;\n};\n\nexport default getDrawDirection;\n","import iterate from \"../process/iterate\";\nimport { PathBBox } from \"../interface\";\nimport { LSegment, MSegment, PathArray, PointTuple } from \"../types\";\nimport { getLineBBox } from \"../math/lineTools\";\nimport { getArcBBox } from \"../math/arcTools\";\nimport { getCubicBBox } from \"../math/cubicTools\";\nimport { getQuadBBox } from \"../math/quadTools\";\nimport parsePathString from \"../parser/parsePathString\";\nimport absolutizeSegment from \"../process/absolutizeSegment\";\n\nconst getPathBBox = (pathInput: PathArray | string) => {\n  if (!pathInput) {\n    return {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0,\n      x2: 0,\n      y2: 0,\n      cx: 0,\n      cy: 0,\n      cz: 0,\n    };\n  }\n\n  const path = parsePathString(pathInput);\n  let pathCommand = \"M\";\n  let mx = 0;\n  let my = 0;\n  const { max, min } = Math;\n  let xMin = Infinity;\n  let yMin = Infinity;\n  let xMax = -Infinity;\n  let yMax = -Infinity;\n  let minX = 0;\n  let minY = 0;\n  let maxX = 0;\n  let maxY = 0;\n  let paramX1 = 0;\n  let paramY1 = 0;\n  let paramX2 = 0;\n  let paramY2 = 0;\n  let paramQX = 0;\n  let paramQY = 0;\n\n  iterate(path, (seg, index, lastX, lastY) => {\n    [pathCommand] = seg;\n    const absCommand = pathCommand.toUpperCase();\n    const isRelative = absCommand !== pathCommand;\n    const absoluteSegment = isRelative\n      ? absolutizeSegment(seg, index, lastX, lastY)\n      : (seg.slice(0) as typeof seg);\n\n    const normalSegment = absCommand === \"V\"\n      ? ([\"L\", lastX, absoluteSegment[1]] as LSegment)\n      : absCommand === \"H\"\n      ? ([\"L\", absoluteSegment[1], lastY] as LSegment)\n      : absoluteSegment;\n\n    [pathCommand] = normalSegment;\n\n    if (!\"TQ\".includes(absCommand)) {\n      // optional but good to be cautious\n      paramQX = 0;\n      paramQY = 0;\n    }\n\n    // this segment is always ZERO\n    /* istanbul ignore else @preserve */\n    if (pathCommand === \"M\") {\n      [, mx, my] = normalSegment as MSegment;\n      minX = mx;\n      minY = my;\n      maxX = mx;\n      maxY = my;\n    } else if (pathCommand === \"L\") {\n      [minX, minY, maxX, maxY] = getLineBBox(\n        lastX,\n        lastY,\n        normalSegment[1] as number,\n        normalSegment[2] as number,\n      );\n    } else if (pathCommand === \"A\") {\n      [minX, minY, maxX, maxY] = getArcBBox(\n        lastX,\n        lastY,\n        normalSegment[1] as number,\n        normalSegment[2] as number,\n        normalSegment[3] as number,\n        normalSegment[4] as number,\n        normalSegment[5] as number,\n        normalSegment[6] as number,\n        normalSegment[7] as number,\n      );\n    } else if (pathCommand === \"S\") {\n      const cp1x = paramX1 * 2 - paramX2;\n      const cp1y = paramY1 * 2 - paramY2;\n\n      [minX, minY, maxX, maxY] = getCubicBBox(\n        lastX,\n        lastY,\n        cp1x,\n        cp1y,\n        normalSegment[1] as number,\n        normalSegment[2] as number,\n        normalSegment[3] as number,\n        normalSegment[4] as number,\n      );\n    } else if (pathCommand === \"C\") {\n      [minX, minY, maxX, maxY] = getCubicBBox(\n        lastX,\n        lastY,\n        normalSegment[1] as number,\n        normalSegment[2] as number,\n        normalSegment[3] as number,\n        normalSegment[4] as number,\n        normalSegment[5] as number,\n        normalSegment[6] as number,\n      );\n    } else if (pathCommand === \"T\") {\n      paramQX = paramX1 * 2 - paramQX;\n      paramQY = paramY1 * 2 - paramQY;\n      [minX, minY, maxX, maxY] = getQuadBBox(\n        lastX,\n        lastY,\n        paramQX,\n        paramQY,\n        normalSegment[1] as number,\n        normalSegment[2] as number,\n      );\n    } else if (pathCommand === \"Q\") {\n      paramQX = normalSegment[1] as number;\n      paramQY = normalSegment[2] as number;\n      [minX, minY, maxX, maxY] = getQuadBBox(\n        lastX,\n        lastY,\n        normalSegment[1] as number,\n        normalSegment[2] as number,\n        normalSegment[3] as number,\n        normalSegment[4] as number,\n      );\n    } else if (pathCommand === \"Z\") {\n      [minX, minY, maxX, maxY] = getLineBBox(lastX, lastY, mx, my);\n    }\n    xMin = min(minX, xMin);\n    yMin = min(minY, yMin);\n    xMax = max(maxX, xMax);\n    yMax = max(maxY, yMax);\n\n    // update params\n    [paramX1, paramY1] = pathCommand === \"Z\"\n      ? [mx, my]\n      : (normalSegment.slice(-2) as PointTuple);\n    [paramX2, paramY2] = pathCommand === \"C\"\n      ? ([normalSegment[3], normalSegment[4]] as PointTuple)\n      : pathCommand === \"S\"\n      ? ([normalSegment[1], normalSegment[2]] as PointTuple)\n      : [paramX1, paramY1];\n  });\n\n  const width = xMax - xMin;\n  const height = yMax - yMin;\n\n  return {\n    width,\n    height,\n    x: xMin,\n    y: yMin,\n    x2: xMax,\n    y2: yMax,\n    cx: xMin + width / 2,\n    cy: yMin + height / 2,\n    // an estimated guess\n    cz: Math.max(width, height) + Math.min(width, height) / 2,\n  } satisfies PathBBox;\n};\n\nexport default getPathBBox;\n","import type { PathArray, PathSegment } from \"../types\";\nimport getPropertiesAtLength from \"./getPropertiesAtLength\";\n\n/**\n * Returns the segment at a given length.\n *\n * @param pathInput the target `pathArray`\n * @param distance the distance in path to look at\n * @returns the requested segment\n */\nconst getSegmentAtLength = (\n  pathInput: string | PathArray,\n  distance?: number,\n): PathSegment | undefined => {\n  return getPropertiesAtLength(pathInput, distance).segment;\n};\n\nexport default getSegmentAtLength;\n","import type { SegmentProperties } from \"../interface\";\nimport type { PathArray } from \"../types\";\nimport getPropertiesAtPoint from \"./getPropertiesAtPoint\";\n\n/**\n * Returns the path segment which contains a given point.\n *\n * @param path the `pathArray` to look into\n * @param point the point of the shape to look for\n * @returns the requested segment\n */\nconst getSegmentOfPoint = (\n  path: string | PathArray,\n  point: { x: number; y: number },\n): SegmentProperties | undefined => {\n  return getPropertiesAtPoint(path, point).segment;\n};\nexport default getSegmentOfPoint;\n","import type { PathArray, PathSegment, RelativeCommand } from \"../types\";\nimport paramsCount from \"../parser/paramsCount\";\n\n/**\n * Iterates an array to check if it's an actual `pathArray`.\n *\n * @param path the `pathArray` to be checked\n * @returns iteration result\n */\nconst isPathArray = (path: unknown): path is PathArray => {\n  return (\n    Array.isArray(path) &&\n    path.every((seg: PathSegment) => {\n      const lk = seg[0].toLowerCase() as RelativeCommand;\n      return (\n        paramsCount[lk] === seg.length - 1 &&\n        \"achlmqstvz\".includes(lk) &&\n        (seg.slice(1) as unknown[]).every(Number.isFinite)\n      );\n    }) &&\n    path.length > 0\n  );\n};\nexport default isPathArray;\n","import type { AbsoluteArray } from \"../types\";\nimport isPathArray from \"./isPathArray\";\n\n/**\n * Iterates an array to check if it's a `pathArray`\n * with all absolute values.\n *\n * @param path the `pathArray` to be checked\n * @returns iteration result\n */\nconst isAbsoluteArray = (path: unknown): path is AbsoluteArray => {\n  return (\n    isPathArray(path) &&\n    // `isPathArray` also checks if it's `Array`\n    path.every(([x]) => x === x.toUpperCase())\n  );\n};\nexport default isAbsoluteArray;\n","import type { NormalArray } from \"../types\";\nimport isAbsoluteArray from \"./isAbsoluteArray\";\n\n/**\n * Iterates an array to check if it's a `pathArray`\n * with all segments are in non-shorthand notation\n * with absolute values.\n *\n * @param {string | SVGPath.pathArray} path the `pathArray` to be checked\n * @returns {boolean} iteration result\n */\nconst isNormalizedArray = (path: unknown): path is NormalArray => {\n  // `isAbsoluteArray` also checks if it's `Array`\n  return isAbsoluteArray(path) && path.every(([pc]) => \"ACLMQZ\".includes(pc));\n};\nexport default isNormalizedArray;\n","import { CurveArray } from \"../types\";\nimport isNormalizedArray from \"./isNormalizedArray\";\n\n/**\n * Iterates an array to check if it's a `pathArray`\n * with all C (cubic bezier) segments.\n *\n * @param path the `Array` to be checked\n * @returns iteration result\n */\nconst isCurveArray = (path: unknown): path is CurveArray => {\n  // `isPathArray` also checks if it's `Array`\n  return isNormalizedArray(path) && path.every(([pc]) => \"MC\".includes(pc));\n};\nexport default isCurveArray;\n","import type { PathArray } from \"../types\";\nimport getPropertiesAtPoint from \"./getPropertiesAtPoint\";\nimport DISTANCE_EPSILON from \"./distanceEpsilon\";\n\n/**\n * Checks if a given point is in the stroke of a path.\n *\n * @param pathInput target path\n * @param point the given `{x,y}` point\n * @returns the query result\n */\nconst isPointInStroke = (\n  pathInput: string | PathArray,\n  point: { x: number; y: number },\n) => {\n  const { distance } = getPropertiesAtPoint(pathInput, point);\n  return Math.abs(distance) < DISTANCE_EPSILON; // 0.01 might be more permissive\n};\nexport default isPointInStroke;\n","import type { RelativeArray } from \"../types\";\nimport isPathArray from \"./isPathArray\";\n\n/**\n * Iterates an array to check if it's a `pathArray`\n * with relative values.\n *\n * @param path the `pathArray` to be checked\n * @returns iteration result\n */\nconst isRelativeArray = (path: unknown): path is RelativeArray => {\n  return (\n    isPathArray(path) &&\n    // `isPathArray` checks if it's `Array`\n    path.slice(1).every(([pc]) => pc === pc.toLowerCase())\n  );\n};\nexport default isRelativeArray;\n","import scanSegment from \"../parser/scanSegment\";\nimport skipSpaces from \"../parser/skipSpaces\";\nimport PathParser from \"../parser/pathParser\";\n\n/**\n * Parses a path string value to determine its validity\n * then returns true if it's valid or false otherwise.\n *\n * @param pathString the path string to be parsed\n * @returns the path string validity\n */\nconst isValidPath = (pathString: string) => {\n  if (typeof pathString !== \"string\" || !pathString.length) {\n    return false;\n  }\n\n  const path = new PathParser(pathString);\n\n  skipSpaces(path);\n\n  while (path.index < path.max && !path.err.length) {\n    scanSegment(path);\n  }\n\n  return !path.err.length && \"mM\".includes(path.segments[0][0]);\n};\nexport default isValidPath;\n","import type { ShapeParams } from \"../interface\";\n\n/**\n * Supported shapes and their specific parameters.\n */\nconst shapeParams: ShapeParams = {\n  line: [\"x1\", \"y1\", \"x2\", \"y2\"],\n  circle: [\"cx\", \"cy\", \"r\"],\n  ellipse: [\"cx\", \"cy\", \"rx\", \"ry\"],\n  rect: [\"width\", \"height\", \"x\", \"y\", \"rx\", \"ry\"],\n  polygon: [\"points\"],\n  polyline: [\"points\"],\n  glyph: [\"d\"],\n};\n\nexport default shapeParams;\n","const isElement = (node?: unknown): node is Element =>\n  node !== undefined && node !== null &&\n  typeof node === \"object\" &&\n  (node as Node).nodeType === 1; // ELEMENT_NODE\n\nexport default isElement;\n","import type {\n  CircleAttr,\n  EllipseAttr,\n  GlyphAttr,\n  LineAttr,\n  PolyAttr,\n  RectAttr,\n  ShapeParams,\n} from \"../interface\";\nimport type { PathArray, PathSegment, ShapeOps, ShapeTypes } from \"../types\";\nimport error from \"../parser/error\";\nimport parsePathString from \"../parser/parsePathString\";\nimport shapeParams from \"./shapeParams\";\nimport isPathArray from \"./isPathArray\";\nimport isElement from \"./isElement\";\n\n/**\n * Returns a new `pathArray` from line attributes.\n *\n * @param attr shape configuration\n * @returns a new line `pathArray`\n */\nexport const getLinePath = (attr: LineAttr): PathArray => {\n  let { x1, y1, x2, y2 } = attr;\n  [x1, y1, x2, y2] = [x1, y1, x2, y2].map((a) => +a);\n  return [\n    [\"M\", x1, y1],\n    [\"L\", x2, y2],\n  ];\n};\n\n/**\n * Returns a new `pathArray` like from polyline/polygon attributes.\n *\n * @param attr shape configuration\n * @return a new polygon/polyline `pathArray`\n */\nexport const getPolyPath = (attr: PolyAttr): PathArray => {\n  const pathArray = [] as PathSegment[];\n  const points = (attr.points || \"\")\n    .trim()\n    .split(/[\\s|,]/)\n    .map((a) => +a);\n\n  let index = 0;\n  while (index < points.length) {\n    pathArray.push([index ? \"L\" : \"M\", points[index], points[index + 1]]);\n    index += 2;\n  }\n\n  return (attr.type === \"polygon\"\n    ? [...pathArray, [\"z\"]]\n    : pathArray) as PathArray;\n};\n\n/**\n * Returns a new `pathArray` from circle attributes.\n *\n * @param attr shape configuration\n * @return a circle `pathArray`\n */\nexport const getCirclePath = (attr: CircleAttr): PathArray => {\n  let { cx, cy, r } = attr;\n  [cx, cy, r] = [cx, cy, r].map((a) => +a);\n\n  return [\n    [\"M\", cx - r, cy],\n    [\"a\", r, r, 0, 1, 0, 2 * r, 0],\n    [\"a\", r, r, 0, 1, 0, -2 * r, 0],\n  ];\n};\n\n/**\n * Returns a new `pathArray` from ellipse attributes.\n *\n * @param attr shape configuration\n * @return an ellipse `pathArray`\n */\nexport const getEllipsePath = (attr: EllipseAttr): PathArray => {\n  let { cx, cy } = attr;\n  let rx = attr.rx || 0;\n  let ry = attr.ry || rx;\n  [cx, cy, rx, ry] = [cx, cy, rx, ry].map((a) => +a);\n\n  return [\n    [\"M\", cx - rx, cy],\n    [\"a\", rx, ry, 0, 1, 0, 2 * rx, 0],\n    [\"a\", rx, ry, 0, 1, 0, -2 * rx, 0],\n  ];\n};\n\n/**\n * Returns a new `pathArray` like from rect attributes.\n *\n * @param attr object with properties above\n * @return a new `pathArray` from `<rect>` attributes\n */\nexport const getRectanglePath = (attr: RectAttr): PathArray => {\n  const x = +attr.x || 0;\n  const y = +attr.y || 0;\n  const w = +attr.width;\n  const h = +attr.height;\n  let rx = +(attr.rx || 0);\n  let ry = +(attr.ry || rx);\n\n  // Validity checks from http://www.w3.org/TR/SVG/shapes.html#RectElement:\n  if (rx || ry) {\n    // rx = !rx ? ry : rx;\n    // ry = !ry ? rx : ry;\n\n    /* istanbul ignore else @preserve */\n    if (rx * 2 > w) rx -= (rx * 2 - w) / 2;\n    /* istanbul ignore else @preserve */\n    if (ry * 2 > h) ry -= (ry * 2 - h) / 2;\n\n    return [\n      [\"M\", x + rx, y],\n      [\"h\", w - rx * 2],\n      [\"s\", rx, 0, rx, ry],\n      [\"v\", h - ry * 2],\n      [\"s\", 0, ry, -rx, ry],\n      [\"h\", -w + rx * 2],\n      [\"s\", -rx, 0, -rx, -ry],\n      [\"v\", -h + ry * 2],\n      [\"s\", 0, -ry, rx, -ry],\n    ];\n  }\n\n  return [[\"M\", x, y], [\"h\", w], [\"v\", h], [\"H\", x], [\"Z\"]];\n};\n\n/**\n * Returns a new `pathArray` created from attributes of a `<line>`, `<polyline>`,\n * `<polygon>`, `<rect>`, `<ellipse>`, `<circle>`, <path> or `<glyph>`.\n *\n * It can also work with an options object, see the type below\n * @see ShapeOps\n *\n * @param element target shape\n * @return the newly created `<path>` element\n */\nconst shapeToPathArray = (\n  element: ShapeTypes | ShapeOps,\n) => {\n  const supportedShapes = Object.keys(shapeParams) as (keyof ShapeParams)[];\n  const targetIsElement = isElement(element);\n  const tagName = targetIsElement ? element.tagName : null;\n\n  if (tagName && [...supportedShapes, \"path\"].every((s) => tagName !== s)) {\n    throw TypeError(`${error}: \"${tagName}\" is not SVGElement`);\n  }\n\n  const type =\n    (targetIsElement ? tagName : (element as ShapeOps).type) as ShapeOps[\n      \"type\"\n    ];\n  const shapeAttrs = shapeParams[type] as string[];\n  const config = { type } as Record<string, string>;\n\n  if (targetIsElement) {\n    shapeAttrs.forEach((p) => {\n      config[p] = element.getAttribute(p) as string;\n    });\n  } else {\n    Object.assign(config, element);\n  }\n\n  // set d\n  let pathArray = [] as unknown as PathArray;\n\n  /* istanbul ignore else */\n  if (type === \"circle\") {\n    pathArray = getCirclePath(config as unknown as CircleAttr);\n  } else if (type === \"ellipse\") {\n    pathArray = getEllipsePath(config as unknown as EllipseAttr);\n  } else if ([\"polyline\", \"polygon\"].includes(type)) {\n    pathArray = getPolyPath(config as unknown as PolyAttr);\n  } else if (type === \"rect\") {\n    pathArray = getRectanglePath(config as unknown as RectAttr);\n  } else if (type === \"line\") {\n    pathArray = getLinePath(config as unknown as LineAttr);\n  } else if ([\"glyph\", \"path\"].includes(type)) {\n    pathArray = parsePathString(\n      targetIsElement\n        ? element.getAttribute(\"d\") || /* istanbul ignore next @preserve */ \"\"\n        : (element as GlyphAttr).d || \"\",\n    );\n  }\n\n  // replace target element\n  if (isPathArray(pathArray) && pathArray.length) {\n    return pathArray;\n  }\n  return false;\n};\nexport default shapeToPathArray;\n","import type { ShapeParams } from \"../interface\";\nimport type { ShapeOps, ShapeTypes } from \"../types\";\nimport pathToString from \"../convert/pathToString\";\nimport defaultOptions from \"../options/options\";\nimport error from \"../parser/error\";\nimport isValidPath from \"./isValidPath\";\nimport isElement from \"./isElement\";\nimport shapeToPathArray from \"./shapeToPathArray\";\nimport shapeParams from \"./shapeParams\";\n\n/**\n * Returns a new `<path>` element created from attributes of a `<line>`, `<polyline>`,\n * `<polygon>`, `<rect>`, `<ellipse>`, `<circle>` or `<glyph>`. If `replace` parameter\n * is `true`, it will replace the target. The default `ownerDocument` is your current\n * `document` browser page, if you want to use in server-side using `jsdom`, you can\n * pass the `jsdom` `document` to `ownDocument`.\n *\n * It can also work with an options object, see the type below\n * @see ShapeOps\n *\n * The newly created `<path>` element keeps all non-specific\n * attributes like `class`, `fill`, etc.\n *\n * @param element target shape\n * @param replace option to replace target\n * @param ownerDocument document for create element\n * @return the newly created `<path>` element\n */\nconst shapeToPath = (\n  element: ShapeTypes | ShapeOps,\n  replace?: boolean,\n  ownerDocument?: Document,\n): SVGPathElement | false => {\n  const doc = ownerDocument || document;\n  const supportedShapes = Object.keys(shapeParams) as (keyof ShapeParams)[];\n  const targetIsElement = isElement(element);\n  const tagName = targetIsElement ? element.tagName : null;\n\n  if (tagName === \"path\") {\n    throw TypeError(`${error}: \"${tagName}\" is already SVGPathElement`);\n  }\n  if (tagName && supportedShapes.every((s) => tagName !== s)) {\n    throw TypeError(`${error}: \"${tagName}\" is not SVGElement`);\n  }\n\n  const path = doc.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n  const type =\n    (targetIsElement ? tagName : (element as ShapeOps).type) as ShapeOps[\n      \"type\"\n    ];\n  const shapeAttrs = shapeParams[type] as string[];\n  const config = { type } as Record<string, string>;\n\n  // set d\n  const round = defaultOptions.round as number;\n  const pathArray = shapeToPathArray(element);\n  const description = pathArray && pathArray.length\n    ? pathToString(pathArray, round)\n    : \"\";\n\n  if (targetIsElement) {\n    shapeAttrs.forEach((p) => {\n      config[p] = element.getAttribute(p) as string;\n    });\n    // set no-specific shape attributes: fill, stroke, etc\n    Object.values(element.attributes).forEach(({ name, value }) => {\n      if (!shapeAttrs.includes(name)) path.setAttribute(name, value);\n    });\n  } else {\n    Object.assign(config, element);\n    // set no-specific shape attributes: fill, stroke, etc\n    Object.keys(config).forEach((k) => {\n      if (!shapeAttrs.includes(k) && k !== \"type\") {\n        path.setAttribute(\n          k.replace(/[A-Z]/g, (m) => `-${m.toLowerCase()}`),\n          config[k],\n        );\n      }\n    });\n  }\n\n  // replace target element\n  if (isValidPath(description)) {\n    path.setAttribute(\"d\", description);\n    if (replace && targetIsElement) {\n      element.before(path, element);\n      element.remove();\n    }\n    return path;\n  }\n  return false;\n};\n\nexport default shapeToPath;\n","import CSSMatrix from \"@thednp/dommatrix\";\n// import type { TransformObject } from '../interface';\nimport type { TransformObjectValues } from \"../types\";\n\n/**\n * Returns a transformation matrix to apply to `<path>` elements.\n *\n * @see TransformObjectValues\n *\n * @param transform the `transformObject`\n * @returns a new transformation matrix\n */\nconst getSVGMatrix = (transform: TransformObjectValues): CSSMatrix => {\n  let matrix = new CSSMatrix();\n  const { origin } = transform;\n  const [originX, originY] = origin as [number, number, number];\n  const { translate } = transform;\n  const { rotate } = transform;\n  const { skew } = transform;\n  const { scale } = transform;\n\n  // set translate\n  if (\n    Array.isArray(translate) &&\n    translate.length >= 2 &&\n    translate.every((x) => !Number.isNaN(+x)) &&\n    translate.some((x) => x !== 0)\n  ) {\n    matrix = matrix.translate(...(translate as [number, number, number?]));\n  } else if (typeof translate === \"number\" && !Number.isNaN(translate)) {\n    matrix = matrix.translate(translate);\n  }\n\n  if (rotate || skew || scale) {\n    // set SVG transform-origin, always defined\n    matrix = matrix.translate(originX, originY);\n\n    // set rotation\n    if (\n      Array.isArray(rotate) &&\n      rotate.length >= 2 &&\n      rotate.every((x) => !Number.isNaN(+x)) &&\n      rotate.some((x) => x !== 0)\n    ) {\n      matrix = matrix.rotate(...(rotate as [number, number, number?]));\n    } else if (typeof rotate === \"number\" && !Number.isNaN(rotate)) {\n      matrix = matrix.rotate(rotate);\n    }\n\n    // set skew(s)\n    if (\n      Array.isArray(skew) && skew.length === 2 && skew.every((x) =>\n        !Number.isNaN(+x)\n      ) && skew.some((x) => x !== 0)\n    ) {\n      matrix = skew[0] ? matrix.skewX(skew[0]) : matrix;\n      matrix = skew[1] ? matrix.skewY(skew[1]) : matrix;\n    } else if (typeof skew === \"number\" && !Number.isNaN(skew)) {\n      matrix = matrix.skewX(skew);\n    }\n\n    // set scale\n    if (\n      Array.isArray(scale) && scale.length >= 2 && scale.every((x) =>\n        !Number.isNaN(+x)\n      ) && scale.some((x) => x !== 1)\n    ) {\n      matrix = matrix.scale(...(scale as [number, number, number?]));\n    } else if (typeof scale === \"number\" && !Number.isNaN(scale)) {\n      matrix = matrix.scale(scale);\n    }\n    // set SVG transform-origin\n    matrix = matrix.translate(-originX, -originY);\n  }\n\n  return matrix;\n};\nexport default getSVGMatrix;\n","import defaultOptions from \"../options/options\";\nimport type { ParserParams } from \"../interface\";\nimport roundTo from \"../math/roundTo\";\nimport type {\n  AbsoluteSegment,\n  NormalSegment,\n  PathCommand,\n  ShortSegment,\n  SSegment,\n  TSegment,\n} from \"../types\";\n\n/**\n * Shorten a single segment of a `pathArray` object.\n *\n * @param segment the `absoluteSegment` object\n * @param normalSegment the `normalSegment` object\n * @param params the coordinates of the previous segment\n * @param prevCommand the path command of the previous segment\n * @returns the shortened segment\n */\nconst shortenSegment = (\n  segment: AbsoluteSegment,\n  normalSegment: NormalSegment,\n  params: ParserParams,\n  prevCommand: PathCommand,\n): ShortSegment => {\n  const [pathCommand] = segment;\n  const { round: defaultRound } = defaultOptions;\n  const round = typeof defaultRound === \"number\"\n    ? defaultRound\n    : /* istanbul ignore next */ 4;\n  const normalValues = normalSegment.slice(1) as number[];\n  const { x1, y1, x2, y2, x, y } = params;\n  const [nx, ny] = normalValues.slice(-2);\n  const result = segment;\n\n  if (!\"TQ\".includes(pathCommand)) {\n    // optional but good to be cautious\n    params.qx = null;\n    params.qy = null;\n  }\n\n  if (pathCommand === \"L\") {\n    if (roundTo(x, round) === roundTo(nx, round)) {\n      return [\"V\", ny];\n    } else if (roundTo(y, round) === roundTo(ny, round)) {\n      return [\"H\", nx];\n    }\n  } else if (pathCommand === \"C\") {\n    const [nx1, ny1] = normalValues;\n    params.x1 = nx1;\n    params.y1 = ny1;\n\n    if (\n      \"CS\".includes(prevCommand) &&\n      ((roundTo(nx1, round) === roundTo(x1 * 2 - x2, round) &&\n        roundTo(ny1, round) === roundTo(y1 * 2 - y2, round)) ||\n        (roundTo(x1, round) === roundTo(x2 * 2 - x, round) &&\n          roundTo(y1, round) === roundTo(y2 * 2 - y, round)))\n    ) {\n      return [\n        \"S\",\n        normalValues[2],\n        normalValues[3],\n        normalValues[4],\n        normalValues[5],\n      ] as SSegment;\n    }\n  } else if (pathCommand === \"Q\") {\n    const [qx, qy] = normalValues;\n    params.qx = qx;\n    params.qy = qy;\n\n    if (\n      \"QT\".includes(prevCommand) &&\n      roundTo(qx, round) === roundTo(x1 * 2 - x2, round) &&\n      roundTo(qy, round) === roundTo(y1 * 2 - y2, round)\n    ) {\n      return [\"T\", normalValues[2], normalValues[3]] as TSegment;\n    }\n  }\n\n  // ['V', 'H', 'S', 'T', 'Z'].includes(pathCommand)\n  return result as ShortSegment;\n};\n\nexport default shortenSegment;\n","import type { PathCommand, PathSegment } from \"../types\";\nimport roundTo from \"../math/roundTo\";\n\nconst roundSegment = <T extends PathSegment>(\n  segment: T,\n  roundOption: number,\n) => {\n  const values = (segment.slice(1) as number[]).map((n) =>\n    roundTo(n, roundOption)\n  );\n  return [segment[0] as PathCommand | number].concat(values) as T;\n};\n\nexport default roundSegment;\n","import type { AbsoluteSegment, PathArray, PathCommand } from \"../types\";\nimport pathToAbsolute from \"../convert/pathToAbsolute\";\nimport shortenSegment from \"./shortenSegment\";\nimport paramsParser from \"../parser/paramsParser\";\nimport iterate from \"./iterate\";\nimport normalizeSegment from \"./normalizeSegment\";\nimport relativizeSegment from \"./relativizeSegment\";\nimport roundSegment from \"./roundSegment\";\n\n/**\n * Optimizes a `pathArray` object:\n * * convert segments to shorthand if possible\n * * select shortest segments from absolute and relative `pathArray`s\n *\n * @param pathInput a string or `pathArray`\n * @param roundOption the amount of decimals to round values to\n * @returns the optimized `pathArray`\n */\nconst optimizePath = (pathInput: PathArray, roundOption?: number) => {\n  const path = pathToAbsolute(pathInput);\n  // allow for ZERO decimals or use an aggressive value of 2\n  const round = typeof roundOption === \"number\" && roundOption >= 0\n    ? roundOption\n    : /* istanbul ignore next @preserve */ 2;\n  // this utility overrides the iterator params\n  const optimParams = { ...paramsParser };\n\n  const allPathCommands = [] as PathCommand[];\n  let pathCommand = \"M\" as PathCommand;\n  let prevCommand = \"Z\" as PathCommand;\n\n  return iterate(path, (seg, i, lastX, lastY) => {\n    optimParams.x = lastX;\n    optimParams.y = lastY;\n    const normalizedSegment = normalizeSegment(seg, optimParams);\n    let result = seg;\n    [pathCommand] = seg;\n\n    // Save current path command\n    allPathCommands[i] = pathCommand;\n    if (i) {\n      // Get previous path command for `shortenSegment`\n      prevCommand = allPathCommands[i - 1];\n      const shortSegment = shortenSegment(\n        seg as AbsoluteSegment,\n        normalizedSegment,\n        optimParams,\n        prevCommand,\n      );\n      const absSegment = roundSegment(shortSegment, round);\n      const absString = absSegment.join(\"\");\n      const relativeSegment = relativizeSegment(shortSegment, i, lastX, lastY);\n      const relSegment = roundSegment(relativeSegment, round);\n      const relString = relSegment.join(\"\");\n      result = absString.length < relString.length ? absSegment : relSegment;\n    }\n\n    const seglen = normalizedSegment.length;\n    optimParams.x1 = +normalizedSegment[seglen - 2];\n    optimParams.y1 = +normalizedSegment[seglen - 1];\n    optimParams.x2 = +normalizedSegment[seglen - 4] || optimParams.x1;\n    optimParams.y2 = +normalizedSegment[seglen - 3] || optimParams.y1;\n\n    return result;\n  });\n};\n\nexport default optimizePath;\n","import CSSMatrix from \"@thednp/dommatrix\";\nimport { type PointTuple } from \"../types\";\n\n/**\n * Transforms a specified point using a matrix, returning a new\n * Tuple *Object* comprising of the transformed point.\n * Neither the matrix nor the original point are altered.\n *\n * @copyright thednp © 2021\n *\n * @param cssm CSSMatrix instance\n * @param v Tuple\n * @return the resulting Tuple\n */\nconst translatePoint = (\n  cssm: CSSMatrix,\n  v: [number, number, number, number],\n): [number, number, number, number] => {\n  let m = CSSMatrix.Translate(v[0], v[1], v[2]);\n\n  [, , , m.m44] = v;\n  m = cssm.multiply(m);\n\n  return [m.m41, m.m42, m.m43, m.m44];\n};\n\n/**\n * Returns the [x,y] projected coordinates for a given an [x,y] point\n * and an [x,y,z] perspective origin point.\n *\n * Equation found here =>\n * http://en.wikipedia.org/wiki/3D_projection#Diagram\n * Details =>\n * https://stackoverflow.com/questions/23792505/predicted-rendering-of-css-3d-transformed-pixel\n *\n * @param m the transformation matrix\n * @param point2D the initial [x,y] coordinates\n * @param origin the [x,y,z] transform origin\n * @returns the projected [x,y] coordinates\n */\nconst projection2d = (\n  m: CSSMatrix,\n  point2D: PointTuple,\n  origin: [number, number, number],\n): PointTuple => {\n  const [originX, originY, originZ] = origin;\n  const [x, y, z] = translatePoint(m, [point2D[0], point2D[1], 0, 1]);\n\n  const relativePositionX = x - originX;\n  const relativePositionY = y - originY;\n  const relativePositionZ = z - originZ;\n\n  return [\n    // protect against division by ZERO\n    relativePositionX * (Math.abs(originZ) / Math.abs(relativePositionZ) || 1) +\n    originX,\n    relativePositionY * (Math.abs(originZ) / Math.abs(relativePositionZ) || 1) +\n    originY,\n  ];\n};\nexport default projection2d;\n","import type { CSegment, CurveArray, MSegment, PathCommand } from \"../types\";\n\n/**\n * Reverses all segments of a `pathArray`\n * which consists of only C (cubic-bezier) path commands.\n *\n * @param path the source `pathArray`\n * @returns the reversed `pathArray`\n */\nconst reverseCurve = (path: CurveArray) => {\n  const rotatedCurve = path\n    .slice(1)\n    .map((x, i, curveOnly) =>\n      !i\n        ? path[0].slice(1).concat(x.slice(1) as number[])\n        : curveOnly[i - 1].slice(-2).concat(x.slice(1))\n    )\n    .map((x) => x.map((_, i) => x[x.length - i - 2 * (1 - (i % 2))]))\n    .reverse() as (MSegment | CSegment)[];\n\n  return [[\"M\" as PathCommand | number].concat(rotatedCurve[0].slice(0, 2))]\n    .concat(\n      rotatedCurve.map((x) => [\"C\" as PathCommand | number].concat(x.slice(2))),\n    ) as CurveArray;\n};\n\nexport default reverseCurve;\n","import type {\n  ASegment,\n  CSegment,\n  HSegment,\n  MSegment,\n  PathArray,\n  PathSegment,\n  PointTuple,\n  QSegment,\n  SSegment,\n  TSegment,\n  VSegment,\n} from \"../types\";\nimport pathToAbsolute from \"../convert/pathToAbsolute\";\nimport normalizePath from \"./normalizePath\";\nimport iterate from \"./iterate\";\n\n/**\n * Reverses all segments of a `pathArray` and returns a new `pathArray` instance\n * with absolute values.\n *\n * @param pathInput the source `pathArray`\n * @returns the reversed `pathArray`\n */\nconst reversePath = (pathInput: PathArray) => {\n  const absolutePath = pathToAbsolute(pathInput);\n  const normalizedPath = normalizePath(absolutePath);\n  const pLen = absolutePath.length;\n  const isClosed = absolutePath[pLen - 1][0] === \"Z\";\n\n  const reversedPath = iterate(absolutePath, (segment, i) => {\n    const normalizedSegment = normalizedPath[i];\n    const prevSeg = i && absolutePath[i - 1];\n    const prevCommand = prevSeg && prevSeg[0];\n    const nextSeg = absolutePath[i + 1];\n    const nextCommand = nextSeg && nextSeg[0];\n    const [pathCommand] = segment;\n    const [x, y] = normalizedPath[i ? i - 1 : pLen - 1].slice(-2) as PointTuple;\n    let result = segment;\n\n    switch (pathCommand) {\n      case \"M\":\n        result = (isClosed ? [\"Z\"] : [pathCommand, x, y]) as PathSegment;\n        break;\n      case \"A\":\n        result = [\n          pathCommand,\n          segment[1],\n          segment[2],\n          segment[3],\n          segment[4],\n          segment[5] === 1 ? 0 : 1,\n          x,\n          y,\n        ] as ASegment;\n        break;\n      case \"C\":\n        if (nextSeg && nextCommand === \"S\") {\n          result = [\"S\", segment[1], segment[2], x, y] as SSegment;\n        } else {\n          result = [\n            pathCommand,\n            segment[3],\n            segment[4],\n            segment[1],\n            segment[2],\n            x,\n            y,\n          ] as CSegment;\n        }\n        break;\n      case \"S\":\n        if (\n          prevCommand && \"CS\".includes(prevCommand) &&\n          (!nextSeg || nextCommand !== \"S\")\n        ) {\n          result = [\n            \"C\",\n            normalizedSegment[3],\n            normalizedSegment[4],\n            normalizedSegment[1],\n            normalizedSegment[2],\n            x,\n            y,\n          ] as CSegment;\n        } else {\n          result = [\n            pathCommand,\n            normalizedSegment[1],\n            normalizedSegment[2],\n            x,\n            y,\n          ] as SSegment;\n        }\n        break;\n      case \"Q\":\n        if (nextSeg && nextCommand === \"T\") {\n          result = [\"T\", x, y] as TSegment;\n        } else {\n          result = [pathCommand, segment[1], segment[2], x, y] as QSegment;\n        }\n        break;\n      case \"T\":\n        if (\n          prevCommand && \"QT\".includes(prevCommand) &&\n          (!nextSeg || nextCommand !== \"T\")\n        ) {\n          result = [\n            \"Q\",\n            normalizedSegment[1],\n            normalizedSegment[2],\n            x,\n            y,\n          ] as QSegment;\n        } else {\n          result = [pathCommand, x, y] as TSegment;\n        }\n        break;\n      case \"Z\":\n        result = [\"M\", x, y] as MSegment;\n        break;\n      case \"H\":\n        result = [pathCommand, x] as HSegment;\n        break;\n      case \"V\":\n        result = [pathCommand, y] as VSegment;\n        break;\n      default:\n        result = [pathCommand as typeof pathCommand | number].concat(\n          segment.slice(1, -2),\n          x,\n          y,\n        ) as PathSegment;\n    }\n\n    return result;\n  });\n\n  return (\n    isClosed\n      ? reversedPath.reverse()\n      : [reversedPath[0] as PathSegment].concat(reversedPath.slice(1).reverse())\n  ) as PathArray;\n};\n\nexport default reversePath;\n","import type { PathArray } from \"../types\";\nimport defaultOptions from \"../options/options\";\nimport iterate from \"./iterate\";\nimport roundSegment from \"./roundSegment\";\n\n/**\n * Rounds the values of a `pathArray` instance to\n * a specified amount of decimals and returns it.\n *\n * @param path the source `pathArray`\n * @param roundOption the amount of decimals to round numbers to\n * @returns the resulted `pathArray` with rounded values\n */\nconst roundPath = (path: PathArray, roundOption?: number | \"off\") => {\n  let { round } = defaultOptions;\n  // allow for ZERO decimals\n  round = roundOption === \"off\"\n    ? roundOption\n    : typeof roundOption === \"number\" && roundOption >= 0\n    ? roundOption\n    : typeof round === \"number\" && round >= 0\n    ? round\n    : /* istanbul ignore next @preserve */ \"off\";\n\n  /* istanbul ignore else @preserve */\n  if (round === \"off\") return path.slice(0) as PathArray;\n\n  return iterate<typeof path>(path, (segment) => {\n    return roundSegment(segment, round);\n  });\n};\nexport default roundPath;\n","import midPoint from \"../math/midPoint\";\nimport type { CubicSegment, PointTuple } from \"../types\";\n\n/**\n * Split a cubic-bezier segment into two.\n *\n * @param pts the cubic-bezier parameters\n * @param ratio the cubic-bezier parameters\n * @return two new cubic-bezier segments\n */\nconst splitCubic = (\n  pts: number[],\n  ratio = 0.5,\n): [CubicSegment, CubicSegment] => {\n  const t = ratio;\n  const p0 = pts.slice(0, 2) as PointTuple;\n  const p1 = pts.slice(2, 4) as PointTuple;\n  const p2 = pts.slice(4, 6) as PointTuple;\n  const p3 = pts.slice(6, 8) as PointTuple;\n  const p4 = midPoint(p0, p1, t);\n  const p5 = midPoint(p1, p2, t);\n  const p6 = midPoint(p2, p3, t);\n  const p7 = midPoint(p4, p5, t);\n  const p8 = midPoint(p5, p6, t);\n  const p9 = midPoint(p7, p8, t);\n\n  return [\n    [\"C\", p4[0], p4[1], p7[0], p7[1], p9[0], p9[1]],\n    [\"C\", p8[0], p8[1], p6[0], p6[1], p3[0], p3[1]],\n  ];\n};\nexport default splitCubic;\n","import paramsParser from \"../parser/paramsParser\";\nimport type {\n  AbsoluteCommand,\n  HSegment,\n  MSegment,\n  PathArray,\n  PointTuple,\n  RelativeCommand,\n  VSegment,\n} from \"../types\";\n\n/**\n * Split a path into an `Array` of sub-path strings.\n *\n * In the process, values are converted to absolute\n * for visual consistency.\n *\n * @param pathInput the source `pathArray`\n * @return an array with all sub-path strings\n */\nconst splitPath = (pathInput: PathArray): PathArray[] => {\n  const composite = [] as PathArray[];\n  let path: PathArray;\n  let pi = -1;\n  let x = 0;\n  let y = 0;\n  let mx = 0;\n  let my = 0;\n  const params = { ...paramsParser };\n\n  pathInput.forEach((seg) => {\n    const [pathCommand] = seg;\n    const absCommand = pathCommand.toUpperCase() as AbsoluteCommand;\n    const relCommand = pathCommand.toLowerCase() as RelativeCommand;\n    const isRelative = pathCommand === relCommand;\n    const values = seg.slice(1) as number[];\n\n    if (absCommand === \"M\") {\n      pi += 1;\n      [x, y] = values as PointTuple;\n      x += isRelative ? params.x : 0;\n      y += isRelative ? params.y : 0;\n      mx = x;\n      my = y;\n      path = [(isRelative ? [absCommand, mx, my] : seg) as MSegment];\n    } else {\n      if (absCommand === \"Z\") {\n        x = mx;\n        y = my;\n      } else if (absCommand === \"H\") {\n        [, x] = seg as HSegment;\n        x += isRelative ? params.x : /* istanbul ignore next @preserve */ 0;\n      } else if (absCommand === \"V\") {\n        [, y] = seg as VSegment;\n        y += isRelative ? params.y : /* istanbul ignore next @preserve */ 0;\n      } else {\n        [x, y] = seg.slice(-2) as PointTuple;\n        x += isRelative ? params.x : 0;\n        y += isRelative ? params.y : 0;\n      }\n      path.push(seg);\n    }\n\n    params.x = x;\n    params.y = y;\n    composite[pi] = path;\n  });\n\n  return composite;\n};\nexport default splitPath;\n","import getSVGMatrix from \"./getSVGMatrix\";\nimport projection2d from \"./projection2d\";\nimport defaultOptions from \"../options/options\";\nimport type {\n  AbsoluteArray,\n  AbsoluteSegment,\n  CSegment,\n  LSegment,\n  PathArray,\n  TransformObjectValues,\n} from \"../types\";\nimport type { TransformObject } from \"../interface\";\nimport iterate from \"./iterate\";\nimport parsePathString from \"../parser/parsePathString\";\nimport absolutizeSegment from \"./absolutizeSegment\";\nimport arcToCubic from \"./arcToCubic\";\n\n/**\n * Apply a 2D / 3D transformation to a `pathArray` instance.\n *\n * Since *SVGElement* doesn't support 3D transformation, this function\n * creates a 2D projection of the <path> element.\n *\n * @param path the `pathArray` to apply transformation\n * @param transform the transform functions `Object`\n * @returns the resulted `pathArray`\n */\nconst transformPath = (\n  pathInput: PathArray | string,\n  transform?: Partial<TransformObject>,\n) => {\n  // last x and y transformed values\n  let x = 0;\n  let y = 0;\n  // new x and y transformed\n  let lx = 0;\n  let ly = 0;\n  // segment params iteration index and length\n  let j = 0;\n  let jj = 0;\n  let pathCommand = \"M\";\n  // transform uses it's own set of params\n  const path = parsePathString(pathInput);\n  const transformProps = transform && Object.keys(transform);\n\n  // when used as a static method, invalidate somehow\n  if (!transform || (transformProps && !transformProps.length)) {\n    return path.slice(0) as typeof path;\n  }\n\n  // transform origin is extremely important\n  if (!transform.origin) {\n    Object.assign(transform, { origin: defaultOptions.origin });\n  }\n  const origin = transform.origin as [number, number, number];\n  const matrixInstance = getSVGMatrix(transform as TransformObjectValues);\n\n  if (matrixInstance.isIdentity) return path.slice(0) as typeof path;\n\n  return iterate<AbsoluteArray>(path, (seg, index, lastX, lastY) => {\n    [pathCommand] = seg;\n    const absCommand = pathCommand.toUpperCase();\n    const isRelative = absCommand !== pathCommand;\n    const absoluteSegment = isRelative\n      ? absolutizeSegment(seg, index, lastX, lastY)\n      : (seg.slice(0) as AbsoluteSegment);\n\n    let result = absCommand === \"A\"\n      // ? segmentToCubic(absoluteSegment, transformParams)\n      ? ([\"C\" as string | number].concat(\n        arcToCubic(\n          lastX,\n          lastY,\n          absoluteSegment[1] as number,\n          absoluteSegment[2] as number,\n          absoluteSegment[3] as number,\n          absoluteSegment[4] as number,\n          absoluteSegment[5] as number,\n          absoluteSegment[6] as number,\n          absoluteSegment[7] as number,\n        ),\n      ) as CSegment)\n      : absCommand === \"V\"\n      ? ([\"L\", lastX, absoluteSegment[1]] as LSegment)\n      : absCommand === \"H\"\n      ? ([\"L\", absoluteSegment[1], lastY] as LSegment)\n      : absoluteSegment;\n\n    // update pathCommand\n    pathCommand = result[0];\n    const isLongArc = pathCommand === \"C\" && result.length > 7;\n    const tempSegment =\n      (isLongArc ? result.slice(0, 7) : result.slice(0)) as AbsoluteSegment;\n\n    if (isLongArc) {\n      path.splice(\n        index + 1,\n        0,\n        [\"C\" as typeof pathCommand | number].concat(\n          result.slice(7),\n        ) as CSegment,\n      );\n      result = tempSegment as CSegment;\n    }\n\n    if (pathCommand === \"L\") {\n      [lx, ly] = projection2d(matrixInstance, [\n        (result as LSegment)[1],\n        (result as LSegment)[2],\n      ], origin);\n\n      /* istanbul ignore else @preserve */\n      if (x !== lx && y !== ly) {\n        result = [\"L\", lx, ly];\n      } else if (y === ly) {\n        result = [\"H\", lx];\n      } else if (x === lx) {\n        result = [\"V\", ly];\n      }\n    } else {\n      for (j = 1, jj = result.length; j < jj; j += 2) {\n        [lx, ly] = projection2d(\n          matrixInstance,\n          [+result[j], +result[j + 1]],\n          origin,\n        );\n        result[j] = lx;\n        result[j + 1] = ly;\n      }\n    }\n    // now update x and y\n    x = lx;\n    y = ly;\n\n    return result;\n  });\n};\n\nexport default transformPath;\n"]}