{"version":3,"sources":["../../src/util.ts","../../node_modules/.pnpm/@thednp+dommatrix@2.0.11/node_modules/@thednp/dommatrix/src/index.ts","../../src/math/arcTools.ts","../../src/math/lineTools.ts","../../src/math/midPoint.ts","../../src/math/distanceSquareRoot.ts","../../src/math/bezier.ts","../../src/math/cubicTools.ts","../../src/math/quadTools.ts","../../src/math/polygonTools.ts","../../src/parser/paramsCount.ts","../../src/parser/finalizeSegment.ts","../../src/parser/error.ts","../../src/parser/scanFlag.ts","../../src/parser/isDigit.ts","../../src/parser/invalidPathValue.ts","../../src/parser/scanParam.ts","../../src/parser/isSpace.ts","../../src/parser/skipSpaces.ts","../../src/parser/isPathCommand.ts","../../src/parser/isDigitStart.ts","../../src/parser/isArcCommand.ts","../../src/parser/isMoveCommand.ts","../../src/parser/scanSegment.ts","../../src/parser/pathParser.ts","../../src/parser/parsePathString.ts","../../src/process/absolutizeSegment.ts","../../src/process/iterate.ts","../../src/convert/pathToAbsolute.ts","../../src/process/relativizeSegment.ts","../../src/convert/pathToRelative.ts","../../src/math/rotateVector.ts","../../src/process/arcToCubic.ts","../../src/process/quadToCubic.ts","../../src/process/lineToCubic.ts","../../src/process/segmentToCubic.ts","../../src/process/normalizeSegment.ts","../../src/parser/paramsParser.ts","../../src/convert/pathToCurve.ts","../../src/options/options.ts","../../src/math/roundTo.ts","../../src/convert/pathToString.ts","../../src/util/distanceEpsilon.ts","../../src/process/normalizePath.ts","../../src/util/getPointAtLength.ts","../../src/util/getTotalLength.ts","../../src/util/getPropertiesAtLength.ts","../../src/util/getPropertiesAtPoint.ts","../../src/util/getClosestPoint.ts","../../src/util/getPathArea.ts","../../src/util/getDrawDirection.ts","../../src/util/getPathBBox.ts","../../src/util/getSegmentAtLength.ts","../../src/util/getSegmentOfPoint.ts","../../src/util/isPathArray.ts","../../src/util/isAbsoluteArray.ts","../../src/util/isNormalizedArray.ts","../../src/util/isCurveArray.ts","../../src/util/isPointInStroke.ts","../../src/util/isRelativeArray.ts","../../src/util/isValidPath.ts","../../src/util/shapeParams.ts","../../src/util/isElement.ts","../../src/util/shapeToPathArray.ts","../../src/util/shapeToPath.ts","../../src/process/getSVGMatrix.ts","../../src/process/shortenSegment.ts","../../src/process/roundSegment.ts","../../src/process/optimizePath.ts","../../src/process/projection2d.ts","../../src/process/reverseCurve.ts","../../src/process/reversePath.ts","../../src/process/roundPath.ts","../../src/process/splitCubic.ts","../../src/process/splitPath.ts","../../src/process/transformPath.ts"],"sourcesContent":["export { default as CSSMatrix } from \"@thednp/dommatrix\";\n// export type { PathArray, PointTuple, TransformObjectValues } from \"./types\";\n// export type { Options, TransformEntries, TransformObject } from \"./interface\";\n// export * from \"./types\";\n// export * from \"./interface\";\n\nimport * as arcTools from \"./math/arcTools\";\nimport * as bezierTools from \"./math/bezier\";\nimport * as cubicTools from \"./math/cubicTools\";\nimport * as lineTools from \"./math/lineTools\";\nimport * as quadTools from \"./math/quadTools\";\nimport * as polygonTools from \"./math/polygonTools\";\nexport { arcTools, bezierTools, cubicTools, lineTools, quadTools, polygonTools };\n\n// export * from \"./math/arcTools\";\n// export * from \"./math/bezier\";\n// export * from \"./math/cubicTools\";\n// export * from \"./math/lineTools\";\n// export * from \"./math/quadTools\";\n// export * from \"./math/polygonTools\";\n\nexport { default as pathToAbsolute } from \"./convert/pathToAbsolute\";\nexport { default as pathToRelative } from \"./convert/pathToRelative\";\nexport { default as pathToCurve } from \"./convert/pathToCurve\";\nexport { default as pathToString } from \"./convert/pathToString\";\n\nexport { default as distanceSquareRoot } from \"./math/distanceSquareRoot\";\nexport { default as midPoint } from \"./math/midPoint\";\nexport { default as rotateVector } from \"./math/rotateVector\";\nexport { default as roundTo } from \"./math/roundTo\";\n\nexport { default as parsePathString } from \"./parser/parsePathString\";\nexport { default as finalizeSegment } from \"./parser/finalizeSegment\";\nexport { default as invalidPathValue } from \"./parser/invalidPathValue\";\nexport { default as isArcCommand } from \"./parser/isArcCommand\";\nexport { default as isDigit } from \"./parser/isDigit\";\nexport { default as isDigitStart } from \"./parser/isDigitStart\";\nexport { default as isMoveCommand } from \"./parser/isMoveCommand\";\nexport { default as isPathCommand } from \"./parser/isPathCommand\";\nexport { default as isSpace } from \"./parser/isSpace\";\nexport { default as paramsCount } from \"./parser/paramsCount\";\nexport { default as paramsParser } from \"./parser/paramsParser\";\nexport { default as pathParser } from \"./parser/pathParser\";\nexport { default as scanFlag } from \"./parser/scanFlag\";\nexport { default as scanParam } from \"./parser/scanParam\";\nexport { default as scanSegment } from \"./parser/scanSegment\";\nexport { default as skipSpaces } from \"./parser/skipSpaces\";\n\nexport { default as distanceEpsilon } from \"./util/distanceEpsilon\";\nexport { default as getClosestPoint } from \"./util/getClosestPoint\";\nexport { default as getDrawDirection } from \"./util/getDrawDirection\";\nexport { default as getPathArea } from \"./util/getPathArea\";\nexport { default as getPathBBox } from \"./util/getPathBBox\";\nexport { default as getPointAtLength } from \"./util/getPointAtLength\";\nexport { default as getPropertiesAtLength } from \"./util/getPropertiesAtLength\";\nexport { default as getPropertiesAtPoint } from \"./util/getPropertiesAtPoint\";\nexport { default as getSegmentAtLength } from \"./util/getSegmentAtLength\";\nexport { default as getSegmentOfPoint } from \"./util/getSegmentOfPoint\";\nexport { default as getTotalLength } from \"./util/getTotalLength\";\n\nexport { default as isAbsoluteArray } from \"./util/isAbsoluteArray\";\nexport { default as isCurveArray } from \"./util/isCurveArray\";\nexport { default as isNormalizedArray } from \"./util/isNormalizedArray\";\nexport { default as isPathArray } from \"./util/isPathArray\";\nexport { default as isPointInStroke } from \"./util/isPointInStroke\";\nexport { default as isRelativeArray } from \"./util/isRelativeArray\";\nexport { default as isValidPath } from \"./util/isValidPath\";\nexport { default as shapeParams } from \"./util/shapeParams\";\nexport { default as shapeToPath } from \"./util/shapeToPath\";\nexport { default as shapeToPathArray } from \"./util/shapeToPathArray\";\n\nexport { default as absolutizeSegment } from \"./process/absolutizeSegment\";\nexport { default as arcToCubic } from \"./process/arcToCubic\";\nexport { default as getSVGMatrix } from \"./process/getSVGMatrix\";\nexport { default as iterate } from \"./process/iterate\";\nexport { default as lineToCubic } from \"./process/lineToCubic\";\nexport { default as normalizePath } from \"./process/normalizePath\";\nexport { default as normalizeSegment } from \"./process/normalizeSegment\";\nexport { default as optimizePath } from \"./process/optimizePath\";\nexport { default as projection2d } from \"./process/projection2d\";\nexport { default as quadToCubic } from \"./process/quadToCubic\";\nexport { default as relativizeSegment } from \"./process/relativizeSegment\";\nexport { default as reverseCurve } from \"./process/reverseCurve\";\nexport { default as reversePath } from \"./process/reversePath\";\nexport { default as roundPath } from \"./process/roundPath\";\nexport { default as roundSegment } from \"./process/roundSegment\";\nexport { default as segmentToCubic } from \"./process/segmentToCubic\";\nexport { default as shortenSegment } from \"./process/shortenSegment\";\nexport { default as splitCubic } from \"./process/splitCubic\";\nexport { default as splitPath } from \"./process/splitPath\";\nexport { default as transformPath } from \"./process/transformPath\";\n","import type {\n  CSSMatrixInput,\n  JSONMatrix,\n  Matrix,\n  Matrix3d,\n  PointTuple,\n} from \"./types\";\n\n/** A model for JSONMatrix */\nconst JSON_MATRIX: JSONMatrix = {\n  a: 1,\n  b: 0,\n  c: 0,\n  d: 1,\n  e: 0,\n  f: 0,\n  m11: 1,\n  m12: 0,\n  m13: 0,\n  m14: 0,\n  m21: 0,\n  m22: 1,\n  m23: 0,\n  m24: 0,\n  m31: 0,\n  m32: 0,\n  m33: 1,\n  m34: 0,\n  m41: 0,\n  m42: 0,\n  m43: 0,\n  m44: 1,\n  is2D: true,\n  isIdentity: true,\n};\n\n// CSSMatrix Static methods\n// * `fromArray` is a more simple implementation, should also accept Float[32/64]Array;\n// * `fromMatrix` load values from another CSSMatrix/DOMMatrix instance or JSON object;\n// * `fromString` parses and loads values from any valid CSS transform string (TransformList).\n// * `isCompatibleArray` Checks if an array is compatible with CSSMatrix.\n// * `isCompatibleObject` Checks if an object is compatible with CSSMatrix.\n\n/** Checks if an array is compatible with CSSMatrix */\nconst isCompatibleArray = (\n  array?: unknown,\n): array is Matrix | Matrix3d | Float32Array | Float64Array => {\n  return (\n    (array instanceof Float64Array ||\n      array instanceof Float32Array ||\n      (Array.isArray(array) && array.every((x) => typeof x === \"number\"))) &&\n    [6, 16].some((x) => array.length === x)\n  );\n};\n\n/** Checks if an object is compatible with CSSMatrix */\nconst isCompatibleObject = (\n  object?: unknown,\n): object is CSSMatrix | DOMMatrix | JSONMatrix => {\n  return (\n    object instanceof DOMMatrix ||\n    object instanceof CSSMatrix ||\n    (typeof object === \"object\" &&\n      Object.keys(JSON_MATRIX).every((k) => object && k in object))\n  );\n};\n\n/**\n * Creates a new mutable `CSSMatrix` instance given an array of 16/6 floating point values.\n * This static method invalidates arrays that contain non-number elements.\n *\n * If the array has six values, the result is a 2D matrix; if the array has 16 values,\n * the result is a 3D matrix. Otherwise, a TypeError exception is thrown.\n *\n * @param array an `Array` to feed values from.\n * @return the resulted matrix.\n */\nconst fromArray = (\n  array: number[] | Float32Array | Float64Array,\n): CSSMatrix => {\n  const m = new CSSMatrix();\n  const a = Array.from(array);\n\n  if (!isCompatibleArray(a)) {\n    throw TypeError(\n      `CSSMatrix: \"${a.join(\",\")}\" must be an array with 6/16 numbers.`,\n    );\n  }\n  // istanbul ignore else @preserve\n  if (a.length === 16) {\n    const [\n      m11,\n      m12,\n      m13,\n      m14,\n      m21,\n      m22,\n      m23,\n      m24,\n      m31,\n      m32,\n      m33,\n      m34,\n      m41,\n      m42,\n      m43,\n      m44,\n    ] = a;\n\n    m.m11 = m11;\n    m.a = m11;\n\n    m.m21 = m21;\n    m.c = m21;\n\n    m.m31 = m31;\n\n    m.m41 = m41;\n    m.e = m41;\n\n    m.m12 = m12;\n    m.b = m12;\n\n    m.m22 = m22;\n    m.d = m22;\n\n    m.m32 = m32;\n\n    m.m42 = m42;\n    m.f = m42;\n\n    m.m13 = m13;\n    m.m23 = m23;\n    m.m33 = m33;\n    m.m43 = m43;\n    m.m14 = m14;\n    m.m24 = m24;\n    m.m34 = m34;\n    m.m44 = m44;\n  } else if (a.length === 6) {\n    const [M11, M12, M21, M22, M41, M42] = a;\n\n    m.m11 = M11;\n    m.a = M11;\n\n    m.m12 = M12;\n    m.b = M12;\n\n    m.m21 = M21;\n    m.c = M21;\n\n    m.m22 = M22;\n    m.d = M22;\n\n    m.m41 = M41;\n    m.e = M41;\n\n    m.m42 = M42;\n    m.f = M42;\n  }\n  return m;\n};\n\n/**\n * Creates a new mutable `CSSMatrix` instance given an existing matrix or a\n * `DOMMatrix` instance which provides the values for its properties.\n *\n * @param m the source matrix to feed values from.\n * @return the resulted matrix.\n */\nconst fromMatrix = (m: CSSMatrix | DOMMatrix | JSONMatrix): CSSMatrix => {\n  if (isCompatibleObject(m)) {\n    return fromArray([\n      m.m11,\n      m.m12,\n      m.m13,\n      m.m14,\n      m.m21,\n      m.m22,\n      m.m23,\n      m.m24,\n      m.m31,\n      m.m32,\n      m.m33,\n      m.m34,\n      m.m41,\n      m.m42,\n      m.m43,\n      m.m44,\n    ]);\n  }\n  throw TypeError(\n    `CSSMatrix: \"${\n      JSON.stringify(m)\n    }\" is not a DOMMatrix / CSSMatrix / JSON compatible object.`,\n  );\n};\n\n/**\n * Creates a new mutable `CSSMatrix` given any valid CSS transform string,\n * or what we call `TransformList`:\n *\n * * `matrix(a, b, c, d, e, f)` - valid matrix() transform function\n * * `matrix3d(m11, m12, m13, ...m44)` - valid matrix3d() transform function\n * * `translate(tx, ty) rotateX(alpha)` - any valid transform function(s)\n *\n * @copyright thednp © 2021\n *\n * @param source valid CSS transform string syntax.\n * @return the resulted matrix.\n */\nconst fromString = (source: string): CSSMatrix => {\n  if (typeof source !== \"string\") {\n    throw TypeError(`CSSMatrix: \"${JSON.stringify(source)}\" is not a string.`);\n  }\n  const str = String(source).replace(/\\s/g, \"\");\n  let m = new CSSMatrix();\n  const invalidStringError = `CSSMatrix: invalid transform string \"${source}\"`;\n\n  // const px = ['perspective'];\n  // const length = ['translate', 'translate3d', 'translateX', 'translateY', 'translateZ'];\n  // const deg = ['rotate', 'rotate3d', 'rotateX', 'rotateY', 'rotateZ', 'skew', 'skewX', 'skewY'];\n  // const abs = ['scale', 'scale3d', 'matrix', 'matrix3d'];\n  // const transformFunctions = px.concat(length, deg, abs);\n\n  str\n    .split(\")\")\n    .filter((f) => f)\n    .forEach((tf) => {\n      const [prop, value] = tf.split(\"(\");\n\n      // invalidate empty string\n      if (!value) throw TypeError(invalidStringError);\n\n      const components = value\n        .split(\",\")\n        .map((\n          n,\n        ) => (n.includes(\"rad\")\n          ? parseFloat(n) * (180 / Math.PI)\n          : parseFloat(n))\n        );\n\n      const [x, y, z, a] = components;\n      const xyz = [x, y, z];\n      const xyza = [x, y, z, a];\n\n      // single number value expected\n      if (\n        prop === \"perspective\" && x && [y, z].every((n) => n === undefined)\n      ) {\n        m.m34 = -1 / x;\n        // 6/16 number values expected\n      } else if (\n        prop.includes(\"matrix\") &&\n        [6, 16].includes(components.length) &&\n        components.every((n) => !Number.isNaN(+n))\n      ) {\n        const values = components.map((n) => (Math.abs(n) < 1e-6 ? 0 : n));\n        m = m.multiply(fromArray(values as Matrix | Matrix3d));\n        // 3 values expected\n      } else if (\n        prop === \"translate3d\" && xyz.every((n) => !Number.isNaN(+n))\n      ) {\n        m = m.translate(x, y, z);\n        // single/double number value(s) expected\n      } else if (prop === \"translate\" && x && z === undefined) {\n        m = m.translate(x, y || 0, 0);\n        // all 4 values expected\n      } else if (\n        prop === \"rotate3d\" && xyza.every((n) => !Number.isNaN(+n)) && a\n      ) {\n        m = m.rotateAxisAngle(x, y, z, a);\n        // single value expected\n      } else if (\n        prop === \"rotate\" && x && [y, z].every((n) => n === undefined)\n      ) {\n        m = m.rotate(0, 0, x);\n        // 3 values expected\n      } else if (\n        prop === \"scale3d\" && xyz.every((n) => !Number.isNaN(+n)) &&\n        xyz.some((n) => n !== 1)\n      ) {\n        m = m.scale(x, y, z);\n        // single value expected\n      } else if (\n        // prop === \"scale\" && !Number.isNaN(x) && x !== 1 && z === undefined\n        // prop === \"scale\" && !Number.isNaN(x) && [x, y].some((n) => n !== 1) &&\n        prop === \"scale\" && !Number.isNaN(x) && (x !== 1 || y !== 1) &&\n        z === undefined\n      ) {\n        const nosy = Number.isNaN(+y);\n        const sy = nosy ? x : y;\n        m = m.scale(x, sy, 1);\n        // single/double value expected\n      } else if (\n        prop === \"skew\" && (x || (!Number.isNaN(x) && y)) && z === undefined\n      ) {\n        m = m.skew(x, y || 0);\n      } else if (\n        [\"translate\", \"rotate\", \"scale\", \"skew\"].some((p) =>\n          prop.includes(p)\n        ) &&\n        /[XYZ]/.test(prop) &&\n        x &&\n        [y, z].every((n) => n === undefined) // a single value expected\n      ) {\n        if (\"skewX\" === prop || \"skewY\" === prop) {\n          m = m[prop](x);\n        } else {\n          const fn = prop.replace(/[XYZ]/, \"\") as\n            | \"scale\"\n            | \"translate\"\n            | \"rotate\";\n          const axis = prop.replace(fn, \"\");\n          const idx = [\"X\", \"Y\", \"Z\"].indexOf(axis);\n          const def = fn === \"scale\" ? 1 : 0;\n          const axeValues: [number, number, number] = [\n            idx === 0 ? x : def,\n            idx === 1 ? x : def,\n            idx === 2 ? x : def,\n          ];\n          m = m[fn](...axeValues);\n        }\n      } else {\n        throw TypeError(invalidStringError);\n      }\n    });\n\n  return m;\n};\n\n/**\n * Returns an *Array* containing elements which comprise the matrix.\n * The method can return either the 16 elements or the 6 elements\n * depending on the value of the `is2D` parameter.\n *\n * @param m the source matrix to feed values from.\n * @param is2D *Array* representation of the matrix\n * @return an *Array* representation of the matrix\n */\nconst toArray = (\n  m: CSSMatrix | DOMMatrix | JSONMatrix,\n  is2D?: boolean,\n): Matrix | Matrix3d => {\n  if (is2D) {\n    return [m.a, m.b, m.c, m.d, m.e, m.f];\n  }\n  return [\n    m.m11,\n    m.m12,\n    m.m13,\n    m.m14,\n    m.m21,\n    m.m22,\n    m.m23,\n    m.m24,\n    m.m31,\n    m.m32,\n    m.m33,\n    m.m34,\n    m.m41,\n    m.m42,\n    m.m43,\n    m.m44,\n  ];\n};\n\n// Transform Functions\n// https://www.w3.org/TR/css-transforms-1/#transform-functions\n\n/**\n * Creates a new `CSSMatrix` for the translation matrix and returns it.\n * This method is equivalent to the CSS `translate3d()` function.\n *\n * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/translate3d\n *\n * @param x the `x-axis` position.\n * @param y the `y-axis` position.\n * @param z the `z-axis` position.\n * @return the resulted matrix.\n */\nconst Translate = (x: number, y: number, z: number): CSSMatrix => {\n  const m = new CSSMatrix();\n  m.m41 = x;\n  m.e = x;\n  m.m42 = y;\n  m.f = y;\n  m.m43 = z;\n  return m;\n};\n\n/**\n * Creates a new `CSSMatrix` for the rotation matrix and returns it.\n *\n * http://en.wikipedia.org/wiki/Rotation_matrix\n *\n * @param rx the `x-axis` rotation.\n * @param ry the `y-axis` rotation.\n * @param rz the `z-axis` rotation.\n * @return the resulted matrix.\n */\nconst Rotate = (rx: number, ry: number, rz: number): CSSMatrix => {\n  const m = new CSSMatrix();\n  const degToRad = Math.PI / 180;\n  const radX = rx * degToRad;\n  const radY = ry * degToRad;\n  const radZ = rz * degToRad;\n\n  // minus sin() because of right-handed system\n  const cosx = Math.cos(radX);\n  const sinx = -Math.sin(radX);\n  const cosy = Math.cos(radY);\n  const siny = -Math.sin(radY);\n  const cosz = Math.cos(radZ);\n  const sinz = -Math.sin(radZ);\n\n  const m11 = cosy * cosz;\n  const m12 = -cosy * sinz;\n\n  m.m11 = m11;\n  m.a = m11;\n\n  m.m12 = m12;\n  m.b = m12;\n\n  m.m13 = siny;\n\n  const m21 = sinx * siny * cosz + cosx * sinz;\n  m.m21 = m21;\n  m.c = m21;\n\n  const m22 = cosx * cosz - sinx * siny * sinz;\n  m.m22 = m22;\n  m.d = m22;\n\n  m.m23 = -sinx * cosy;\n\n  m.m31 = sinx * sinz - cosx * siny * cosz;\n  m.m32 = sinx * cosz + cosx * siny * sinz;\n  m.m33 = cosx * cosy;\n\n  return m;\n};\n\n/**\n * Creates a new `CSSMatrix` for the rotation matrix and returns it.\n * This method is equivalent to the CSS `rotate3d()` function.\n *\n * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/rotate3d\n *\n * @param x the `x-axis` vector length.\n * @param y the `y-axis` vector length.\n * @param z the `z-axis` vector length.\n * @param alpha the value in degrees of the rotation.\n * @return the resulted matrix.\n */\nconst RotateAxisAngle = (\n  x: number,\n  y: number,\n  z: number,\n  alpha: number,\n): CSSMatrix => {\n  const m = new CSSMatrix();\n  const length = Math.sqrt(x * x + y * y + z * z);\n\n  if (length === 0) {\n    // bad vector length, return identity\n    return m;\n  }\n\n  const X = x / length;\n  const Y = y / length;\n  const Z = z / length;\n\n  const angle = alpha * (Math.PI / 360);\n  const sinA = Math.sin(angle);\n  const cosA = Math.cos(angle);\n  const sinA2 = sinA * sinA;\n  const x2 = X * X;\n  const y2 = Y * Y;\n  const z2 = Z * Z;\n\n  const m11 = 1 - 2 * (y2 + z2) * sinA2;\n  m.m11 = m11;\n  m.a = m11;\n\n  const m12 = 2 * (X * Y * sinA2 + Z * sinA * cosA);\n  m.m12 = m12;\n  m.b = m12;\n\n  m.m13 = 2 * (X * Z * sinA2 - Y * sinA * cosA);\n\n  const m21 = 2 * (Y * X * sinA2 - Z * sinA * cosA);\n  m.m21 = m21;\n  m.c = m21;\n\n  const m22 = 1 - 2 * (z2 + x2) * sinA2;\n  m.m22 = m22;\n  m.d = m22;\n\n  m.m23 = 2 * (Y * Z * sinA2 + X * sinA * cosA);\n  m.m31 = 2 * (Z * X * sinA2 + Y * sinA * cosA);\n  m.m32 = 2 * (Z * Y * sinA2 - X * sinA * cosA);\n  m.m33 = 1 - 2 * (x2 + y2) * sinA2;\n\n  return m;\n};\n\n/**\n * Creates a new `CSSMatrix` for the scale matrix and returns it.\n * This method is equivalent to the CSS `scale3d()` function, except it doesn't\n * accept {x, y, z} transform origin parameters.\n *\n * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/scale3d\n *\n * @param x the `x-axis` scale.\n * @param y the `y-axis` scale.\n * @param z the `z-axis` scale.\n * @return the resulted matrix.\n */\nconst Scale = (x: number, y: number, z: number): CSSMatrix => {\n  const m = new CSSMatrix();\n  m.m11 = x;\n  m.a = x;\n\n  m.m22 = y;\n  m.d = y;\n\n  m.m33 = z;\n  return m;\n};\n\n/**\n * Creates a new `CSSMatrix` for the shear of both the `x-axis` and`y-axis`\n * matrix and returns it. This method is equivalent to the CSS `skew()` function.\n *\n * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/skew\n *\n * @param angleX the X-angle in degrees.\n * @param angleY the Y-angle in degrees.\n * @return the resulted matrix.\n */\nconst Skew = (angleX: number, angleY: number): CSSMatrix => {\n  const m = new CSSMatrix();\n  if (angleX) {\n    const radX = (angleX * Math.PI) / 180;\n    const tX = Math.tan(radX);\n    m.m21 = tX;\n    m.c = tX;\n  }\n  if (angleY) {\n    const radY = (angleY * Math.PI) / 180;\n    const tY = Math.tan(radY);\n    m.m12 = tY;\n    m.b = tY;\n  }\n  return m;\n};\n\n/**\n * Creates a new `CSSMatrix` for the shear of the `x-axis` rotation matrix and\n * returns it. This method is equivalent to the CSS `skewX()` function.\n *\n * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/skewX\n *\n * @param angle the angle in degrees.\n * @return the resulted matrix.\n */\nconst SkewX = (angle: number): CSSMatrix => {\n  return Skew(angle, 0);\n};\n\n/**\n * Creates a new `CSSMatrix` for the shear of the `y-axis` rotation matrix and\n * returns it. This method is equivalent to the CSS `skewY()` function.\n *\n * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/skewY\n *\n * @param angle the angle in degrees.\n * @return the resulted matrix.\n */\nconst SkewY = (angle: number): CSSMatrix => {\n  return Skew(0, angle);\n};\n\n/**\n * Creates a new `CSSMatrix` resulted from the multiplication of two matrixes\n * and returns it. Both matrixes are not changed.\n *\n * @param m1 the first matrix.\n * @param m2 the second matrix.\n * @return the resulted matrix.\n */\nconst Multiply = (\n  m1: CSSMatrix | DOMMatrix | JSONMatrix,\n  m2: CSSMatrix | DOMMatrix | JSONMatrix,\n): CSSMatrix => {\n  const m11 = m2.m11 * m1.m11 + m2.m12 * m1.m21 + m2.m13 * m1.m31 +\n    m2.m14 * m1.m41;\n  const m12 = m2.m11 * m1.m12 + m2.m12 * m1.m22 + m2.m13 * m1.m32 +\n    m2.m14 * m1.m42;\n  const m13 = m2.m11 * m1.m13 + m2.m12 * m1.m23 + m2.m13 * m1.m33 +\n    m2.m14 * m1.m43;\n  const m14 = m2.m11 * m1.m14 + m2.m12 * m1.m24 + m2.m13 * m1.m34 +\n    m2.m14 * m1.m44;\n\n  const m21 = m2.m21 * m1.m11 + m2.m22 * m1.m21 + m2.m23 * m1.m31 +\n    m2.m24 * m1.m41;\n  const m22 = m2.m21 * m1.m12 + m2.m22 * m1.m22 + m2.m23 * m1.m32 +\n    m2.m24 * m1.m42;\n  const m23 = m2.m21 * m1.m13 + m2.m22 * m1.m23 + m2.m23 * m1.m33 +\n    m2.m24 * m1.m43;\n  const m24 = m2.m21 * m1.m14 + m2.m22 * m1.m24 + m2.m23 * m1.m34 +\n    m2.m24 * m1.m44;\n\n  const m31 = m2.m31 * m1.m11 + m2.m32 * m1.m21 + m2.m33 * m1.m31 +\n    m2.m34 * m1.m41;\n  const m32 = m2.m31 * m1.m12 + m2.m32 * m1.m22 + m2.m33 * m1.m32 +\n    m2.m34 * m1.m42;\n  const m33 = m2.m31 * m1.m13 + m2.m32 * m1.m23 + m2.m33 * m1.m33 +\n    m2.m34 * m1.m43;\n  const m34 = m2.m31 * m1.m14 + m2.m32 * m1.m24 + m2.m33 * m1.m34 +\n    m2.m34 * m1.m44;\n\n  const m41 = m2.m41 * m1.m11 + m2.m42 * m1.m21 + m2.m43 * m1.m31 +\n    m2.m44 * m1.m41;\n  const m42 = m2.m41 * m1.m12 + m2.m42 * m1.m22 + m2.m43 * m1.m32 +\n    m2.m44 * m1.m42;\n  const m43 = m2.m41 * m1.m13 + m2.m42 * m1.m23 + m2.m43 * m1.m33 +\n    m2.m44 * m1.m43;\n  const m44 = m2.m41 * m1.m14 + m2.m42 * m1.m24 + m2.m43 * m1.m34 +\n    m2.m44 * m1.m44;\n\n  return fromArray([\n    m11,\n    m12,\n    m13,\n    m14,\n    m21,\n    m22,\n    m23,\n    m24,\n    m31,\n    m32,\n    m33,\n    m34,\n    m41,\n    m42,\n    m43,\n    m44,\n  ]);\n};\n\n/**\n * Creates and returns a new `DOMMatrix` compatible instance\n * with equivalent instance.\n *\n * @class CSSMatrix\n *\n * @author thednp <https://github.com/thednp/DOMMatrix/>\n * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMMatrix\n */\nexport default class CSSMatrix {\n  declare m11: number;\n  declare m12: number;\n  declare m13: number;\n  declare m14: number;\n  declare m21: number;\n  declare m22: number;\n  declare m23: number;\n  declare m24: number;\n  declare m31: number;\n  declare m32: number;\n  declare m33: number;\n  declare m34: number;\n  declare m41: number;\n  declare m42: number;\n  declare m43: number;\n  declare m44: number;\n  declare a: number;\n  declare b: number;\n  declare c: number;\n  declare d: number;\n  declare e: number;\n  declare f: number;\n  static Translate = Translate;\n  static Rotate = Rotate;\n  static RotateAxisAngle = RotateAxisAngle;\n  static Scale = Scale;\n  static SkewX = SkewX;\n  static SkewY = SkewY;\n  static Skew = Skew;\n  static Multiply = Multiply;\n  static fromArray = fromArray;\n  static fromMatrix = fromMatrix;\n  static fromString = fromString;\n  static toArray = toArray;\n  static isCompatibleArray = isCompatibleArray;\n  static isCompatibleObject = isCompatibleObject;\n\n  /**\n   * @constructor\n   * @param init accepts all parameter configurations:\n   * * valid CSS transform string,\n   * * CSSMatrix/DOMMatrix instance,\n   * * a 6/16 elements *Array*.\n   */\n  constructor(init?: CSSMatrixInput) {\n    // array 6\n    this.a = 1;\n    this.b = 0;\n    this.c = 0;\n    this.d = 1;\n    this.e = 0;\n    this.f = 0;\n    // array 16\n    this.m11 = 1;\n    this.m12 = 0;\n    this.m13 = 0;\n    this.m14 = 0;\n    this.m21 = 0;\n    this.m22 = 1;\n    this.m23 = 0;\n    this.m24 = 0;\n    this.m31 = 0;\n    this.m32 = 0;\n    this.m33 = 1;\n    this.m34 = 0;\n    this.m41 = 0;\n    this.m42 = 0;\n    this.m43 = 0;\n    this.m44 = 1;\n\n    if (init) {\n      return this.setMatrixValue(init);\n    }\n    return this;\n  }\n\n  /**\n   * A `Boolean` whose value is `true` if the matrix is the identity matrix. The identity\n   * matrix is one in which every value is 0 except those on the main diagonal from top-left\n   * to bottom-right corner (in other words, where the offsets in each direction are equal).\n   *\n   * @return the current property value\n   */\n  get isIdentity(): boolean {\n    return (\n      this.m11 === 1 &&\n      this.m12 === 0 &&\n      this.m13 === 0 &&\n      this.m14 === 0 &&\n      this.m21 === 0 &&\n      this.m22 === 1 &&\n      this.m23 === 0 &&\n      this.m24 === 0 &&\n      this.m31 === 0 &&\n      this.m32 === 0 &&\n      this.m33 === 1 &&\n      this.m34 === 0 &&\n      this.m41 === 0 &&\n      this.m42 === 0 &&\n      this.m43 === 0 &&\n      this.m44 === 1\n    );\n  }\n\n  /**\n   * A `Boolean` flag whose value is `true` if the matrix was initialized as a 2D matrix\n   * and `false` if the matrix is 3D.\n   *\n   * @return the current property value\n   */\n  get is2D(): boolean {\n    return this.m31 === 0 && this.m32 === 0 && this.m33 === 1 &&\n      this.m34 === 0 && this.m43 === 0 && this.m44 === 1;\n  }\n\n  /**\n   * The `setMatrixValue` method replaces the existing matrix with one computed\n   * in the browser. EG: `matrix(1,0.25,-0.25,1,0,0)`\n   *\n   * The method accepts any *Array* values, the result of\n   * `DOMMatrix` instance method `toFloat64Array()` / `toFloat32Array()` calls\n   * or `CSSMatrix` instance method `toArray()`.\n   *\n   * This method expects valid *matrix()* / *matrix3d()* string values, as well\n   * as other transform functions like *translateX(10px)*.\n   *\n   * @param source\n   * @return the matrix instance\n   */\n  setMatrixValue(source?: CSSMatrixInput): CSSMatrix {\n    // CSS transform string source - TransformList first\n    if (typeof source === \"string\" && source.length && source !== \"none\") {\n      return fromString(source);\n    }\n\n    // [Array | Float[32/64]Array] come next\n    if (\n      Array.isArray(source) || source instanceof Float64Array ||\n      source instanceof Float32Array\n    ) {\n      return fromArray(source);\n    }\n\n    // new CSSMatrix(CSSMatrix | DOMMatrix | JSONMatrix) last\n    if (typeof source === \"object\") {\n      return fromMatrix(source);\n    }\n\n    return this;\n  }\n\n  /**\n   * Returns a *Float32Array* containing elements which comprise the matrix.\n   * The method can return either the 16 elements or the 6 elements\n   * depending on the value of the `is2D` parameter.\n   *\n   * @param is2D *Array* representation of the matrix\n   * @return an *Array* representation of the matrix\n   */\n  toFloat32Array(is2D?: boolean): Float32Array {\n    return Float32Array.from(toArray(this, is2D));\n  }\n\n  /**\n   * Returns a *Float64Array* containing elements which comprise the matrix.\n   * The method can return either the 16 elements or the 6 elements\n   * depending on the value of the `is2D` parameter.\n   *\n   * @param is2D *Array* representation of the matrix\n   * @return an *Array* representation of the matrix\n   */\n  toFloat64Array(is2D?: boolean): Float64Array {\n    return Float64Array.from(toArray(this, is2D));\n  }\n\n  /**\n   * Creates and returns a string representation of the matrix in `CSS` matrix syntax,\n   * using the appropriate `CSS` matrix notation.\n   *\n   * matrix3d *matrix3d(m11, m12, m13, m14, m21, ...)*\n   * matrix *matrix(a, b, c, d, e, f)*\n   *\n   * @return a string representation of the matrix\n   */\n  toString(): string {\n    const { is2D } = this;\n    const values = this.toFloat64Array(is2D).join(\", \");\n    const type = is2D ? \"matrix\" : \"matrix3d\";\n    return `${type}(${values})`;\n  }\n\n  /**\n   * Returns a JSON representation of the `CSSMatrix` instance, a standard *Object*\n   * that includes `{a,b,c,d,e,f}` and `{m11,m12,m13,..m44}` properties as well\n   * as the `is2D` & `isIdentity` properties.\n   *\n   * The result can also be used as a second parameter for the `fromMatrix` static method\n   * to load values into another matrix instance.\n   *\n   * @return an *Object* with all matrix values.\n   */\n  toJSON(): JSONMatrix {\n    const { is2D, isIdentity } = this;\n    return { ...this, is2D, isIdentity };\n  }\n\n  /**\n   * The Multiply method returns a new CSSMatrix which is the result of this\n   * matrix multiplied by the passed matrix, with the passed matrix to the right.\n   * This matrix is not modified.\n   *\n   * @param m2 CSSMatrix\n   * @return The resulted matrix.\n   */\n  multiply(m2: CSSMatrix | DOMMatrix | JSONMatrix): CSSMatrix {\n    return Multiply(this, m2);\n  }\n\n  /**\n   * The translate method returns a new matrix which is this matrix post\n   * multiplied by a translation matrix containing the passed values. If the z\n   * component is undefined, a 0 value is used in its place. This matrix is not\n   * modified.\n   *\n   * @param x X component of the translation value.\n   * @param y Y component of the translation value.\n   * @param z Z component of the translation value.\n   * @return The resulted matrix\n   */\n  translate(x: number, y?: number, z?: number): CSSMatrix {\n    const X = x;\n    let Y = y;\n    let Z = z;\n    if (typeof Y === \"undefined\") Y = 0;\n    if (typeof Z === \"undefined\") Z = 0;\n    return Multiply(this, Translate(X, Y, Z));\n  }\n\n  /**\n   * The scale method returns a new matrix which is this matrix post multiplied by\n   * a scale matrix containing the passed values. If the z component is undefined,\n   * a 1 value is used in its place. If the y component is undefined, the x\n   * component value is used in its place. This matrix is not modified.\n   *\n   * @param x The X component of the scale value.\n   * @param y The Y component of the scale value.\n   * @param z The Z component of the scale value.\n   * @return The resulted matrix\n   */\n  scale(x: number, y?: number, z?: number): CSSMatrix {\n    const X = x;\n    let Y = y;\n    let Z = z;\n    if (typeof Y === \"undefined\") Y = x;\n    if (typeof Z === \"undefined\") Z = 1; // Z must be 1 if undefined\n\n    return Multiply(this, Scale(X, Y, Z));\n  }\n\n  /**\n   * The rotate method returns a new matrix which is this matrix post multiplied\n   * by each of 3 rotation matrices about the major axes, first X, then Y, then Z.\n   * If the y and z components are undefined, the x value is used to rotate the\n   * object about the z axis, as though the vector (0,0,x) were passed. All\n   * rotation values are in degrees. This matrix is not modified.\n   *\n   * @param rx The X component of the rotation, or Z if Y and Z are null.\n   * @param ry The (optional) Y component of the rotation value.\n   * @param rz The (optional) Z component of the rotation value.\n   * @return The resulted matrix\n   */\n  rotate(rx: number, ry?: number, rz?: number): CSSMatrix {\n    let RX = rx;\n    let RY = ry || 0;\n    let RZ = rz || 0;\n\n    if (\n      typeof rx === \"number\" && typeof ry === \"undefined\" &&\n      typeof rz === \"undefined\"\n    ) {\n      RZ = RX;\n      RX = 0;\n      RY = 0;\n    }\n\n    return Multiply(this, Rotate(RX, RY, RZ));\n  }\n\n  /**\n   * The rotateAxisAngle method returns a new matrix which is this matrix post\n   * multiplied by a rotation matrix with the given axis and `angle`. The right-hand\n   * rule is used to determine the direction of rotation. All rotation values are\n   * in degrees. This matrix is not modified.\n   *\n   * @param x The X component of the axis vector.\n   * @param y The Y component of the axis vector.\n   * @param z The Z component of the axis vector.\n   * @param angle The angle of rotation about the axis vector, in degrees.\n   * @return The resulted matrix\n   */\n  rotateAxisAngle(x: number, y: number, z: number, angle: number): CSSMatrix {\n    if ([x, y, z, angle].some((n) => Number.isNaN(+n))) {\n      throw new TypeError(\"CSSMatrix: expecting 4 values\");\n    }\n    return Multiply(this, RotateAxisAngle(x, y, z, angle));\n  }\n\n  /**\n   * Specifies a skew transformation along the `x-axis` by the given angle.\n   * This matrix is not modified.\n   *\n   * @param angle The angle amount in degrees to skew.\n   * @return The resulted matrix\n   */\n  skewX(angle: number): CSSMatrix {\n    return Multiply(this, SkewX(angle));\n  }\n\n  /**\n   * Specifies a skew transformation along the `y-axis` by the given angle.\n   * This matrix is not modified.\n   *\n   * @param angle The angle amount in degrees to skew.\n   * @return The resulted matrix\n   */\n  skewY(angle: number): CSSMatrix {\n    return Multiply(this, SkewY(angle));\n  }\n\n  /**\n   * Specifies a skew transformation along both the `x-axis` and `y-axis`.\n   * This matrix is not modified.\n   *\n   * @param angleX The X-angle amount in degrees to skew.\n   * @param angleY The angle amount in degrees to skew.\n   * @return The resulted matrix\n   */\n  skew(angleX: number, angleY: number): CSSMatrix {\n    return Multiply(this, Skew(angleX, angleY));\n  }\n\n  /**\n   * Transforms a specified vector using the matrix, returning a new\n   * {x,y,z,w} Tuple *Object* comprising the transformed vector.\n   * Neither the matrix nor the original vector are altered.\n   *\n   * The method is equivalent with `transformPoint()` method\n   * of the `DOMMatrix` constructor.\n   *\n   * @param t Tuple with `{x,y,z,w}` components\n   * @return the resulting Tuple\n   */\n  transformPoint(t: PointTuple | DOMPoint): PointTuple | DOMPoint {\n    const x = this.m11 * t.x + this.m21 * t.y + this.m31 * t.z + this.m41 * t.w;\n    const y = this.m12 * t.x + this.m22 * t.y + this.m32 * t.z + this.m42 * t.w;\n    const z = this.m13 * t.x + this.m23 * t.y + this.m33 * t.z + this.m43 * t.w;\n    const w = this.m14 * t.x + this.m24 * t.y + this.m34 * t.z + this.m44 * t.w;\n\n    return t instanceof DOMPoint ? new DOMPoint(x, y, z, w) : {\n      x,\n      y,\n      z,\n      w,\n    };\n  }\n}\n","import { getPointAtLineLength } from \"./lineTools\";\nimport type { Point, PointTuple } from \"../types\";\n\n/**\n * Returns the Arc segment length.\n * @param rx radius along X axis\n * @param ry radius along Y axis\n * @param theta the angle in radians\n * @returns the arc length\n */\nconst arcLength = (rx: number, ry: number, theta: number) => {\n  const halfTheta = theta / 2;\n  const sinHalfTheta = Math.sin(halfTheta);\n  const cosHalfTheta = Math.cos(halfTheta);\n  const term1 = rx ** 2 * sinHalfTheta ** 2;\n  const term2 = ry ** 2 * cosHalfTheta ** 2;\n  const length = Math.sqrt(term1 + term2) * theta;\n  return Math.abs(length);\n};\n\n/**\n * Find point on ellipse at given angle around ellipse (theta);\n * @param cx the center X\n * @param cy the center Y\n * @param rx the radius X\n * @param ry the radius Y\n * @param alpha the arc rotation angle in radians\n * @param theta the arc sweep angle in radians\n * @returns a point around ellipse at given angle\n */\nconst arcPoint = (\n  cx: number,\n  cy: number,\n  rx: number,\n  ry: number,\n  alpha: number,\n  theta: number,\n) => {\n  const { sin, cos } = Math;\n  // theta is angle in radians around arc\n  // alpha is angle of rotation of ellipse in radians\n  const cosA = cos(alpha);\n  const sinA = sin(alpha);\n  const x = rx * cos(theta);\n  const y = ry * sin(theta);\n\n  return [cx + cosA * x - sinA * y, cy + sinA * x + cosA * y] as PointTuple;\n};\n\n/**\n * Returns the angle between two points.\n * @param v0 starting point\n * @param v1 ending point\n * @returns the angle in radian\n */\nconst angleBetween = (v0: Point, v1: Point) => {\n  const { x: v0x, y: v0y } = v0;\n  const { x: v1x, y: v1y } = v1;\n  const p = v0x * v1x + v0y * v1y;\n  const n = Math.sqrt((v0x ** 2 + v0y ** 2) * (v1x ** 2 + v1y ** 2));\n  const sign = v0x * v1y - v0y * v1x < 0 ? -1 : 1;\n  return sign * Math.acos(p / n);\n};\n\n/**\n * Returns the following properties for an Arc segment: center, start angle,\n * end angle, and radiuses on X and Y axis.\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param RX the radius on X axis\n * @param RY the radius on Y axis\n * @param angle the ellipse rotation in degrees\n * @param LAF the large arc flag\n * @param SF the sweep flag\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @returns properties specific to Arc segments\n */\nconst getArcProps = (\n  x1: number,\n  y1: number,\n  RX: number,\n  RY: number,\n  angle: number,\n  LAF: number,\n  SF: number,\n  x: number,\n  y: number,\n) => {\n  const { abs, sin, cos, sqrt, PI } = Math;\n  let rx = abs(RX);\n  let ry = abs(RY);\n  const xRot = ((angle % 360) + 360) % 360;\n  const xRotRad = xRot * (PI / 180);\n\n  // istanbul ignore next @preserve\n  if (x1 === x && y1 === y) {\n    return {\n      rx,\n      ry,\n      startAngle: 0,\n      endAngle: 0,\n      center: { x, y },\n    };\n  }\n\n  if (rx === 0 || ry === 0) {\n    return {\n      rx,\n      ry,\n      startAngle: 0,\n      endAngle: 0,\n      center: { x: (x + x1) / 2, y: (y + y1) / 2 },\n    };\n  }\n\n  const dx = (x1 - x) / 2;\n  const dy = (y1 - y) / 2;\n\n  const transformedPoint = {\n    x: cos(xRotRad) * dx + sin(xRotRad) * dy,\n    y: -sin(xRotRad) * dx + cos(xRotRad) * dy,\n  };\n\n  const radiiCheck = transformedPoint.x ** 2 / rx ** 2 +\n    transformedPoint.y ** 2 / ry ** 2;\n\n  if (radiiCheck > 1) {\n    rx *= sqrt(radiiCheck);\n    ry *= sqrt(radiiCheck);\n  }\n\n  const cSquareNumerator = rx ** 2 * ry ** 2 -\n    rx ** 2 * transformedPoint.y ** 2 - ry ** 2 * transformedPoint.x ** 2;\n  const cSquareRootDenom = rx ** 2 * transformedPoint.y ** 2 +\n    ry ** 2 * transformedPoint.x ** 2;\n\n  let cRadicand = cSquareNumerator / cSquareRootDenom;\n  /* istanbul ignore next @preserve */\n  cRadicand = cRadicand < 0 ? 0 : cRadicand;\n  const cCoef = (LAF !== SF ? 1 : -1) * sqrt(cRadicand);\n  const transformedCenter = {\n    x: cCoef * ((rx * transformedPoint.y) / ry),\n    y: cCoef * (-(ry * transformedPoint.x) / rx),\n  };\n\n  const center = {\n    x: cos(xRotRad) * transformedCenter.x - sin(xRotRad) * transformedCenter.y +\n      (x1 + x) / 2,\n    y: sin(xRotRad) * transformedCenter.x + cos(xRotRad) * transformedCenter.y +\n      (y1 + y) / 2,\n  };\n\n  const startVector = {\n    x: (transformedPoint.x - transformedCenter.x) / rx,\n    y: (transformedPoint.y - transformedCenter.y) / ry,\n  };\n\n  const startAngle = angleBetween({ x: 1, y: 0 }, startVector);\n\n  const endVector = {\n    x: (-transformedPoint.x - transformedCenter.x) / rx,\n    y: (-transformedPoint.y - transformedCenter.y) / ry,\n  };\n\n  let sweepAngle = angleBetween(startVector, endVector);\n  if (!SF && sweepAngle > 0) {\n    sweepAngle -= 2 * PI;\n  } else if (SF && sweepAngle < 0) {\n    sweepAngle += 2 * PI;\n  }\n  sweepAngle %= 2 * PI;\n\n  const endAngle = startAngle + sweepAngle;\n\n  // point.ellipticalArcStartAngle = startAngle;\n  // point.ellipticalArcEndAngle = startAngle + sweepAngle;\n  // point.ellipticalArcAngle = alpha;\n\n  // point.ellipticalArcCenter = center;\n  // point.resultantRx = rx;\n  // point.resultantRy = ry;\n\n  return {\n    center,\n    startAngle,\n    endAngle,\n    rx,\n    ry,\n  };\n};\n\n/**\n * Returns the length of an Arc segment.\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param c1x the first control point X\n * @param c1y the first control point Y\n * @param c2x the second control point X\n * @param c2y the second control point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @returns the length of the Arc segment\n */\nconst getArcLength = (\n  x1: number,\n  y1: number,\n  RX: number,\n  RY: number,\n  angle: number,\n  LAF: number,\n  SF: number,\n  x: number,\n  y: number,\n) => {\n  const { rx, ry, startAngle, endAngle } = getArcProps(\n    x1,\n    y1,\n    RX,\n    RY,\n    angle,\n    LAF,\n    SF,\n    x,\n    y,\n  );\n  return arcLength(rx, ry, endAngle - startAngle);\n};\n\n/**\n * Returns a point along an Arc segment at a given distance.\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param RX the radius on X axis\n * @param RY the radius on Y axis\n * @param angle the ellipse rotation in degrees\n * @param LAF the large arc flag\n * @param SF the sweep flag\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @param distance a [0-1] ratio\n * @returns a point along the Arc segment\n */\nconst getPointAtArcLength = (\n  x1: number,\n  y1: number,\n  RX: number,\n  RY: number,\n  angle: number,\n  LAF: number,\n  SF: number,\n  x: number,\n  y: number,\n  distance?: number,\n) => {\n  let point = { x: x1, y: y1 };\n  const { center, rx, ry, startAngle, endAngle } = getArcProps(\n    x1,\n    y1,\n    RX,\n    RY,\n    angle,\n    LAF,\n    SF,\n    x,\n    y,\n  );\n\n  /* istanbul ignore else @preserve */\n  if (typeof distance === \"number\") {\n    const length = arcLength(rx, ry, endAngle - startAngle);\n    if (distance <= 0) {\n      point = { x: x1, y: y1 };\n    } else if (distance >= length) {\n      point = { x, y };\n    } else {\n      /* istanbul ignore next @preserve */\n      if (x1 === x && y1 === y) {\n        return { x, y };\n      }\n      /* istanbul ignore next @preserve */\n      if (rx === 0 || ry === 0) {\n        return getPointAtLineLength(x1, y1, x, y, distance);\n      }\n      const { PI, cos, sin } = Math;\n      const sweepAngle = endAngle - startAngle;\n      const xRot = ((angle % 360) + 360) % 360;\n      const xRotRad = xRot * (PI / 180);\n      const alpha = startAngle + sweepAngle * (distance / length);\n      const ellipseComponentX = rx * cos(alpha);\n      const ellipseComponentY = ry * sin(alpha);\n\n      point = {\n        x: cos(xRotRad) * ellipseComponentX - sin(xRotRad) * ellipseComponentY +\n          center.x,\n        y: sin(xRotRad) * ellipseComponentX + cos(xRotRad) * ellipseComponentY +\n          center.y,\n      };\n    }\n  }\n\n  return point;\n};\n\n/**\n * Returns the extrema for an Arc segment in the following format:\n * [MIN_X, MIN_Y, MAX_X, MAX_Y]\n *\n * @see https://github.com/herrstrietzel/svg-pathdata-getbbox\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param RX the radius on X axis\n * @param RY the radius on Y axis\n * @param angle the ellipse rotation in degrees\n * @param LAF the large arc flag\n * @param SF the sweep flag\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @returns the extrema of the Arc segment\n */\nconst getArcBBox = (\n  x1: number,\n  y1: number,\n  RX: number,\n  RY: number,\n  angle: number,\n  LAF: number,\n  SF: number,\n  x: number,\n  y: number,\n) => {\n  const { center, rx, ry, startAngle, endAngle } = getArcProps(\n    x1,\n    y1,\n    RX,\n    RY,\n    angle,\n    LAF,\n    SF,\n    x,\n    y,\n  );\n  const deltaAngle = endAngle - startAngle;\n  const { min, max, tan, atan2, PI } = Math;\n\n  // circle/elipse center coordinates\n  const { x: cx, y: cy } = center;\n\n  // rotation to radians\n  const alpha = (angle * PI) / 180;\n  const tangent = tan(alpha);\n\n  /**\n   * find min/max from zeroes of directional derivative along x and y\n   * along x axis\n   */\n  const theta = atan2(-ry * tangent, rx);\n  const angle1 = theta;\n  const angle2 = theta + PI;\n  const angle3 = atan2(ry, rx * tangent);\n  const angle4 = angle3 + PI;\n  const xArray = [x];\n  const yArray = [y];\n\n  // inner bounding box\n  let xMin = min(x1, x);\n  let xMax = max(x1, x);\n  let yMin = min(y1, y);\n  let yMax = max(y1, y);\n\n  // on path point close after start\n  const angleAfterStart = endAngle - deltaAngle * 0.00001;\n  const pP2 = arcPoint(cx, cy, rx, ry, alpha, angleAfterStart);\n\n  // on path point close before end\n  const angleBeforeEnd = endAngle - deltaAngle * 0.99999;\n  const pP3 = arcPoint(cx, cy, rx, ry, alpha, angleBeforeEnd);\n\n  /**\n   * expected extremes\n   * if leaving inner bounding box\n   * (between segment start and end point)\n   * otherwise exclude elliptic extreme points\n   */\n\n  // right\n  if (pP2[0] > xMax || pP3[0] > xMax) {\n    // get point for this theta\n    const p1 = arcPoint(cx, cy, rx, ry, alpha, angle1);\n    xArray.push(p1[0]);\n    yArray.push(p1[1]);\n  }\n\n  // left\n  if (pP2[0] < xMin || pP3[0] < xMin) {\n    // get anti-symmetric point\n    const p2 = arcPoint(cx, cy, rx, ry, alpha, angle2);\n    xArray.push(p2[0]);\n    yArray.push(p2[1]);\n  }\n\n  // top\n  if (pP2[1] < yMin || pP3[1] < yMin) {\n    // get anti-symmetric point\n    const p4 = arcPoint(cx, cy, rx, ry, alpha, angle4);\n    xArray.push(p4[0]);\n    yArray.push(p4[1]);\n  }\n\n  // bottom\n  if (pP2[1] > yMax || pP3[1] > yMax) {\n    // get point for this theta\n    const p3 = arcPoint(cx, cy, rx, ry, alpha, angle3);\n    xArray.push(p3[0]);\n    yArray.push(p3[1]);\n  }\n\n  xMin = min.apply([], xArray);\n  yMin = min.apply([], yArray);\n  xMax = max.apply([], xArray);\n  yMax = max.apply([], yArray);\n\n  return [xMin, yMin, xMax, yMax] as [number, number, number, number];\n};\n\nexport {\n  angleBetween,\n  arcLength,\n  arcPoint,\n  getArcBBox,\n  getArcLength,\n  getArcProps,\n  getPointAtArcLength,\n};\n","import midPoint from \"./midPoint\";\nimport distanceSquareRoot from \"./distanceSquareRoot\";\n\n/**\n * Returns length for line segments (MoveTo, LineTo).\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @returns the line segment length\n */\nconst getLineLength = (x1: number, y1: number, x2: number, y2: number) => {\n  return distanceSquareRoot([x1, y1], [x2, y2]);\n};\n\n/**\n * Returns a point along the line segments (MoveTo, LineTo).\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @param distance the distance to point in [0-1] range\n * @returns the point at length\n */\nconst getPointAtLineLength = (\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  distance?: number,\n) => {\n  let point = { x: x1, y: y1 };\n\n  /* istanbul ignore else @preserve */\n  if (typeof distance === \"number\") {\n    const length = distanceSquareRoot([x1, y1], [x2, y2]);\n    if (distance <= 0) {\n      point = { x: x1, y: y1 };\n    } else if (distance >= length) {\n      point = { x: x2, y: y2 };\n    } else {\n      const [x, y] = midPoint([x1, y1], [x2, y2], distance / length);\n      point = { x, y };\n    }\n  }\n  return point;\n};\n\n/**\n * Returns bounding box for line segments (MoveTo, LineTo).\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @param distance the distance to point in [0-1] range\n * @returns the extrema for line segments\n */\nconst getLineBBox = (x1: number, y1: number, x2: number, y2: number) => {\n  const { min, max } = Math;\n\n  return [min(x1, x2), min(y1, y2), max(x1, x2), max(y1, y2)] as [\n    number,\n    number,\n    number,\n    number,\n  ];\n};\n\nexport { getLineBBox, getLineLength, getPointAtLineLength };\n","import { PointTuple } from \"../types\";\n\n/**\n * Returns the coordinates of a specified distance\n * ratio between two points.\n *\n * @param a the first point coordinates\n * @param b the second point coordinates\n * @param t the ratio\n * @returns the midpoint coordinates\n */\nconst midPoint = (a: PointTuple, b: PointTuple, t: number): PointTuple => {\n  const [ax, ay] = a;\n  const [bx, by] = b;\n  return [ax + (bx - ax) * t, ay + (by - ay) * t];\n};\n\nexport default midPoint;\n","import { type PointTuple } from \"../types\";\n\n/**\n * Returns the square root of the distance\n * between two given points.\n *\n * @param a the first point coordinates\n * @param b the second point coordinates\n * @returns the distance value\n */\nconst distanceSquareRoot = (a: PointTuple, b: PointTuple) => {\n  return Math.sqrt(\n    (a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1]),\n  );\n};\n\nexport default distanceSquareRoot;\n","import type {\n  CubicCoordinates,\n  CubicPoints,\n  DeriveCallback,\n  DerivedCubicPoints,\n  DerivedPoint,\n  DerivedQuadPoints,\n  PointTuple,\n  QuadCoordinates,\n  QuadPoints,\n} from \"../types\";\n\n/**\n * Tools from bezier.js by Mike 'Pomax' Kamermans\n * @see https://github.com/Pomax/bezierjs\n */\n\nconst Tvalues = [\n  -0.0640568928626056260850430826247450385909,\n  0.0640568928626056260850430826247450385909,\n  -0.1911188674736163091586398207570696318404,\n  0.1911188674736163091586398207570696318404,\n  -0.3150426796961633743867932913198102407864,\n  0.3150426796961633743867932913198102407864,\n  -0.4337935076260451384870842319133497124524,\n  0.4337935076260451384870842319133497124524,\n  -0.5454214713888395356583756172183723700107,\n  0.5454214713888395356583756172183723700107,\n  -0.6480936519369755692524957869107476266696,\n  0.6480936519369755692524957869107476266696,\n  -0.7401241915785543642438281030999784255232,\n  0.7401241915785543642438281030999784255232,\n  -0.8200019859739029219539498726697452080761,\n  0.8200019859739029219539498726697452080761,\n  -0.8864155270044010342131543419821967550873,\n  0.8864155270044010342131543419821967550873,\n  -0.9382745520027327585236490017087214496548,\n  0.9382745520027327585236490017087214496548,\n  -0.9747285559713094981983919930081690617411,\n  0.9747285559713094981983919930081690617411,\n  -0.9951872199970213601799974097007368118745,\n  0.9951872199970213601799974097007368118745,\n];\n\nconst Cvalues = [\n  0.1279381953467521569740561652246953718517,\n  0.1279381953467521569740561652246953718517,\n  0.1258374563468282961213753825111836887264,\n  0.1258374563468282961213753825111836887264,\n  0.121670472927803391204463153476262425607,\n  0.121670472927803391204463153476262425607,\n  0.1155056680537256013533444839067835598622,\n  0.1155056680537256013533444839067835598622,\n  0.1074442701159656347825773424466062227946,\n  0.1074442701159656347825773424466062227946,\n  0.0976186521041138882698806644642471544279,\n  0.0976186521041138882698806644642471544279,\n  0.086190161531953275917185202983742667185,\n  0.086190161531953275917185202983742667185,\n  0.0733464814110803057340336152531165181193,\n  0.0733464814110803057340336152531165181193,\n  0.0592985849154367807463677585001085845412,\n  0.0592985849154367807463677585001085845412,\n  0.0442774388174198061686027482113382288593,\n  0.0442774388174198061686027482113382288593,\n  0.0285313886289336631813078159518782864491,\n  0.0285313886289336631813078159518782864491,\n  0.0123412297999871995468056670700372915759,\n  0.0123412297999871995468056670700372915759,\n];\n\n/**\n * @param points\n * @returns\n */\nconst deriveBezier = (points: QuadPoints | CubicPoints) => {\n  const dpoints = [] as (DerivedCubicPoints | DerivedQuadPoints)[];\n  for (let p = points, d = p.length, c = d - 1; d > 1; d -= 1, c -= 1) {\n    const list = [] as unknown as DerivedCubicPoints | DerivedQuadPoints;\n    for (let j = 0; j < c; j += 1) {\n      list.push({\n        x: c * (p[j + 1].x - p[j].x),\n        y: c * (p[j + 1].y - p[j].y),\n        t: 0,\n      });\n    }\n    dpoints.push(list);\n    p = list;\n  }\n  return dpoints;\n};\n\n/**\n * @param points\n * @param t\n */\nconst computeBezier = (\n  points: DerivedQuadPoints | DerivedCubicPoints,\n  t: number,\n) => {\n  // shortcuts\n  /* istanbul ignore next @preserve */\n  if (t === 0) {\n    points[0].t = 0;\n    return points[0];\n  }\n\n  const order = points.length - 1;\n\n  /* istanbul ignore next @preserve */\n  if (t === 1) {\n    points[order].t = 1;\n    return points[order];\n  }\n\n  const mt = 1 - t;\n  let p = points as typeof points | [\n    DerivedPoint,\n    DerivedPoint,\n    DerivedPoint,\n    DerivedPoint,\n  ];\n\n  // constant?\n  /* istanbul ignore next @preserve */\n  if (order === 0) {\n    points[0].t = t;\n    return points[0];\n  }\n\n  // linear?\n  /* istanbul ignore else @preserve */\n  if (order === 1) {\n    return {\n      x: mt * p[0].x + t * p[1].x,\n      y: mt * p[0].y + t * p[1].y,\n      t,\n    };\n  }\n\n  // quadratic/cubic curve?\n  const mt2 = mt * mt;\n  const t2 = t * t;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  /* istanbul ignore else @preserve */\n  if (order === 2) {\n    p = [p[0], p[1], p[2], { x: 0, y: 0 } as DerivedPoint];\n    a = mt2;\n    b = mt * t * 2;\n    c = t2;\n  } else if (order === 3) {\n    a = mt2 * mt;\n    b = mt2 * t * 3;\n    c = mt * t2 * 3;\n    d = t * t2;\n  }\n  return {\n    x: a * p[0].x + b * p[1].x + c * p[2].x + d * p[3].x,\n    y: a * p[0].y + b * p[1].y + c * p[2].y + d * p[3].y,\n    t,\n  };\n};\n\nconst calculateBezier = (derivativeFn: DeriveCallback, t: number) => {\n  const d = derivativeFn(t);\n  const l = d.x * d.x + d.y * d.y;\n\n  return Math.sqrt(l);\n};\n\nconst bezierLength = (derivativeFn: DeriveCallback) => {\n  const z = 0.5;\n  const len = Tvalues.length;\n\n  let sum = 0;\n\n  for (let i = 0, t; i < len; i++) {\n    t = z * Tvalues[i] + z;\n    sum += Cvalues[i] * calculateBezier(derivativeFn, t);\n  }\n  return z * sum;\n};\n\n/**\n * Returns the length of CubicBezier / Quad segment.\n * @param curve cubic / quad bezier segment\n */\nconst getBezierLength = (curve: CubicCoordinates | QuadCoordinates) => {\n  const points = [] as unknown as CubicPoints | QuadPoints;\n  for (let idx = 0, len = curve.length, step = 2; idx < len; idx += step) {\n    points.push({\n      x: curve[idx],\n      y: curve[idx + 1],\n    });\n  }\n  const dpoints = deriveBezier(points);\n  return bezierLength((t: number) => {\n    return computeBezier(dpoints[0], t);\n  });\n};\n\n// Precision for consider cubic polynom as quadratic one\nconst CBEZIER_MINMAX_EPSILON = 0.00000001;\n\n/**\n * Returns the most extreme points in a Quad Bezier segment.\n * @param A an array which consist of X/Y values\n */\n// https://github.com/kpym/SVGPathy/blob/acd1a50c626b36d81969f6e98e8602e128ba4302/lib/box.js#L89\nconst minmaxQ = ([v1, cp, v2]: [number, number, number]) => {\n  const min = Math.min(v1, v2);\n  const max = Math.max(v1, v2);\n\n  /* istanbul ignore next @preserve */\n  if (cp >= v1 ? v2 >= cp : v2 <= cp) {\n    // if no extremum in ]0,1[\n    return [min, max] as PointTuple;\n  }\n\n  // check if the extremum E is min or max\n  const E = (v1 * v2 - cp * cp) / (v1 - 2 * cp + v2);\n  return (E < min ? [E, max] : [min, E]) as PointTuple;\n};\n\n/**\n * Returns the most extreme points in a Cubic Bezier segment.\n * @param A an array which consist of X/Y values\n * @see https://github.com/kpym/SVGPathy/blob/acd1a50c626b36d81969f6e98e8602e128ba4302/lib/box.js#L127\n */\nconst minmaxC = ([v1, cp1, cp2, v2]: [number, number, number, number]) => {\n  const K = v1 - 3 * cp1 + 3 * cp2 - v2;\n\n  // if the polynomial is (almost) quadratic and not cubic\n  /* istanbul ignore next @preserve */\n  if (Math.abs(K) < CBEZIER_MINMAX_EPSILON) {\n    if (v1 === v2 && v1 === cp1) {\n      // no curve, point targeting same location\n      return [v1, v2] as PointTuple;\n    }\n\n    return minmaxQ([v1, -0.5 * v1 + 1.5 * cp1, v1 - 3 * cp1 + 3 * cp2]);\n  }\n\n  // the reduced discriminant of the derivative\n  const T = -v1 * cp2 + v1 * v2 - cp1 * cp2 - cp1 * v2 + cp1 * cp1 + cp2 * cp2;\n\n  // if the polynomial is monotone in [0,1]\n  if (T <= 0) {\n    return [Math.min(v1, v2), Math.max(v1, v2)] as PointTuple;\n  }\n  const S = Math.sqrt(T);\n\n  // potential extrema\n  let min = Math.min(v1, v2);\n  let max = Math.max(v1, v2);\n\n  const L = v1 - 2 * cp1 + cp2;\n  // check local extrema\n  for (let R = (L + S) / K, i = 1; i <= 2; R = (L - S) / K, i++) {\n    // istanbul ignore next @preserve\n    if (R > 0 && R < 1) {\n      // if the extrema is for R in [0,1]\n      const Q = v1 * (1 - R) * (1 - R) * (1 - R) +\n        cp1 * 3 * (1 - R) * (1 - R) * R + cp2 * 3 * (1 - R) * R * R +\n        v2 * R * R * R;\n      if (Q < min) {\n        min = Q;\n      }\n      if (Q > max) {\n        max = Q;\n      }\n    }\n  }\n\n  return [min, max] as PointTuple;\n};\n\nexport {\n  bezierLength,\n  calculateBezier,\n  CBEZIER_MINMAX_EPSILON,\n  computeBezier,\n  Cvalues,\n  deriveBezier,\n  getBezierLength,\n  minmaxC,\n  minmaxQ,\n  Tvalues,\n};\n","import { getBezierLength, minmaxC } from \"./bezier\";\nimport { type CubicCoordinates } from \"../types\";\n\n/**\n * Returns a point at a given length of a CubicBezier segment.\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param c1x the first control point X\n * @param c1y the first control point Y\n * @param c2x the second control point X\n * @param c2y the second control point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @param t a [0-1] ratio\n * @returns the point at cubic-bezier segment length\n */\nconst getPointAtCubicSegmentLength = (\n  [x1, y1, c1x, c1y, c2x, c2y, x2, y2]: CubicCoordinates,\n  t: number,\n) => {\n  const t1 = 1 - t;\n  return {\n    x: t1 ** 3 * x1 + 3 * t1 ** 2 * t * c1x + 3 * t1 * t ** 2 * c2x +\n      t ** 3 * x2,\n    y: t1 ** 3 * y1 + 3 * t1 ** 2 * t * c1y + 3 * t1 * t ** 2 * c2y +\n      t ** 3 * y2,\n  };\n};\n\n/**\n * Returns the length of a CubicBezier segment.\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param c1x the first control point X\n * @param c1y the first control point Y\n * @param c2x the second control point X\n * @param c2y the second control point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @returns the CubicBezier segment length\n */\nconst getCubicLength = (\n  x1: number,\n  y1: number,\n  c1x: number,\n  c1y: number,\n  c2x: number,\n  c2y: number,\n  x2: number,\n  y2: number,\n) => {\n  return getBezierLength([x1, y1, c1x, c1y, c2x, c2y, x2, y2]);\n};\n\n/**\n * Returns the point along a CubicBezier segment at a given distance.\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param c1x the first control point X\n * @param c1y the first control point Y\n * @param c2x the second control point X\n * @param c2y the second control point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @param distance the distance to look at\n * @returns the point at CubicBezier length\n */\nconst getPointAtCubicLength = (\n  x1: number,\n  y1: number,\n  c1x: number,\n  c1y: number,\n  c2x: number,\n  c2y: number,\n  x2: number,\n  y2: number,\n  distance?: number,\n) => {\n  const distanceIsNumber = typeof distance === \"number\";\n  let point = { x: x1, y: y1 };\n  /* istanbul ignore else @preserve */\n  if (distanceIsNumber) {\n    const currentLength = getBezierLength([x1, y1, c1x, c1y, c2x, c2y, x2, y2]);\n    if (distance <= 0) {\n      // first point already defined\n    } else if (distance >= currentLength) {\n      point = { x: x2, y: y2 };\n    } else {\n      point = getPointAtCubicSegmentLength(\n        [x1, y1, c1x, c1y, c2x, c2y, x2, y2],\n        distance / currentLength,\n      );\n    }\n  }\n  return point;\n};\n\n/**\n * Returns the boundig box of a CubicBezier segment in the following format:\n * [MIN_X, MIN_Y, MAX_X, MAX_Y]\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param c1x the first control point X\n * @param c1y the first control point Y\n * @param c2x the second control point X\n * @param c2y the second control point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @returns the extrema of the CubicBezier segment\n */\nconst getCubicBBox = (\n  x1: number,\n  y1: number,\n  c1x: number,\n  c1y: number,\n  c2x: number,\n  c2y: number,\n  x2: number,\n  y2: number,\n) => {\n  const cxMinMax = minmaxC([x1, c1x, c2x, x2]);\n  const cyMinMax = minmaxC([y1, c1y, c2y, y2]);\n\n  return [cxMinMax[0], cyMinMax[0], cxMinMax[1], cyMinMax[1]] as [\n    number,\n    number,\n    number,\n    number,\n  ];\n};\n\nexport {\n  getCubicBBox,\n  getCubicLength,\n  getPointAtCubicLength,\n  getPointAtCubicSegmentLength,\n};\n","import { getBezierLength, minmaxQ } from \"./bezier\";\nimport { type QuadCoordinates } from \"../types\";\n\n/**\n * Returns the {x,y} coordinates of a point at a\n * given length of a quadratic-bezier segment.\n *\n * @see https://github.com/substack/point-at-length\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param cx the control point X\n * @param cy the control point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @param t a [0-1] ratio\n * @returns the requested {x,y} coordinates\n */\nconst getPointAtQuadSegmentLength = (\n  [x1, y1, cx, cy, x2, y2]: QuadCoordinates,\n  t: number,\n) => {\n  const t1 = 1 - t;\n  return {\n    x: t1 ** 2 * x1 + 2 * t1 * t * cx + t ** 2 * x2,\n    y: t1 ** 2 * y1 + 2 * t1 * t * cy + t ** 2 * y2,\n  };\n};\n\n/**\n * Returns the length of a QuadraticBezier segment.\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param cx the control point X\n * @param cy the control point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @returns the QuadraticBezier segment length\n */\nconst getQuadLength = (\n  x1: number,\n  y1: number,\n  cx: number,\n  cy: number,\n  x2: number,\n  y2: number,\n) => {\n  return getBezierLength([x1, y1, cx, cy, x2, y2]);\n};\n\n/**\n * Returns the point along a QuadraticBezier segment at a given distance.\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param cx the control point X\n * @param cy the control point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @param distance the distance to look at\n * @returns the point at QuadraticBezier length\n */\nconst getPointAtQuadLength = (\n  x1: number,\n  y1: number,\n  cx: number,\n  cy: number,\n  x2: number,\n  y2: number,\n  distance?: number,\n) => {\n  const distanceIsNumber = typeof distance === \"number\";\n  let point = { x: x1, y: y1 };\n\n  /* istanbul ignore else @preserve */\n  if (distanceIsNumber) {\n    const currentLength = getBezierLength([x1, y1, cx, cy, x2, y2]);\n    if (distance <= 0) {\n      // first point already defined\n    } else if (distance >= currentLength) {\n      point = { x: x2, y: y2 };\n    } else {\n      point = getPointAtQuadSegmentLength(\n        [x1, y1, cx, cy, x2, y2],\n        distance / currentLength,\n      );\n    }\n  }\n  return point;\n};\n\n/**\n * Returns the boundig box of a QuadraticBezier segment in the following format:\n * [MIN_X, MIN_Y, MAX_X, MAX_Y]\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param cx the control point X\n * @param cy the control point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @returns the extrema of the QuadraticBezier segment\n */\nconst getQuadBBox = (\n  x1: number,\n  y1: number,\n  cx: number,\n  cy: number,\n  x2: number,\n  y2: number,\n) => {\n  const cxMinMax = minmaxQ([x1, cx, x2]);\n  const cyMinMax = minmaxQ([y1, cy, y2]);\n  return [cxMinMax[0], cyMinMax[0], cxMinMax[1], cyMinMax[1]] as [\n    number,\n    number,\n    number,\n    number,\n  ];\n};\n\nexport {\n  getPointAtQuadLength,\n  getPointAtQuadSegmentLength,\n  getQuadBBox,\n  getQuadLength,\n};\n","import distanceSquareRoot from \"./distanceSquareRoot\";\nimport { type PointTuple } from \"../types\";\n\n/**\n * d3-polygon-area\n * https://github.com/d3/d3-polygon\n *\n * Returns the area of a polygon.\n *\n * @param polygon an array of coordinates\n * @returns the polygon area\n */\nconst polygonArea = (polygon: PointTuple[]) => {\n  const n = polygon.length;\n  let i = -1;\n  let a: PointTuple;\n  let b = polygon[n - 1];\n  let area = 0;\n\n  /* eslint-disable-next-line */\n  while (++i < n) {\n    a = b;\n    b = polygon[i];\n    area += a[1] * b[0] - a[0] * b[1];\n  }\n\n  return area / 2;\n};\n\n/**\n * d3-polygon-length\n * https://github.com/d3/d3-polygon\n *\n * Returns the perimeter of a polygon.\n *\n * @param polygon an array of coordinates\n * @returns the polygon length\n */\nconst polygonLength = (polygon: PointTuple[]) => {\n  return polygon.reduce((length, point, i) => {\n    if (i) {\n      return length + distanceSquareRoot(polygon[i - 1], point);\n    }\n    return 0;\n  }, 0);\n};\n\nexport { polygonArea, polygonLength };\n","/** Segment params length */\nconst paramsCount = {\n  a: 7,\n  c: 6,\n  h: 1,\n  l: 2,\n  m: 2,\n  r: 4,\n  q: 4,\n  s: 4,\n  t: 2,\n  v: 1,\n  z: 0,\n};\n\nexport default paramsCount;\n","import paramsCount from \"./paramsCount\";\nimport PathParser from \"./pathParser\";\nimport type { PathCommand, PathSegment, RelativeCommand } from \"../types\";\n\n/**\n * Breaks the parsing of a pathString once a segment is finalized.\n *\n * @param path the `PathParser` instance\n */\nconst finalizeSegment = (path: PathParser) => {\n  let pathCommand = path.pathValue[path.segmentStart] as PathCommand;\n  let relativeCommand = pathCommand.toLowerCase() as RelativeCommand;\n  const { data } = path;\n\n  while (data.length >= paramsCount[relativeCommand]) {\n    // overloaded `moveTo`\n    // https://github.com/rveciana/svg-path-properties/blob/master/src/parse.ts\n    if (relativeCommand === \"m\" && data.length > 2) {\n      path.segments.push(\n        [pathCommand as PathCommand | number].concat(\n          data.splice(0, 2) as number[],\n        ) as PathSegment,\n      );\n      relativeCommand = \"l\";\n      pathCommand = pathCommand === \"m\" ? \"l\" : \"L\";\n    } else {\n      path.segments.push(\n        [pathCommand as PathCommand | number].concat(\n          data.splice(0, paramsCount[relativeCommand]) as number[],\n        ) as PathSegment,\n      );\n    }\n\n    if (!paramsCount[relativeCommand]) {\n      break;\n    }\n  }\n};\nexport default finalizeSegment;\n","const error = \"SVGPathCommander Error\";\nexport default error;\n","import error from \"./error\";\nimport type PathParser from \"./pathParser\";\n\n/**\n * Validates an A (arc-to) specific path command value.\n * Usually a `large-arc-flag` or `sweep-flag`.\n *\n * @param path the `PathParser` instance\n */\nconst scanFlag = (path: PathParser) => {\n  const { index, pathValue } = path;\n  const code = pathValue.charCodeAt(index);\n\n  if (code === 0x30 /* 0 */) {\n    path.param = 0;\n    path.index += 1;\n    return;\n  }\n\n  if (code === 0x31 /* 1 */) {\n    path.param = 1;\n    path.index += 1;\n    return;\n  }\n\n  path.err = `${error}: invalid Arc flag \"${\n    pathValue[index]\n  }\", expecting 0 or 1 at index ${index}`;\n};\n\nexport default scanFlag;\n","import { DigitNumber } from \"../types\";\n\n/**\n * Checks if a character is a digit.\n *\n * @param code the character to check\n * @returns check result\n */\nconst isDigit = (code: number): code is DigitNumber => {\n  return code >= 48 && code <= 57; // 0..9\n};\nexport default isDigit;\n","const invalidPathValue = \"Invalid path value\";\nexport default invalidPathValue;\n","import isDigit from \"./isDigit\";\nimport invalidPathValue from \"./invalidPathValue\";\nimport error from \"./error\";\nimport type PathParser from \"./pathParser\";\n\n/**\n * Validates every character of the path string,\n * every path command, negative numbers or floating point numbers.\n *\n * @param path the `PathParser` instance\n */\nconst scanParam = (path: PathParser) => {\n  const { max, pathValue, index: start } = path;\n  let index = start;\n  let zeroFirst = false;\n  let hasCeiling = false;\n  let hasDecimal = false;\n  let hasDot = false;\n  let ch;\n\n  if (index >= max) {\n    path.err =\n      `${error}: ${invalidPathValue} at index ${index}, \"pathValue\" is missing param`;\n    return;\n  }\n  ch = pathValue.charCodeAt(index);\n\n  if (ch === 0x2b /* + */ || ch === 0x2d /* - */) {\n    index += 1;\n    // ch = (index < max) ? pathValue.charCodeAt(index) : 0;\n    ch = pathValue.charCodeAt(index);\n  }\n\n  // This logic is shamelessly borrowed from Esprima\n  // https://github.com/ariya/esprimas\n  if (!isDigit(ch) && ch !== 0x2e /* . */) {\n    // path.err = 'SvgPath: param should start with 0..9 or `.` (at pos ' + index + ')';\n    path.err = `${error}: ${invalidPathValue} at index ${index}, \"${\n      pathValue[index]\n    }\" is not a number`;\n    return;\n  }\n\n  if (ch !== 0x2e /* . */) {\n    zeroFirst = ch === 0x30 /* 0 */;\n    index += 1;\n\n    ch = pathValue.charCodeAt(index);\n\n    if (zeroFirst && index < max) {\n      // decimal number starts with '0' such as '09' is illegal.\n      if (ch && isDigit(ch)) {\n        // path.err = 'SvgPath: numbers started with `0` such as `09`\n        // are illegal (at pos ' + start + ')';\n        path.err = `${error}: ${invalidPathValue} at index ${start}, \"${\n          pathValue[start]\n        }\" illegal number`;\n        return;\n      }\n    }\n\n    while (index < max && isDigit(pathValue.charCodeAt(index))) {\n      index += 1;\n      hasCeiling = true;\n    }\n\n    ch = pathValue.charCodeAt(index);\n  }\n\n  if (ch === 0x2e /* . */) {\n    hasDot = true;\n    index += 1;\n    while (isDigit(pathValue.charCodeAt(index))) {\n      index += 1;\n      hasDecimal = true;\n    }\n\n    ch = pathValue.charCodeAt(index);\n  }\n\n  if (ch === 0x65 /* e */ || ch === 0x45 /* E */) {\n    if (hasDot && !hasCeiling && !hasDecimal) {\n      path.err = `${error}: ${invalidPathValue} at index ${index}, \"${\n        pathValue[index]\n      }\" invalid float exponent`;\n      return;\n    }\n\n    index += 1;\n\n    ch = pathValue.charCodeAt(index);\n\n    if (ch === 0x2b /* + */ || ch === 0x2d /* - */) {\n      index += 1;\n    }\n    if (index < max && isDigit(pathValue.charCodeAt(index))) {\n      while (index < max && isDigit(pathValue.charCodeAt(index))) {\n        index += 1;\n      }\n    } else {\n      path.err = `${error}: ${invalidPathValue} at index ${index}, \"${\n        pathValue[index]\n      }\" invalid integer exponent`;\n      return;\n    }\n  }\n\n  path.index = index;\n  path.param = +path.pathValue.slice(start, index);\n};\nexport default scanParam;\n","import type { SpaceNumber } from \"../types\";\n\n/**\n * Checks if the character is a space.\n *\n * @param ch the character to check\n * @returns check result\n */\n\nconst isSpace = (ch: number): ch is SpaceNumber => {\n  const allSpaces = [\n    // Special spaces\n    0x1680,\n    0x180e,\n    0x2000,\n    0x2001,\n    0x2002,\n    0x2003,\n    0x2004,\n    0x2005,\n    0x2006,\n    0x2007,\n    0x2008,\n    0x2009,\n    0x200a,\n    0x202f,\n    0x205f,\n    0x3000,\n    0xfeff,\n    // Line terminators\n    0x0a,\n    0x0d,\n    0x2028,\n    0x2029,\n    // White spaces\n    0x20,\n    0x09,\n    0x0b,\n    0x0c,\n    0xa0,\n  ];\n\n  return allSpaces.includes(ch);\n};\nexport default isSpace;\n","import isSpace from \"./isSpace\";\nimport type PathParser from \"./pathParser\";\n\n/**\n * Points the parser to the next character in the\n * path string every time it encounters any kind of\n * space character.\n *\n * @param path the `PathParser` instance\n */\nconst skipSpaces = (path: PathParser) => {\n  const { pathValue, max } = path;\n  while (path.index < max && isSpace(pathValue.charCodeAt(path.index))) {\n    path.index += 1;\n  }\n};\nexport default skipSpaces;\n","import type { PathCommandNumber } from \"../types\";\n\n/**\n * Checks if the character is a path command.\n *\n * @param code the character to check\n * @returns check result\n */\nconst isPathCommand = (code: number): code is PathCommandNumber => {\n  // eslint-disable-next-line no-bitwise -- Impossible to satisfy\n  switch (code | 0x20) {\n    case 0x6d /* m */:\n    case 0x7a /* z */:\n    case 0x6c /* l */:\n    case 0x68 /* h */:\n    case 0x76 /* v */:\n    case 0x63 /* c */:\n    case 0x73 /* s */:\n    case 0x71 /* q */:\n    case 0x74 /* t */:\n    case 0x61 /* a */:\n      // case 0x72/* r */:\n      return true;\n    default:\n      return false;\n  }\n};\nexport default isPathCommand;\n","import isDigit from \"./isDigit\";\nimport type { DigitNumber } from \"../types\";\n\n/**\n * Checks if the character is or belongs to a number.\n * [0-9]|+|-|.\n *\n * @param code the character to check\n * @returns check result\n */\nconst isDigitStart = (\n  code: number,\n): code is DigitNumber | 0x2b | 0x2d | 0x2e => {\n  return isDigit(code) /* 0..9 */ || code === 0x2b /* + */ ||\n    code === 0x2d /* - */ || code === 0x2e; /* . */\n};\nexport default isDigitStart;\n","/**\n * Checks if the character is an A (arc-to) path command.\n *\n * @param code the character to check\n * @returns check result\n */\nconst isArcCommand = (code: number): code is 0x61 => {\n  // eslint-disable-next-line no-bitwise -- Impossible to satisfy\n  return (code | 0x20) === 0x61;\n};\nexport default isArcCommand;\n","/**\n * Checks if the character is a MoveTo command.\n *\n * @param code the character to check\n * @returns check result\n */\nconst isMoveCommand = (code: number): code is 0x6d | 0x4d => {\n  // eslint-disable-next-line no-bitwise -- Impossible to satisfy\n  switch (code | 0x20) {\n    case 0x6d /* m */:\n    case 0x4d /* M */:\n      return true;\n    default:\n      return false;\n  }\n};\nexport default isMoveCommand;\n","import finalizeSegment from \"./finalizeSegment\";\nimport paramCounts from \"./paramsCount\";\nimport scanFlag from \"./scanFlag\";\nimport scanParam from \"./scanParam\";\nimport skipSpaces from \"./skipSpaces\";\nimport isPathCommand from \"./isPathCommand\";\nimport isDigitStart from \"./isDigitStart\";\nimport isArcCommand from \"./isArcCommand\";\nimport isMoveCommand from \"./isMoveCommand\";\nimport invalidPathValue from \"./invalidPathValue\";\nimport error from \"./error\";\n\nimport type PathParser from \"./pathParser\";\nimport type { PathSegment, RelativeCommand } from \"../types\";\n\n/**\n * Scans every character in the path string to determine\n * where a segment starts and where it ends.\n *\n * @param path the `PathParser` instance\n */\nconst scanSegment = (path: PathParser) => {\n  const { max, pathValue, index, segments } = path;\n  const cmdCode = pathValue.charCodeAt(index);\n  const reqParams =\n    paramCounts[pathValue[index].toLowerCase() as RelativeCommand];\n\n  path.segmentStart = index;\n\n  // segments always start with a path command\n  if (!isPathCommand(cmdCode)) {\n    path.err = `${error}: ${invalidPathValue} \"${\n      pathValue[index]\n    }\" is not a path command at index ${index}`;\n    return;\n  }\n\n  // after a Z segment, we only expect a MoveTo path command\n  const lastSegment = segments[segments.length - 1] as PathSegment | undefined;\n  if (\n    !isMoveCommand(cmdCode) && lastSegment?.[0]?.toLocaleLowerCase() === \"z\"\n  ) {\n    path.err = `${error}: ${invalidPathValue} \"${\n      pathValue[index]\n    }\" is not a MoveTo path command at index ${index}`;\n    return;\n  }\n\n  path.index += 1;\n  skipSpaces(path);\n\n  path.data = [];\n\n  if (!reqParams) {\n    // Z\n    finalizeSegment(path);\n    return;\n  }\n\n  for (;;) {\n    for (let i = reqParams; i > 0; i -= 1) {\n      if (isArcCommand(cmdCode) && (i === 3 || i === 4)) scanFlag(path);\n      else scanParam(path);\n\n      if (path.err.length) {\n        return;\n      }\n      path.data.push(path.param);\n\n      skipSpaces(path);\n\n      // after ',' param is mandatory\n      if (\n        path.index < max && pathValue.charCodeAt(path.index) === 0x2c /* , */\n      ) {\n        path.index += 1;\n        skipSpaces(path);\n      }\n    }\n\n    if (path.index >= path.max) {\n      break;\n    }\n\n    // Stop on next segment\n    if (!isDigitStart(pathValue.charCodeAt(path.index))) {\n      break;\n    }\n  }\n\n  finalizeSegment(path);\n};\nexport default scanSegment;\n","import type { PathArray, PathSegment } from \"../types\";\n\n/**\n * The `PathParser` is used by the `parsePathString` static method\n * to generate a `pathArray`.\n *\n * @param pathString\n */\nexport default class PathParser {\n  declare segments: PathArray | PathSegment[];\n  declare pathValue: string;\n  declare max: number;\n  declare index: number;\n  declare param: number;\n  declare segmentStart: number;\n  declare data: (string | number)[];\n  declare err: string;\n\n  constructor(pathString: string) {\n    this.segments = [];\n    this.pathValue = pathString;\n    this.max = pathString.length;\n    this.index = 0;\n    this.param = 0.0;\n    this.segmentStart = 0;\n    this.data = [];\n    this.err = \"\";\n  }\n}\n","import scanSegment from \"./scanSegment\";\nimport skipSpaces from \"./skipSpaces\";\nimport PathParser from \"./pathParser\";\nimport type { PathArray } from \"../types\";\n\n/**\n * Parses a path string value and returns an array\n * of segments we like to call `pathArray`.\n *\n * @param pathInput the string to be parsed\n * @returns the resulted `pathArray` or error string\n */\nconst parsePathString = <T extends PathArray>(pathInput: string | T) => {\n  if (typeof pathInput !== \"string\") {\n    return pathInput.slice(0) as typeof pathInput;\n  }\n\n  const path = new PathParser(pathInput);\n\n  skipSpaces(path);\n\n  while (path.index < path.max && !path.err.length) {\n    scanSegment(path);\n  }\n\n  // handle valid paths first\n  // handle errors second\n  if (!path.err.length) {\n    if (path.segments.length) {\n      /**\n       * force absolute first M\n       * getPathBBox calculation requires first segment to be absolute\n       * @see https://github.com/thednp/svg-path-commander/pull/49\n       */\n      path.segments[0][0] = \"M\";\n    }\n  } else {\n    throw TypeError(path.err);\n  }\n\n  return path.segments as PathArray;\n};\n\nexport default parsePathString;\n","import type {\n  AbsoluteCommand,\n  AbsoluteSegment,\n  ASegment,\n  CSegment,\n  HSegment,\n  LSegment,\n  MSegment,\n  PathSegment,\n  QSegment,\n  SSegment,\n  TSegment,\n  VSegment,\n} from \"../types\";\n\n/**\n * Returns an absolute segment of a `PathArray` object.\n *\n * @param segment the segment object\n * @param index the segment index\n * @param lastX the last known X value\n * @param lastY the last known Y value\n * @returns the absolute segment\n */\nconst absolutizeSegment = (\n  segment: PathSegment,\n  index: number,\n  lastX: number,\n  lastY: number,\n) => {\n  const [pathCommand] = segment;\n  const absCommand = pathCommand.toUpperCase() as AbsoluteCommand;\n  const isAbsolute = absCommand === pathCommand;\n\n  /* istanbul ignore else @preserve */\n  if (index === 0 || isAbsolute) return segment as MSegment | AbsoluteSegment;\n  // const values = segment.slice(1) as number[];\n  if (absCommand === \"A\") {\n    return [\n      absCommand,\n      segment[1],\n      segment[2],\n      segment[3],\n      segment[4],\n      segment[5],\n      (segment as ASegment)[6] + lastX,\n      (segment as ASegment)[7] + lastY,\n    ] as ASegment;\n  } else if (absCommand === \"V\") {\n    return [absCommand, (segment as VSegment)[1] + lastY] as VSegment;\n  } else if (absCommand === \"H\") {\n    return [absCommand, (segment as HSegment)[1] + lastX] as HSegment;\n  } else if (absCommand === \"L\") {\n    return [\n      absCommand,\n      (segment as LSegment)[1] + lastX,\n      (segment as LSegment)[2] + lastY,\n    ] as LSegment;\n  } else {\n    // use brakets for `eslint: no-case-declaration`\n    // https://stackoverflow.com/a/50753272/803358\n    const absValues = [] as number[];\n    const seglen = segment.length;\n    for (let j = 1; j < seglen; j += 1) {\n      absValues.push((segment[j] as number) + (j % 2 ? lastX : lastY));\n    }\n    // for c, s, q, t\n    return [absCommand as typeof absCommand | number].concat(absValues) as\n      | MSegment\n      | QSegment\n      | TSegment\n      | SSegment\n      | CSegment;\n  }\n};\nexport default absolutizeSegment;\n","// import paramsParser from '../parser/paramsParser';\nimport type {\n  AbsoluteCommand,\n  IteratorCallback,\n  PathArray,\n  PathCommand,\n  PathSegment,\n} from \"../types\";\n\nconst iterate = <T extends PathArray>(\n  path: PathArray,\n  iterator: IteratorCallback,\n) => {\n  let pathLen = path.length;\n  let segment: PathSegment;\n  let pathCommand = \"M\" as PathCommand;\n  let absCommand = \"M\" as AbsoluteCommand;\n  let isRelative = false;\n  let x = 0;\n  let y = 0;\n  let mx = 0;\n  let my = 0;\n  let segLen = 0;\n\n  for (let i = 0; i < pathLen; i += 1) {\n    segment = path[i];\n    [pathCommand] = segment;\n    segLen = segment.length;\n    absCommand = pathCommand.toUpperCase() as AbsoluteCommand;\n    isRelative = absCommand !== pathCommand;\n\n    const iteratorResult = iterator(segment, i, x, y);\n    // some methods like getPointAtLength would like to break\n    // when task is complete\n    if (iteratorResult === false) {\n      break;\n    }\n\n    // segment = path[i];\n    if (absCommand === \"Z\") {\n      x = mx;\n      y = my;\n    } else if (absCommand === \"H\") {\n      x = (segment[1] as number) + (isRelative ? x : 0);\n    } else if (absCommand === \"V\") {\n      y = (segment[1] as number) + (isRelative ? y : 0);\n    } else {\n      x = (segment[segLen - 2] as number) + (isRelative ? x : 0);\n      y = (segment[segLen - 1] as number) + (isRelative ? y : 0);\n\n      if (absCommand === \"M\") {\n        mx = x;\n        my = y;\n      }\n    }\n\n    if (iteratorResult) {\n      path[i] = iteratorResult;\n      if (iteratorResult[0] === \"C\") {\n        pathLen = path.length;\n      }\n    }\n  }\n  return path as T;\n};\n\nexport default iterate;\n","import parsePathString from \"../parser/parsePathString\";\nimport absolutizeSegment from \"../process/absolutizeSegment\";\nimport type { AbsoluteArray, PathArray } from \"../types\";\nimport iterate from \"../process/iterate\";\n\n/**\n * Parses a path string value or object and returns an array\n * of segments, all converted to absolute values.\n *\n * @param pathInput the path string | object\n * @returns the resulted `pathArray` with absolute values\n */\nconst pathToAbsolute = (pathInput: string | PathArray) => {\n  const path = parsePathString(pathInput);\n\n  return iterate<AbsoluteArray>(path, absolutizeSegment);\n};\nexport default pathToAbsolute;\n","import type {\n  aSegment,\n  cSegment,\n  hSegment,\n  lSegment,\n  MSegment,\n  PathSegment,\n  qSegment,\n  RelativeCommand,\n  RelativeSegment,\n  sSegment,\n  tSegment,\n  vSegment,\n} from \"../types\";\n\n/**\n * Returns a relative segment of a `PathArray` object.\n *\n * @param segment the segment object\n * @param index the segment index\n * @param lastX the last known X value\n * @param lastY the last known Y value\n * @returns the relative segment\n */\nconst relativizeSegment = (\n  segment: PathSegment,\n  index: number,\n  lastX: number,\n  lastY: number,\n) => {\n  const [pathCommand] = segment;\n  const relCommand = pathCommand.toLowerCase() as RelativeCommand;\n  const isRelative = pathCommand === relCommand;\n\n  /* istanbul ignore else @preserve */\n  if (index === 0 || isRelative) return segment as MSegment | RelativeSegment;\n\n  if (relCommand === \"a\") {\n    return [\n      relCommand,\n      segment[1],\n      segment[2],\n      segment[3],\n      segment[4],\n      segment[5],\n      (segment as aSegment)[6] - lastX,\n      (segment as aSegment)[7] - lastY,\n    ] as aSegment;\n  } else if (relCommand === \"v\") {\n    return [relCommand, (segment as vSegment)[1] - lastY] as vSegment;\n  } else if (relCommand === \"h\") {\n    return [relCommand, (segment as hSegment)[1] - lastX] as hSegment;\n  } else if (relCommand === \"l\") {\n    return [\n      relCommand,\n      (segment as lSegment)[1] - lastX,\n      (segment as lSegment)[2] - lastY,\n    ] as lSegment;\n  } else {\n    // use brakets for `eslint: no-case-declaration`\n    // https://stackoverflow.com/a/50753272/803358\n    const relValues = [] as number[];\n    const seglen = segment.length;\n    for (let j = 1; j < seglen; j += 1) {\n      relValues.push((segment[j] as number) - (j % 2 ? lastX : lastY));\n    }\n    // for c, s, q, t\n    return [relCommand as RelativeCommand | number].concat(relValues) as\n      | qSegment\n      | tSegment\n      | sSegment\n      | cSegment;\n  }\n};\n\nexport default relativizeSegment;\n","import type { PathArray, RelativeArray } from \"../types\";\nimport parsePathString from \"../parser/parsePathString\";\nimport iterate from \"../process/iterate\";\nimport relativizeSegment from \"../process/relativizeSegment\";\n\n/**\n * Parses a path string value or object and returns an array\n * of segments, all converted to relative values.\n *\n * @param pathInput the path string | object\n * @returns the resulted `pathArray` with relative values\n */\nconst pathToRelative = (pathInput: string | PathArray): RelativeArray => {\n  const path = parsePathString(pathInput);\n\n  return iterate<RelativeArray>(path, relativizeSegment);\n};\nexport default pathToRelative;\n","/**\n * Returns an {x,y} vector rotated by a given\n * angle in radian.\n *\n * @param x the initial vector x\n * @param y the initial vector y\n * @param rad the radian vector angle\n * @returns the rotated vector\n */\nconst rotateVector = (\n  x: number,\n  y: number,\n  rad: number,\n): { x: number; y: number } => {\n  const { sin, cos } = Math;\n  const X = x * cos(rad) - y * sin(rad);\n  const Y = x * sin(rad) + y * cos(rad);\n  return { x: X, y: Y };\n};\n\nexport default rotateVector;\n","import rotateVector from \"../math/rotateVector\";\n\n/**\n * Converts A (arc-to) segments to C (cubic-bezier-to).\n *\n * For more information of where this math came from visit:\n * http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n *\n * @param X1 the starting x position\n * @param Y1 the starting y position\n * @param RX x-radius of the arc\n * @param RY y-radius of the arc\n * @param angle x-axis-rotation of the arc\n * @param LAF large-arc-flag of the arc\n * @param SF sweep-flag of the arc\n * @param X2 the ending x position\n * @param Y2 the ending y position\n * @param recursive the parameters needed to split arc into 2 segments\n * @return the resulting cubic-bezier segment(s)\n */\nconst arcToCubic = (\n  X1: number,\n  Y1: number,\n  RX: number,\n  RY: number,\n  angle: number,\n  LAF: number,\n  SF: number,\n  X2: number,\n  Y2: number,\n  recursive?: [number, number, number, number],\n): number[] => {\n  let x1 = X1;\n  let y1 = Y1;\n  let rx = RX;\n  let ry = RY;\n  let x2 = X2;\n  let y2 = Y2;\n  // for more information of where this Math came from visit:\n  // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n  const d120 = (Math.PI * 120) / 180;\n\n  const rad = (Math.PI / 180) * (+angle || 0);\n  let res = [] as number[];\n  let xy;\n  let f1;\n  let f2;\n  let cx;\n  let cy;\n\n  if (!recursive) {\n    xy = rotateVector(x1, y1, -rad);\n    x1 = xy.x;\n    y1 = xy.y;\n    xy = rotateVector(x2, y2, -rad);\n    x2 = xy.x;\n    y2 = xy.y;\n\n    const x = (x1 - x2) / 2;\n    const y = (y1 - y2) / 2;\n    let h = (x * x) / (rx * rx) + (y * y) / (ry * ry);\n    if (h > 1) {\n      h = Math.sqrt(h);\n      rx *= h;\n      ry *= h;\n    }\n    const rx2 = rx * rx;\n    const ry2 = ry * ry;\n\n    const k = (LAF === SF ? -1 : 1) *\n      Math.sqrt(\n        Math.abs(\n          (rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x),\n        ),\n      );\n\n    cx = (k * rx * y) / ry + (x1 + x2) / 2;\n    cy = (k * -ry * x) / rx + (y1 + y2) / 2;\n    // eslint-disable-next-line no-bitwise -- Impossible to satisfy no-bitwise\n    f1 = Math.asin(((((y1 - cy) / ry) * 10 ** 9) >> 0) / 10 ** 9);\n    // eslint-disable-next-line no-bitwise -- Impossible to satisfy no-bitwise\n    f2 = Math.asin(((((y2 - cy) / ry) * 10 ** 9) >> 0) / 10 ** 9);\n\n    f1 = x1 < cx ? Math.PI - f1 : f1;\n    f2 = x2 < cx ? Math.PI - f2 : f2;\n    if (f1 < 0) f1 = Math.PI * 2 + f1;\n    if (f2 < 0) f2 = Math.PI * 2 + f2;\n    if (SF && f1 > f2) {\n      f1 -= Math.PI * 2;\n    }\n    if (!SF && f2 > f1) {\n      f2 -= Math.PI * 2;\n    }\n  } else {\n    [f1, f2, cx, cy] = recursive;\n  }\n  let df = f2 - f1;\n  if (Math.abs(df) > d120) {\n    const f2old = f2;\n    const x2old = x2;\n    const y2old = y2;\n    f2 = f1 + d120 * (SF && f2 > f1 ? 1 : -1);\n    x2 = cx + rx * Math.cos(f2);\n    y2 = cy + ry * Math.sin(f2);\n    res = arcToCubic(x2, y2, rx, ry, angle, 0, SF, x2old, y2old, [\n      f2,\n      f2old,\n      cx,\n      cy,\n    ]);\n  }\n  df = f2 - f1;\n  const c1 = Math.cos(f1);\n  const s1 = Math.sin(f1);\n  const c2 = Math.cos(f2);\n  const s2 = Math.sin(f2);\n  const t = Math.tan(df / 4);\n  const hx = (4 / 3) * rx * t;\n  const hy = (4 / 3) * ry * t;\n  const m1 = [x1, y1];\n  const m2 = [x1 + hx * s1, y1 - hy * c1];\n  const m3 = [x2 + hx * s2, y2 - hy * c2];\n  const m4 = [x2, y2];\n  m2[0] = 2 * m1[0] - m2[0];\n  m2[1] = 2 * m1[1] - m2[1];\n  if (recursive) {\n    return [m2[0], m2[1], m3[0], m3[1], m4[0], m4[1]].concat(res);\n  }\n  res = [m2[0], m2[1], m3[0], m3[1], m4[0], m4[1]].concat(res);\n  const newres = [];\n  for (let i = 0, ii = res.length; i < ii; i += 1) {\n    newres[i] = i % 2\n      ? rotateVector(res[i - 1], res[i], rad).y\n      : rotateVector(res[i], res[i + 1], rad).x;\n  }\n  return newres;\n};\nexport default arcToCubic;\n","/**\n * Converts a Q (quadratic-bezier) segment to C (cubic-bezier).\n *\n * @param x1 curve start x\n * @param y1 curve start y\n * @param qx control point x\n * @param qy control point y\n * @param x2 curve end x\n * @param y2 curve end y\n * @returns the cubic-bezier segment\n */\nconst quadToCubic = (\n  x1: number,\n  y1: number,\n  qx: number,\n  qy: number,\n  x2: number,\n  y2: number,\n): [number, number, number, number, number, number] => {\n  const r13 = 1 / 3;\n  const r23 = 2 / 3;\n  return [\n    r13 * x1 + r23 * qx, // cpx1\n    r13 * y1 + r23 * qy, // cpy1\n    r13 * x2 + r23 * qx, // cpx2\n    r13 * y2 + r23 * qy, // cpy2\n    x2,\n    y2, // x,y\n  ];\n};\nexport default quadToCubic;\n","import midPoint from \"../math/midPoint\";\n\n/**\n * Converts an L (line-to) segment to C (cubic-bezier).\n *\n * @param x1 line start x\n * @param y1 line start y\n * @param x2 line end x\n * @param y2 line end y\n * @returns the cubic-bezier segment\n */\nconst lineToCubic = (x1: number, y1: number, x2: number, y2: number) => {\n  const c1 = midPoint([x1, y1], [x2, y2], 1.0 / 3.0);\n  const c2 = midPoint([x1, y1], [x2, y2], 2.0 / 3.0);\n  return [c1[0], c1[1], c2[0], c2[1], x2, y2];\n};\nexport default lineToCubic;\n","import arcToCubic from \"./arcToCubic\";\nimport quadToCubic from \"./quadToCubic\";\nimport lineToCubic from \"./lineToCubic\";\nimport type { CSegment, MSegment, PathSegment } from \"../types\";\nimport type { ParserParams } from \"../interface\";\n\n/**\n * Converts any segment to C (cubic-bezier).\n *\n * @param segment the source segment\n * @param params the source segment parameters\n * @returns the cubic-bezier segment\n */\nconst segmentToCubic = (segment: PathSegment, params: ParserParams) => {\n  const [pathCommand] = segment;\n  const values = segment.slice(1).map(Number);\n  const [x, y] = values;\n  // let args;\n  const { x1: px1, y1: py1, x: px, y: py } = params;\n\n  if (!\"TQ\".includes(pathCommand)) {\n    params.qx = null;\n    params.qy = null;\n  }\n\n  if (pathCommand === \"M\") {\n    params.x = x;\n    params.y = y;\n    return segment;\n  } else if (pathCommand === \"A\") {\n    return [\"C\" as string | number].concat(\n      arcToCubic(\n        px1,\n        py1,\n        values[0],\n        values[1],\n        values[2],\n        values[3],\n        values[4],\n        values[5],\n        values[6],\n      ),\n    ) as CSegment;\n  } else if (pathCommand === \"Q\") {\n    params.qx = x;\n    params.qy = y;\n    return [\"C\" as string | number].concat(\n      quadToCubic(px1, py1, values[0], values[1], values[2], values[3]),\n    ) as CSegment;\n  } else if (pathCommand === \"L\") {\n    return [\"C\" as string | number].concat(\n      lineToCubic(px1, py1, x, y),\n    ) as CSegment;\n  } else if (pathCommand === \"Z\") {\n    return [\"C\" as string | number].concat(\n      lineToCubic(px1, py1, px, py),\n    ) as CSegment;\n  }\n\n  return segment as MSegment | CSegment;\n};\nexport default segmentToCubic;\n","import type { ParserParams } from \"../interface\";\nimport type {\n  ASegment,\n  CSegment,\n  HSegment,\n  LSegment,\n  MSegment,\n  NormalSegment,\n  PathCommand,\n  PathSegment,\n  PointTuple,\n  QSegment,\n  VSegment,\n} from \"../types\";\n\n/**\n * Normalizes a single segment of a `pathArray` object.\n *\n * @param segment the segment object\n * @param params the normalization parameters\n * @returns the normalized segment\n */\nconst normalizeSegment = (segment: PathSegment, params: ParserParams) => {\n  const [pathCommand] = segment;\n  const absCommand = pathCommand.toUpperCase();\n  const isRelative = pathCommand !== absCommand;\n  const { x1: px1, y1: py1, x2: px2, y2: py2, x, y } = params;\n  const values = segment.slice(1) as number[];\n  let absValues = values.map((n, j) => n + (isRelative ? (j % 2 ? y : x) : 0));\n\n  if (!\"TQ\".includes(absCommand)) {\n    // optional but good to be cautious\n    params.qx = null;\n    params.qy = null;\n  }\n\n  // istanbul ignore else @preserve\n  if (absCommand === \"A\") {\n    absValues = values.slice(0, -2).concat(\n      values[5] + (isRelative ? x : 0),\n      values[6] + (isRelative ? y : 0),\n    );\n\n    return [\"A\" as PathCommand | number].concat(absValues) as ASegment;\n  } else if (absCommand === \"H\") {\n    return [\n      \"L\",\n      (segment as HSegment)[1] + (isRelative ? x : 0),\n      py1,\n    ] as LSegment;\n  } else if (absCommand === \"V\") {\n    return [\n      \"L\",\n      px1,\n      (segment as VSegment)[1] + (isRelative ? y : 0),\n    ] as LSegment;\n  } else if (absCommand === \"L\") {\n    return [\n      \"L\",\n      (segment as LSegment)[1] + (isRelative ? x : 0),\n      (segment as LSegment)[2] + (isRelative ? y : 0),\n    ] as LSegment;\n  } else if (absCommand === \"M\") {\n    return [\n      \"M\",\n      (segment as MSegment)[1] + (isRelative ? x : 0),\n      (segment as MSegment)[2] + (isRelative ? y : 0),\n    ] as MSegment;\n  } else if (absCommand === \"C\") {\n    return [\"C\" as PathCommand | number].concat(absValues) as CSegment;\n  } else if (absCommand === \"S\") {\n    const x1 = px1 * 2 - px2;\n    const y1 = py1 * 2 - py2;\n    params.x1 = x1;\n    params.y1 = y1;\n    return [\"C\", x1, y1].concat(absValues) as CSegment;\n  } else if (absCommand === \"T\") {\n    const qx = px1 * 2 - (params.qx ? params.qx : /* istanbul ignore next */ 0);\n    const qy = py1 * 2 - (params.qy ? params.qy : /* istanbul ignore next */ 0);\n    params.qx = qx;\n    params.qy = qy;\n    return [\"Q\", qx, qy].concat(absValues) as QSegment;\n  } else if (absCommand === \"Q\") {\n    const [nqx, nqy] = absValues as PointTuple;\n    params.qx = nqx;\n    params.qy = nqy;\n    return [\"Q\" as PathCommand | number].concat(absValues) as QSegment;\n  } else if (absCommand === \"Z\") {\n    return [\"Z\"] as NormalSegment;\n  }\n\n  // istanbul ignore next @preserve\n  return segment as NormalSegment;\n};\nexport default normalizeSegment;\n","import type { ParserParams } from \"../interface\";\n\nconst paramsParser: ParserParams = {\n  x1: 0,\n  y1: 0,\n  x2: 0,\n  y2: 0,\n  x: 0,\n  y: 0,\n  qx: null,\n  qy: null,\n};\n\nexport default paramsParser;\n","import segmentToCubic from \"../process/segmentToCubic\";\nimport { AbsoluteCommand, CSegment, CurveArray, PathArray } from \"../types\";\nimport iterate from \"../process/iterate\";\nimport parsePathString from \"../parser/parsePathString\";\nimport normalizeSegment from \"../process/normalizeSegment\";\nimport paramsParser from \"../parser/paramsParser\";\n\n/**\n * Parses a path string value or 'pathArray' and returns a new one\n * in which all segments are converted to cubic-bezier.\n *\n * In addition, un-necessary `Z` segment is removed if previous segment\n * extends to the `M` segment.\n *\n * @param pathInput the string to be parsed or 'pathArray'\n * @returns the resulted `pathArray` converted to cubic-bezier\n */\nconst pathToCurve = (pathInput: string | PathArray): CurveArray => {\n  const params = { ...paramsParser };\n  const path = parsePathString(pathInput);\n\n  return iterate<CurveArray>(path, (seg, index, lastX, lastY) => {\n    params.x = lastX;\n    params.y = lastY;\n    const normalSegment = normalizeSegment(seg, params);\n    let result = segmentToCubic(normalSegment, params);\n    const isLongArc = result[0] === \"C\" && result.length > 7;\n\n    if (isLongArc) {\n      path.splice(\n        index + 1,\n        0,\n        [\"C\" as AbsoluteCommand | number].concat(result.slice(7)) as CSegment,\n      );\n      result = result.slice(0, 7) as CSegment;\n    }\n\n    const seglen = result.length;\n    params.x1 = +result[seglen - 2];\n    params.y1 = +result[seglen - 1];\n    params.x2 = +result[seglen - 4] || params.x1;\n    params.y2 = +result[seglen - 3] || params.y1;\n\n    return result;\n  });\n};\nexport default pathToCurve;\n","import { Options } from \"../interface\";\n\n/** SVGPathCommander default options */\nconst defaultOptions: Options = {\n  origin: [0, 0, 0],\n  round: 4,\n};\n\nexport default defaultOptions;\n","const roundTo = (n: number, round: number) => {\n  const pow = round >= 1 ? 10 ** round : 1;\n\n  return round > 0 ? Math.round(n * pow) / pow : Math.round(n);\n};\n\nexport default roundTo;\n","import type { PathArray, PathSegment } from \"../types\";\nimport defaultOptions from \"../options/options\";\nimport roundTo from \"../math/roundTo\";\n\n/**\n * Returns a valid `d` attribute string value created\n * by rounding values and concatenating the `pathArray` segments.\n *\n * @param path the `pathArray` object\n * @param roundOption amount of decimals to round values to\n * @returns the concatenated path string\n */\nconst pathToString = (\n  path: PathArray,\n  roundOption?: number | \"off\",\n): string => {\n  const pathLen = path.length;\n  let { round } = defaultOptions;\n  let segment = path[0] as PathSegment;\n  let result = \"\";\n\n  // allow for ZERO decimals\n  round = roundOption === \"off\"\n    ? roundOption\n    : typeof roundOption === \"number\" && roundOption >= 0\n    ? roundOption\n    : typeof round === \"number\" && round >= 0\n    ? round\n    : /* istanbul ignore next @preserve */ \"off\";\n\n  for (let i = 0; i < pathLen; i += 1) {\n    segment = path[i];\n    const [pathCommand] = segment;\n    const values = segment.slice(1) as number[];\n    result += pathCommand;\n    if (round === \"off\") {\n      result += values.join(\" \");\n    } else {\n      let j = 0;\n      const valLen = values.length;\n      while (j < valLen) {\n        result += roundTo(values[j], round);\n        if (j !== valLen - 1) result += \" \";\n        j += 1;\n      }\n    }\n  }\n\n  return result;\n};\n\nexport default pathToString;\n","const DISTANCE_EPSILON = 0.00001;\n\nexport default DISTANCE_EPSILON;\n","import normalizeSegment from \"./normalizeSegment\";\nimport type { NormalArray, PathArray } from \"../types\";\nimport iterate from \"./iterate\";\nimport parsePathString from \"../parser/parsePathString\";\nimport paramsParser from \"../parser/paramsParser\";\n\n/**\n * Normalizes a `pathArray` object for further processing:\n * * convert segments to absolute values\n * * convert shorthand path commands to their non-shorthand notation\n *\n * @param pathInput the string to be parsed or 'pathArray'\n * @returns the normalized `pathArray`\n */\nconst normalizePath = (pathInput: string | PathArray) => {\n  const path = parsePathString(pathInput);\n  const params = { ...paramsParser };\n\n  return iterate<NormalArray>(path, (seg, _, lastX, lastY) => {\n    params.x = lastX;\n    params.y = lastY;\n    const result = normalizeSegment(seg, params);\n\n    const seglen = result.length;\n    params.x1 = +result[seglen - 2];\n    params.y1 = +result[seglen - 1];\n    params.x2 = +result[seglen - 4] || params.x1;\n    params.y2 = +result[seglen - 3] || params.y1;\n\n    return result;\n  });\n};\nexport default normalizePath;\n","import DISTANCE_EPSILON from \"./distanceEpsilon\";\nimport type { MSegment, PathArray, PointTuple } from \"../types\";\nimport iterate from \"../process/iterate\";\nimport { getLineLength, getPointAtLineLength } from \"../math/lineTools\";\nimport { getArcLength, getPointAtArcLength } from \"../math/arcTools\";\nimport { getCubicLength, getPointAtCubicLength } from \"../math/cubicTools\";\nimport { getPointAtQuadLength, getQuadLength } from \"../math/quadTools\";\nimport normalizePath from \"../process/normalizePath\";\n\n/**\n * Returns [x,y] coordinates of a point at a given length of a shape.\n *\n * @param pathInput the `pathArray` to look into\n * @param distance the length of the shape to look at\n * @returns the requested {x, y} point coordinates\n */\nconst getPointAtLength = (pathInput: string | PathArray, distance?: number) => {\n  const path = normalizePath(pathInput);\n  let isM = false;\n  let data = [] as number[];\n  let pathCommand = \"M\";\n  let x = 0;\n  let y = 0;\n  let [mx, my] = path[0].slice(1) as PointTuple;\n  const distanceIsNumber = typeof distance === \"number\";\n  let point = { x: mx, y: my };\n  let length = 0;\n  let POINT = point;\n  let totalLength = 0;\n\n  if (!distanceIsNumber || distance < DISTANCE_EPSILON) return point;\n\n  // for (let i = 0; i < pathLen; i += 1) {\n  iterate(path, (seg, _, lastX, lastY) => {\n    [pathCommand] = seg;\n    isM = pathCommand === \"M\";\n    data = !isM ? [lastX, lastY].concat(seg.slice(1) as number[]) : data;\n\n    // this segment is always ZERO\n    /* istanbul ignore else @preserve */\n    if (isM) {\n      // remember mx, my for Z\n      [, mx, my] = seg as MSegment;\n      point = { x: mx, y: my };\n      length = 0;\n    } else if (pathCommand === \"L\") {\n      point = getPointAtLineLength(\n        data[0],\n        data[1],\n        data[2],\n        data[3],\n        distance - totalLength,\n      );\n      length = getLineLength(data[0], data[1], data[2], data[3]);\n    } else if (pathCommand === \"A\") {\n      point = getPointAtArcLength(\n        data[0],\n        data[1],\n        data[2],\n        data[3],\n        data[4],\n        data[5],\n        data[6],\n        data[7],\n        data[8],\n        distance - totalLength,\n      );\n      length = getArcLength(\n        data[0],\n        data[1],\n        data[2],\n        data[3],\n        data[4],\n        data[5],\n        data[6],\n        data[7],\n        data[8],\n      );\n    } else if (pathCommand === \"C\") {\n      point = getPointAtCubicLength(\n        data[0],\n        data[1],\n        data[2],\n        data[3],\n        data[4],\n        data[5],\n        data[6],\n        data[7],\n        distance - totalLength,\n      );\n      length = getCubicLength(\n        data[0],\n        data[1],\n        data[2],\n        data[3],\n        data[4],\n        data[5],\n        data[6],\n        data[7],\n      );\n    } else if (pathCommand === \"Q\") {\n      point = getPointAtQuadLength(\n        data[0],\n        data[1],\n        data[2],\n        data[3],\n        data[4],\n        data[5],\n        distance - totalLength,\n      );\n      length = getQuadLength(\n        data[0],\n        data[1],\n        data[2],\n        data[3],\n        data[4],\n        data[5],\n      );\n    } else if (pathCommand === \"Z\") {\n      data = [lastX, lastY, mx, my];\n      point = { x: mx, y: my };\n\n      length = getLineLength(data[0], data[1], data[2], data[3]);\n    }\n\n    [x, y] = data.slice(-2);\n\n    if (totalLength < distance) {\n      POINT = point;\n    } else {\n      // totalLength >= distance\n      // stop right here\n      // stop iterator now!\n      return false;\n    }\n\n    totalLength += length;\n    return;\n  });\n\n  // native `getPointAtLength` behavior when the given distance\n  // is higher than total length\n  if (distance > totalLength - DISTANCE_EPSILON) {\n    return { x, y };\n  }\n\n  return POINT;\n};\n\nexport default getPointAtLength;\n","import type { LSegment, MSegment, PathArray, PointTuple } from \"../types\";\nimport { getLineLength } from \"../math/lineTools\";\nimport { getArcLength } from \"../math/arcTools\";\nimport { getCubicLength } from \"../math/cubicTools\";\nimport { getQuadLength } from \"../math/quadTools\";\nimport iterate from \"../process/iterate\";\nimport parsePathString from \"../parser/parsePathString\";\nimport absolutizeSegment from \"../process/absolutizeSegment\";\n\n/**\n * Returns the shape total length, or the equivalent to `shape.getTotalLength()`.\n *\n * @param pathInput the target `pathArray`\n * @returns the shape total length\n */\nconst getTotalLength = (pathInput: string | PathArray) => {\n  const path = parsePathString(pathInput);\n  let paramX1 = 0;\n  let paramY1 = 0;\n  let paramX2 = 0;\n  let paramY2 = 0;\n  let paramQX = 0;\n  let paramQY = 0;\n  let pathCommand = \"M\";\n  let mx = 0;\n  let my = 0;\n  let totalLength = 0;\n\n  iterate(path, (seg, index, lastX, lastY) => {\n    [pathCommand] = seg;\n    const absCommand = pathCommand.toUpperCase();\n    const isRelative = absCommand !== pathCommand;\n    const absoluteSegment = isRelative\n      ? absolutizeSegment(seg, index, lastX, lastY)\n      : (seg.slice(0) as typeof seg);\n\n    const normalSegment = absCommand === \"V\"\n      ? ([\"L\", lastX, absoluteSegment[1]] as LSegment)\n      : absCommand === \"H\"\n      ? ([\"L\", absoluteSegment[1], lastY] as LSegment)\n      : absoluteSegment;\n    [pathCommand] = normalSegment;\n\n    if (!\"TQ\".includes(absCommand)) {\n      // optional but good to be cautious\n      paramQX = 0;\n      paramQY = 0;\n    }\n\n    // this segment is always ZERO\n    /* istanbul ignore else @preserve */\n    if (pathCommand === \"M\") {\n      // remember mx, my for Z\n      [, mx, my] = normalSegment as MSegment;\n    } else if (pathCommand === \"L\") {\n      totalLength += getLineLength(\n        lastX,\n        lastY,\n        normalSegment[1] as number,\n        normalSegment[2] as number,\n      );\n    } else if (pathCommand === \"A\") {\n      totalLength += getArcLength(\n        lastX,\n        lastY,\n        normalSegment[1] as number,\n        normalSegment[2] as number,\n        normalSegment[3] as number,\n        normalSegment[4] as number,\n        normalSegment[5] as number,\n        normalSegment[6] as number,\n        normalSegment[7] as number,\n      );\n    } else if (pathCommand === \"S\") {\n      const cp1x = paramX1 * 2 - paramX2;\n      const cp1y = paramY1 * 2 - paramY2;\n\n      totalLength += getCubicLength(\n        lastX,\n        lastY,\n        cp1x,\n        cp1y,\n        normalSegment[1] as number,\n        normalSegment[2] as number,\n        normalSegment[3] as number,\n        normalSegment[4] as number,\n      );\n    } else if (pathCommand === \"C\") {\n      totalLength += getCubicLength(\n        lastX,\n        lastY,\n        normalSegment[1] as number,\n        normalSegment[2] as number,\n        normalSegment[3] as number,\n        normalSegment[4] as number,\n        normalSegment[5] as number,\n        normalSegment[6] as number,\n      );\n    } else if (pathCommand === \"T\") {\n      paramQX = paramX1 * 2 - paramQX;\n      paramQY = paramY1 * 2 - paramQY;\n      totalLength += getQuadLength(\n        lastX,\n        lastY,\n        paramQX,\n        paramQY,\n        normalSegment[1] as number,\n        normalSegment[2] as number,\n      );\n    } else if (pathCommand === \"Q\") {\n      paramQX = normalSegment[1] as number;\n      paramQY = normalSegment[2] as number;\n      totalLength += getQuadLength(\n        lastX,\n        lastY,\n        normalSegment[1] as number,\n        normalSegment[2] as number,\n        normalSegment[3] as number,\n        normalSegment[4] as number,\n      );\n    } else if (pathCommand === \"Z\") {\n      totalLength += getLineLength(lastX, lastY, mx, my);\n    }\n\n    // update params\n    [paramX1, paramY1] = pathCommand === \"Z\"\n      ? [mx, my]\n      : (normalSegment.slice(-2) as PointTuple);\n    [paramX2, paramY2] = pathCommand === \"C\"\n      ? ([normalSegment[3], normalSegment[4]] as PointTuple)\n      : pathCommand === \"S\"\n      ? ([normalSegment[1], normalSegment[2]] as PointTuple)\n      : [paramX1, paramY1];\n  });\n\n  return totalLength;\n};\n\nexport default getTotalLength;\n","import type { PathArray, PathSegment } from \"../types\";\nimport type { SegmentProperties } from \"../interface\";\nimport parsePathString from \"../parser/parsePathString\";\nimport getTotalLength from \"./getTotalLength\";\n\n/**\n * Returns the segment, its index and length as well as\n * the length to that segment at a given length in a path.\n *\n * @param pathInput target `pathArray`\n * @param distance the given length\n * @returns the requested properties\n */\nconst getPropertiesAtLength = (\n  pathInput: string | PathArray,\n  distance?: number,\n): SegmentProperties => {\n  const pathArray = parsePathString(pathInput);\n\n  let pathTemp = pathArray.slice(0) as PathArray;\n  let pathLength = getTotalLength(pathTemp);\n  let index = pathTemp.length - 1;\n  let lengthAtSegment = 0;\n  let length = 0;\n  let segment = pathArray[0] as PathSegment;\n\n  // If the path is empty, return 0.\n  if (index <= 0 || !distance || !Number.isFinite(distance)) {\n    return {\n      segment,\n      index: 0,\n      length,\n      lengthAtSegment,\n    };\n  }\n\n  if (distance >= pathLength) {\n    pathTemp = pathArray.slice(0, -1) as PathArray;\n    lengthAtSegment = getTotalLength(pathTemp);\n    length = pathLength - lengthAtSegment;\n    segment = pathArray[index];\n    return {\n      segment,\n      index,\n      length,\n      lengthAtSegment,\n    };\n  }\n\n  const segments = [] as SegmentProperties[];\n  while (index > 0) {\n    segment = pathTemp[index];\n    pathTemp = pathTemp.slice(0, -1) as PathArray;\n    lengthAtSegment = getTotalLength(pathTemp);\n    length = pathLength - lengthAtSegment;\n    pathLength = lengthAtSegment;\n\n    segments.push({\n      segment,\n      index,\n      length,\n      lengthAtSegment,\n    });\n    index -= 1;\n  }\n\n  return segments.find(({ lengthAtSegment: l }) =>\n    l <= distance\n  ) as SegmentProperties;\n};\n\nexport default getPropertiesAtLength;\n","import type { PathArray, Point } from \"../types\";\nimport type { PointProperties } from \"../interface\";\nimport getPointAtLength from \"./getPointAtLength\";\nimport getPropertiesAtLength from \"./getPropertiesAtLength\";\nimport getTotalLength from \"./getTotalLength\";\nimport parsePathString from \"../parser/parsePathString\";\nimport normalizePath from \"../process/normalizePath\";\n\n/**\n * Returns the point and segment in path closest to a given point as well as\n * the distance to the path stroke.\n *\n * @see https://bl.ocks.org/mbostock/8027637\n *\n * @param pathInput target `pathArray`\n * @param point the given point\n * @returns the requested properties\n */\nconst getPropertiesAtPoint = (\n  pathInput: string | PathArray,\n  point: Point,\n): PointProperties => {\n  const path = parsePathString(pathInput);\n  const normalPath = normalizePath(path);\n  const pathLength = getTotalLength(normalPath);\n  const distanceTo = (p: Point) => {\n    const dx = p.x - point.x;\n    const dy = p.y - point.y;\n    return dx * dx + dy * dy;\n  };\n  let precision = 8;\n  let scan: Point;\n  let closest = { x: 0, y: 0 }; // make TS happy\n  let scanDistance = 0;\n  let bestLength = 0;\n  let bestDistance = Infinity;\n\n  // linear scan for coarse approximation\n  for (let scanLength = 0; scanLength <= pathLength; scanLength += precision) {\n    scan = getPointAtLength(normalPath, scanLength);\n    scanDistance = distanceTo(scan);\n\n    if (scanDistance < bestDistance) {\n      closest = scan;\n      bestLength = scanLength;\n      bestDistance = scanDistance;\n    }\n  }\n\n  // binary search for precise estimate\n  precision /= 2;\n  let before: { x: number; y: number };\n  let after: { x: number; y: number };\n  let beforeLength = 0;\n  let afterLength = 0;\n  let beforeDistance = 0;\n  let afterDistance = 0;\n\n  while (precision > 0.000001) {\n    beforeLength = bestLength - precision;\n    before = getPointAtLength(normalPath, beforeLength);\n    beforeDistance = distanceTo(before);\n    afterLength = bestLength + precision;\n    after = getPointAtLength(normalPath, afterLength);\n    afterDistance = distanceTo(after);\n\n    if (beforeLength >= 0 && beforeDistance < bestDistance) {\n      closest = before;\n      bestLength = beforeLength;\n      bestDistance = beforeDistance;\n    } else if (afterLength <= pathLength && afterDistance < bestDistance) {\n      closest = after;\n      bestLength = afterLength;\n      bestDistance = afterDistance;\n    } else {\n      precision /= 2;\n    }\n    if (precision < 0.00001) break;\n  }\n\n  const segment = getPropertiesAtLength(path, bestLength);\n  const distance = Math.sqrt(bestDistance);\n\n  return { closest, distance, segment };\n};\n\nexport default getPropertiesAtPoint;\n","import type { PathArray } from \"../types\";\nimport getPropertiesAtPoint from \"./getPropertiesAtPoint\";\n\n/**\n * Returns the point in path closest to a given point.\n *\n * @param pathInput target `pathArray`\n * @param point the given point\n * @returns the best match\n */\nconst getClosestPoint = (\n  pathInput: string | PathArray,\n  point: { x: number; y: number },\n) => {\n  return getPropertiesAtPoint(pathInput, point).closest;\n};\n\nexport default getClosestPoint;\n","import pathToCurve from \"../convert/pathToCurve\";\nimport type { PathArray, PointTuple } from \"../types\";\n\n/**\n * Returns the area of a single cubic-bezier segment.\n *\n * http://objectmix.com/graphics/133553-area-closed-bezier-curve.html\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param c1x the first control point X\n * @param c1y the first control point Y\n * @param c2x the second control point X\n * @param c2y the second control point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @returns the area of the cubic-bezier segment\n */\nconst getCubicSegArea = (\n  x1: number,\n  y1: number,\n  c1x: number,\n  c1y: number,\n  c2x: number,\n  c2y: number,\n  x2: number,\n  y2: number,\n) => {\n  return (\n    (3 *\n      ((y2 - y1) * (c1x + c2x) -\n        (x2 - x1) * (c1y + c2y) +\n        c1y * (x1 - c2x) -\n        c1x * (y1 - c2y) +\n        y2 * (c2x + x1 / 3) -\n        x2 * (c2y + y1 / 3))) /\n    20\n  );\n};\n\n/**\n * Returns the area of a shape.\n *\n * @author Jürg Lehni & Jonathan Puckey\n *\n * @see https://github.com/paperjs/paper.js/blob/develop/src/path/Path.js\n *\n * @param path the shape `pathArray`\n * @returns the length of the cubic-bezier segment\n */\nconst getPathArea = (path: PathArray) => {\n  let x = 0;\n  let y = 0;\n  let len = 0;\n\n  return pathToCurve(path)\n    .map((seg) => {\n      switch (seg[0]) {\n        case \"M\":\n          [, x, y] = seg;\n          return 0;\n        default:\n          len = getCubicSegArea(\n            x,\n            y,\n            seg[1],\n            seg[2],\n            seg[3],\n            seg[4],\n            seg[5],\n            seg[6],\n          );\n          [x, y] = seg.slice(-2) as PointTuple;\n          return len;\n      }\n    })\n    .reduce((a, b) => a + b, 0);\n};\nexport default getPathArea;\n","import getPathArea from \"./getPathArea\";\nimport pathToCurve from \"../convert/pathToCurve\";\nimport type { PathArray } from \"../types\";\n\n/**\n * Check if a path is drawn clockwise and returns true if so,\n * false otherwise.\n *\n * @param path the path string or `pathArray`\n * @returns true when clockwise or false if not\n */\nconst getDrawDirection = (path: string | PathArray) => {\n  return getPathArea(pathToCurve(path)) >= 0;\n};\n\nexport default getDrawDirection;\n","import iterate from \"../process/iterate\";\nimport { PathBBox } from \"../interface\";\nimport { LSegment, MSegment, PathArray, PointTuple } from \"../types\";\nimport { getLineBBox } from \"../math/lineTools\";\nimport { getArcBBox } from \"../math/arcTools\";\nimport { getCubicBBox } from \"../math/cubicTools\";\nimport { getQuadBBox } from \"../math/quadTools\";\nimport parsePathString from \"../parser/parsePathString\";\nimport absolutizeSegment from \"../process/absolutizeSegment\";\n\nconst getPathBBox = (pathInput: PathArray | string) => {\n  if (!pathInput) {\n    return {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0,\n      x2: 0,\n      y2: 0,\n      cx: 0,\n      cy: 0,\n      cz: 0,\n    };\n  }\n\n  const path = parsePathString(pathInput);\n  let pathCommand = \"M\";\n  let mx = 0;\n  let my = 0;\n  const { max, min } = Math;\n  let xMin = Infinity;\n  let yMin = Infinity;\n  let xMax = -Infinity;\n  let yMax = -Infinity;\n  let minX = 0;\n  let minY = 0;\n  let maxX = 0;\n  let maxY = 0;\n  let paramX1 = 0;\n  let paramY1 = 0;\n  let paramX2 = 0;\n  let paramY2 = 0;\n  let paramQX = 0;\n  let paramQY = 0;\n\n  iterate(path, (seg, index, lastX, lastY) => {\n    [pathCommand] = seg;\n    const absCommand = pathCommand.toUpperCase();\n    const isRelative = absCommand !== pathCommand;\n    const absoluteSegment = isRelative\n      ? absolutizeSegment(seg, index, lastX, lastY)\n      : (seg.slice(0) as typeof seg);\n\n    const normalSegment = absCommand === \"V\"\n      ? ([\"L\", lastX, absoluteSegment[1]] as LSegment)\n      : absCommand === \"H\"\n      ? ([\"L\", absoluteSegment[1], lastY] as LSegment)\n      : absoluteSegment;\n\n    [pathCommand] = normalSegment;\n\n    if (!\"TQ\".includes(absCommand)) {\n      // optional but good to be cautious\n      paramQX = 0;\n      paramQY = 0;\n    }\n\n    // this segment is always ZERO\n    /* istanbul ignore else @preserve */\n    if (pathCommand === \"M\") {\n      [, mx, my] = normalSegment as MSegment;\n      minX = mx;\n      minY = my;\n      maxX = mx;\n      maxY = my;\n    } else if (pathCommand === \"L\") {\n      [minX, minY, maxX, maxY] = getLineBBox(\n        lastX,\n        lastY,\n        normalSegment[1] as number,\n        normalSegment[2] as number,\n      );\n    } else if (pathCommand === \"A\") {\n      [minX, minY, maxX, maxY] = getArcBBox(\n        lastX,\n        lastY,\n        normalSegment[1] as number,\n        normalSegment[2] as number,\n        normalSegment[3] as number,\n        normalSegment[4] as number,\n        normalSegment[5] as number,\n        normalSegment[6] as number,\n        normalSegment[7] as number,\n      );\n    } else if (pathCommand === \"S\") {\n      const cp1x = paramX1 * 2 - paramX2;\n      const cp1y = paramY1 * 2 - paramY2;\n\n      [minX, minY, maxX, maxY] = getCubicBBox(\n        lastX,\n        lastY,\n        cp1x,\n        cp1y,\n        normalSegment[1] as number,\n        normalSegment[2] as number,\n        normalSegment[3] as number,\n        normalSegment[4] as number,\n      );\n    } else if (pathCommand === \"C\") {\n      [minX, minY, maxX, maxY] = getCubicBBox(\n        lastX,\n        lastY,\n        normalSegment[1] as number,\n        normalSegment[2] as number,\n        normalSegment[3] as number,\n        normalSegment[4] as number,\n        normalSegment[5] as number,\n        normalSegment[6] as number,\n      );\n    } else if (pathCommand === \"T\") {\n      paramQX = paramX1 * 2 - paramQX;\n      paramQY = paramY1 * 2 - paramQY;\n      [minX, minY, maxX, maxY] = getQuadBBox(\n        lastX,\n        lastY,\n        paramQX,\n        paramQY,\n        normalSegment[1] as number,\n        normalSegment[2] as number,\n      );\n    } else if (pathCommand === \"Q\") {\n      paramQX = normalSegment[1] as number;\n      paramQY = normalSegment[2] as number;\n      [minX, minY, maxX, maxY] = getQuadBBox(\n        lastX,\n        lastY,\n        normalSegment[1] as number,\n        normalSegment[2] as number,\n        normalSegment[3] as number,\n        normalSegment[4] as number,\n      );\n    } else if (pathCommand === \"Z\") {\n      [minX, minY, maxX, maxY] = getLineBBox(lastX, lastY, mx, my);\n    }\n    xMin = min(minX, xMin);\n    yMin = min(minY, yMin);\n    xMax = max(maxX, xMax);\n    yMax = max(maxY, yMax);\n\n    // update params\n    [paramX1, paramY1] = pathCommand === \"Z\"\n      ? [mx, my]\n      : (normalSegment.slice(-2) as PointTuple);\n    [paramX2, paramY2] = pathCommand === \"C\"\n      ? ([normalSegment[3], normalSegment[4]] as PointTuple)\n      : pathCommand === \"S\"\n      ? ([normalSegment[1], normalSegment[2]] as PointTuple)\n      : [paramX1, paramY1];\n  });\n\n  const width = xMax - xMin;\n  const height = yMax - yMin;\n\n  return {\n    width,\n    height,\n    x: xMin,\n    y: yMin,\n    x2: xMax,\n    y2: yMax,\n    cx: xMin + width / 2,\n    cy: yMin + height / 2,\n    // an estimated guess\n    cz: Math.max(width, height) + Math.min(width, height) / 2,\n  } satisfies PathBBox;\n};\n\nexport default getPathBBox;\n","import type { PathArray, PathSegment } from \"../types\";\nimport getPropertiesAtLength from \"./getPropertiesAtLength\";\n\n/**\n * Returns the segment at a given length.\n *\n * @param pathInput the target `pathArray`\n * @param distance the distance in path to look at\n * @returns the requested segment\n */\nconst getSegmentAtLength = (\n  pathInput: string | PathArray,\n  distance?: number,\n): PathSegment | undefined => {\n  return getPropertiesAtLength(pathInput, distance).segment;\n};\n\nexport default getSegmentAtLength;\n","import type { SegmentProperties } from \"../interface\";\nimport type { PathArray } from \"../types\";\nimport getPropertiesAtPoint from \"./getPropertiesAtPoint\";\n\n/**\n * Returns the path segment which contains a given point.\n *\n * @param path the `pathArray` to look into\n * @param point the point of the shape to look for\n * @returns the requested segment\n */\nconst getSegmentOfPoint = (\n  path: string | PathArray,\n  point: { x: number; y: number },\n): SegmentProperties | undefined => {\n  return getPropertiesAtPoint(path, point).segment;\n};\nexport default getSegmentOfPoint;\n","import type { PathArray, PathSegment, RelativeCommand } from \"../types\";\nimport paramsCount from \"../parser/paramsCount\";\n\n/**\n * Iterates an array to check if it's an actual `pathArray`.\n *\n * @param path the `pathArray` to be checked\n * @returns iteration result\n */\nconst isPathArray = (path: unknown): path is PathArray => {\n  return (\n    Array.isArray(path) &&\n    path.every((seg: PathSegment) => {\n      const lk = seg[0].toLowerCase() as RelativeCommand;\n      return (\n        paramsCount[lk] === seg.length - 1 &&\n        \"achlmqstvz\".includes(lk) &&\n        (seg.slice(1) as unknown[]).every(Number.isFinite)\n      );\n    }) &&\n    path.length > 0\n  );\n};\nexport default isPathArray;\n","import type { AbsoluteArray } from \"../types\";\nimport isPathArray from \"./isPathArray\";\n\n/**\n * Iterates an array to check if it's a `pathArray`\n * with all absolute values.\n *\n * @param path the `pathArray` to be checked\n * @returns iteration result\n */\nconst isAbsoluteArray = (path: unknown): path is AbsoluteArray => {\n  return (\n    isPathArray(path) &&\n    // `isPathArray` also checks if it's `Array`\n    path.every(([x]) => x === x.toUpperCase())\n  );\n};\nexport default isAbsoluteArray;\n","import type { NormalArray } from \"../types\";\nimport isAbsoluteArray from \"./isAbsoluteArray\";\n\n/**\n * Iterates an array to check if it's a `pathArray`\n * with all segments are in non-shorthand notation\n * with absolute values.\n *\n * @param {string | SVGPath.pathArray} path the `pathArray` to be checked\n * @returns {boolean} iteration result\n */\nconst isNormalizedArray = (path: unknown): path is NormalArray => {\n  // `isAbsoluteArray` also checks if it's `Array`\n  return isAbsoluteArray(path) && path.every(([pc]) => \"ACLMQZ\".includes(pc));\n};\nexport default isNormalizedArray;\n","import { CurveArray } from \"../types\";\nimport isNormalizedArray from \"./isNormalizedArray\";\n\n/**\n * Iterates an array to check if it's a `pathArray`\n * with all C (cubic bezier) segments.\n *\n * @param path the `Array` to be checked\n * @returns iteration result\n */\nconst isCurveArray = (path: unknown): path is CurveArray => {\n  // `isPathArray` also checks if it's `Array`\n  return isNormalizedArray(path) && path.every(([pc]) => \"MC\".includes(pc));\n};\nexport default isCurveArray;\n","import type { PathArray } from \"../types\";\nimport getPropertiesAtPoint from \"./getPropertiesAtPoint\";\nimport DISTANCE_EPSILON from \"./distanceEpsilon\";\n\n/**\n * Checks if a given point is in the stroke of a path.\n *\n * @param pathInput target path\n * @param point the given `{x,y}` point\n * @returns the query result\n */\nconst isPointInStroke = (\n  pathInput: string | PathArray,\n  point: { x: number; y: number },\n) => {\n  const { distance } = getPropertiesAtPoint(pathInput, point);\n  return Math.abs(distance) < DISTANCE_EPSILON; // 0.01 might be more permissive\n};\nexport default isPointInStroke;\n","import type { RelativeArray } from \"../types\";\nimport isPathArray from \"./isPathArray\";\n\n/**\n * Iterates an array to check if it's a `pathArray`\n * with relative values.\n *\n * @param path the `pathArray` to be checked\n * @returns iteration result\n */\nconst isRelativeArray = (path: unknown): path is RelativeArray => {\n  return (\n    isPathArray(path) &&\n    // `isPathArray` checks if it's `Array`\n    path.slice(1).every(([pc]) => pc === pc.toLowerCase())\n  );\n};\nexport default isRelativeArray;\n","import scanSegment from \"../parser/scanSegment\";\nimport skipSpaces from \"../parser/skipSpaces\";\nimport PathParser from \"../parser/pathParser\";\n\n/**\n * Parses a path string value to determine its validity\n * then returns true if it's valid or false otherwise.\n *\n * @param pathString the path string to be parsed\n * @returns the path string validity\n */\nconst isValidPath = (pathString: string) => {\n  if (typeof pathString !== \"string\" || !pathString.length) {\n    return false;\n  }\n\n  const path = new PathParser(pathString);\n\n  skipSpaces(path);\n\n  while (path.index < path.max && !path.err.length) {\n    scanSegment(path);\n  }\n\n  return !path.err.length && \"mM\".includes(path.segments[0][0]);\n};\nexport default isValidPath;\n","import type { ShapeParams } from \"../interface\";\n\n/**\n * Supported shapes and their specific parameters.\n */\nconst shapeParams: ShapeParams = {\n  line: [\"x1\", \"y1\", \"x2\", \"y2\"],\n  circle: [\"cx\", \"cy\", \"r\"],\n  ellipse: [\"cx\", \"cy\", \"rx\", \"ry\"],\n  rect: [\"width\", \"height\", \"x\", \"y\", \"rx\", \"ry\"],\n  polygon: [\"points\"],\n  polyline: [\"points\"],\n  glyph: [\"d\"],\n};\n\nexport default shapeParams;\n","const isElement = (node?: unknown): node is Element =>\n  node !== undefined && node !== null &&\n  typeof node === \"object\" &&\n  (node as Node).nodeType === 1; // ELEMENT_NODE\n\nexport default isElement;\n","import type {\n  CircleAttr,\n  EllipseAttr,\n  GlyphAttr,\n  LineAttr,\n  PolyAttr,\n  RectAttr,\n  ShapeParams,\n} from \"../interface\";\nimport type { PathArray, PathSegment, ShapeOps, ShapeTypes } from \"../types\";\nimport error from \"../parser/error\";\nimport parsePathString from \"../parser/parsePathString\";\nimport shapeParams from \"./shapeParams\";\nimport isPathArray from \"./isPathArray\";\nimport isElement from \"./isElement\";\n\n/**\n * Returns a new `pathArray` from line attributes.\n *\n * @param attr shape configuration\n * @returns a new line `pathArray`\n */\nexport const getLinePath = (attr: LineAttr): PathArray => {\n  let { x1, y1, x2, y2 } = attr;\n  [x1, y1, x2, y2] = [x1, y1, x2, y2].map((a) => +a);\n  return [\n    [\"M\", x1, y1],\n    [\"L\", x2, y2],\n  ];\n};\n\n/**\n * Returns a new `pathArray` like from polyline/polygon attributes.\n *\n * @param attr shape configuration\n * @return a new polygon/polyline `pathArray`\n */\nexport const getPolyPath = (attr: PolyAttr): PathArray => {\n  const pathArray = [] as PathSegment[];\n  const points = (attr.points || \"\")\n    .trim()\n    .split(/[\\s|,]/)\n    .map((a) => +a);\n\n  let index = 0;\n  while (index < points.length) {\n    pathArray.push([index ? \"L\" : \"M\", points[index], points[index + 1]]);\n    index += 2;\n  }\n\n  return (attr.type === \"polygon\"\n    ? [...pathArray, [\"z\"]]\n    : pathArray) as PathArray;\n};\n\n/**\n * Returns a new `pathArray` from circle attributes.\n *\n * @param attr shape configuration\n * @return a circle `pathArray`\n */\nexport const getCirclePath = (attr: CircleAttr): PathArray => {\n  let { cx, cy, r } = attr;\n  [cx, cy, r] = [cx, cy, r].map((a) => +a);\n\n  return [\n    [\"M\", cx - r, cy],\n    [\"a\", r, r, 0, 1, 0, 2 * r, 0],\n    [\"a\", r, r, 0, 1, 0, -2 * r, 0],\n  ];\n};\n\n/**\n * Returns a new `pathArray` from ellipse attributes.\n *\n * @param attr shape configuration\n * @return an ellipse `pathArray`\n */\nexport const getEllipsePath = (attr: EllipseAttr): PathArray => {\n  let { cx, cy } = attr;\n  let rx = attr.rx || 0;\n  let ry = attr.ry || rx;\n  [cx, cy, rx, ry] = [cx, cy, rx, ry].map((a) => +a);\n\n  return [\n    [\"M\", cx - rx, cy],\n    [\"a\", rx, ry, 0, 1, 0, 2 * rx, 0],\n    [\"a\", rx, ry, 0, 1, 0, -2 * rx, 0],\n  ];\n};\n\n/**\n * Returns a new `pathArray` like from rect attributes.\n *\n * @param attr object with properties above\n * @return a new `pathArray` from `<rect>` attributes\n */\nexport const getRectanglePath = (attr: RectAttr): PathArray => {\n  const x = +attr.x || 0;\n  const y = +attr.y || 0;\n  const w = +attr.width;\n  const h = +attr.height;\n  let rx = +(attr.rx || 0);\n  let ry = +(attr.ry || rx);\n\n  // Validity checks from http://www.w3.org/TR/SVG/shapes.html#RectElement:\n  if (rx || ry) {\n    // rx = !rx ? ry : rx;\n    // ry = !ry ? rx : ry;\n\n    /* istanbul ignore else @preserve */\n    if (rx * 2 > w) rx -= (rx * 2 - w) / 2;\n    /* istanbul ignore else @preserve */\n    if (ry * 2 > h) ry -= (ry * 2 - h) / 2;\n\n    return [\n      [\"M\", x + rx, y],\n      [\"h\", w - rx * 2],\n      [\"s\", rx, 0, rx, ry],\n      [\"v\", h - ry * 2],\n      [\"s\", 0, ry, -rx, ry],\n      [\"h\", -w + rx * 2],\n      [\"s\", -rx, 0, -rx, -ry],\n      [\"v\", -h + ry * 2],\n      [\"s\", 0, -ry, rx, -ry],\n    ];\n  }\n\n  return [[\"M\", x, y], [\"h\", w], [\"v\", h], [\"H\", x], [\"Z\"]];\n};\n\n/**\n * Returns a new `pathArray` created from attributes of a `<line>`, `<polyline>`,\n * `<polygon>`, `<rect>`, `<ellipse>`, `<circle>`, <path> or `<glyph>`.\n *\n * It can also work with an options object, see the type below\n * @see ShapeOps\n *\n * @param element target shape\n * @return the newly created `<path>` element\n */\nconst shapeToPathArray = (\n  element: ShapeTypes | ShapeOps,\n) => {\n  const supportedShapes = Object.keys(shapeParams) as (keyof ShapeParams)[];\n  const targetIsElement = isElement(element);\n  const tagName = targetIsElement ? element.tagName : null;\n\n  if (tagName && [...supportedShapes, \"path\"].every((s) => tagName !== s)) {\n    throw TypeError(`${error}: \"${tagName}\" is not SVGElement`);\n  }\n\n  const type =\n    (targetIsElement ? tagName : (element as ShapeOps).type) as ShapeOps[\n      \"type\"\n    ];\n  const shapeAttrs = shapeParams[type] as string[];\n  const config = { type } as Record<string, string>;\n\n  if (targetIsElement) {\n    shapeAttrs.forEach((p) => {\n      config[p] = element.getAttribute(p) as string;\n    });\n  } else {\n    Object.assign(config, element);\n  }\n\n  // set d\n  let pathArray = [] as unknown as PathArray;\n\n  /* istanbul ignore else */\n  if (type === \"circle\") {\n    pathArray = getCirclePath(config as unknown as CircleAttr);\n  } else if (type === \"ellipse\") {\n    pathArray = getEllipsePath(config as unknown as EllipseAttr);\n  } else if ([\"polyline\", \"polygon\"].includes(type)) {\n    pathArray = getPolyPath(config as unknown as PolyAttr);\n  } else if (type === \"rect\") {\n    pathArray = getRectanglePath(config as unknown as RectAttr);\n  } else if (type === \"line\") {\n    pathArray = getLinePath(config as unknown as LineAttr);\n  } else if ([\"glyph\", \"path\"].includes(type)) {\n    pathArray = parsePathString(\n      targetIsElement\n        ? element.getAttribute(\"d\") || /* istanbul ignore next @preserve */ \"\"\n        : (element as GlyphAttr).d || \"\",\n    );\n  }\n\n  // replace target element\n  if (isPathArray(pathArray) && pathArray.length) {\n    return pathArray;\n  }\n  return false;\n};\nexport default shapeToPathArray;\n","import type { ShapeParams } from \"../interface\";\nimport type { ShapeOps, ShapeTypes } from \"../types\";\nimport pathToString from \"../convert/pathToString\";\nimport defaultOptions from \"../options/options\";\nimport error from \"../parser/error\";\nimport isValidPath from \"./isValidPath\";\nimport isElement from \"./isElement\";\nimport shapeToPathArray from \"./shapeToPathArray\";\nimport shapeParams from \"./shapeParams\";\n\n/**\n * Returns a new `<path>` element created from attributes of a `<line>`, `<polyline>`,\n * `<polygon>`, `<rect>`, `<ellipse>`, `<circle>` or `<glyph>`. If `replace` parameter\n * is `true`, it will replace the target. The default `ownerDocument` is your current\n * `document` browser page, if you want to use in server-side using `jsdom`, you can\n * pass the `jsdom` `document` to `ownDocument`.\n *\n * It can also work with an options object, see the type below\n * @see ShapeOps\n *\n * The newly created `<path>` element keeps all non-specific\n * attributes like `class`, `fill`, etc.\n *\n * @param element target shape\n * @param replace option to replace target\n * @param ownerDocument document for create element\n * @return the newly created `<path>` element\n */\nconst shapeToPath = (\n  element: ShapeTypes | ShapeOps,\n  replace?: boolean,\n  ownerDocument?: Document,\n): SVGPathElement | false => {\n  const doc = ownerDocument || document;\n  const supportedShapes = Object.keys(shapeParams) as (keyof ShapeParams)[];\n  const targetIsElement = isElement(element);\n  const tagName = targetIsElement ? element.tagName : null;\n\n  if (tagName === \"path\") {\n    throw TypeError(`${error}: \"${tagName}\" is already SVGPathElement`);\n  }\n  if (tagName && supportedShapes.every((s) => tagName !== s)) {\n    throw TypeError(`${error}: \"${tagName}\" is not SVGElement`);\n  }\n\n  const path = doc.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n  const type =\n    (targetIsElement ? tagName : (element as ShapeOps).type) as ShapeOps[\n      \"type\"\n    ];\n  const shapeAttrs = shapeParams[type] as string[];\n  const config = { type } as Record<string, string>;\n\n  // set d\n  const round = defaultOptions.round as number;\n  const pathArray = shapeToPathArray(element);\n  const description = pathArray && pathArray.length\n    ? pathToString(pathArray, round)\n    : \"\";\n\n  if (targetIsElement) {\n    shapeAttrs.forEach((p) => {\n      config[p] = element.getAttribute(p) as string;\n    });\n    // set no-specific shape attributes: fill, stroke, etc\n    Object.values(element.attributes).forEach(({ name, value }) => {\n      if (!shapeAttrs.includes(name)) path.setAttribute(name, value);\n    });\n  } else {\n    Object.assign(config, element);\n    // set no-specific shape attributes: fill, stroke, etc\n    Object.keys(config).forEach((k) => {\n      if (!shapeAttrs.includes(k) && k !== \"type\") {\n        path.setAttribute(\n          k.replace(/[A-Z]/g, (m) => `-${m.toLowerCase()}`),\n          config[k],\n        );\n      }\n    });\n  }\n\n  // replace target element\n  if (isValidPath(description)) {\n    path.setAttribute(\"d\", description);\n    if (replace && targetIsElement) {\n      element.before(path, element);\n      element.remove();\n    }\n    return path;\n  }\n  return false;\n};\n\nexport default shapeToPath;\n","import CSSMatrix from \"@thednp/dommatrix\";\n// import type { TransformObject } from '../interface';\nimport type { TransformObjectValues } from \"../types\";\n\n/**\n * Returns a transformation matrix to apply to `<path>` elements.\n *\n * @see TransformObjectValues\n *\n * @param transform the `transformObject`\n * @returns a new transformation matrix\n */\nconst getSVGMatrix = (transform: TransformObjectValues): CSSMatrix => {\n  let matrix = new CSSMatrix();\n  const { origin } = transform;\n  const [originX, originY] = origin as [number, number, number];\n  const { translate } = transform;\n  const { rotate } = transform;\n  const { skew } = transform;\n  const { scale } = transform;\n\n  // set translate\n  if (\n    Array.isArray(translate) &&\n    translate.length >= 2 &&\n    translate.every((x) => !Number.isNaN(+x)) &&\n    translate.some((x) => x !== 0)\n  ) {\n    matrix = matrix.translate(...(translate as [number, number, number?]));\n  } else if (typeof translate === \"number\" && !Number.isNaN(translate)) {\n    matrix = matrix.translate(translate);\n  }\n\n  if (rotate || skew || scale) {\n    // set SVG transform-origin, always defined\n    matrix = matrix.translate(originX, originY);\n\n    // set rotation\n    if (\n      Array.isArray(rotate) &&\n      rotate.length >= 2 &&\n      rotate.every((x) => !Number.isNaN(+x)) &&\n      rotate.some((x) => x !== 0)\n    ) {\n      matrix = matrix.rotate(...(rotate as [number, number, number?]));\n    } else if (typeof rotate === \"number\" && !Number.isNaN(rotate)) {\n      matrix = matrix.rotate(rotate);\n    }\n\n    // set skew(s)\n    if (\n      Array.isArray(skew) && skew.length === 2 && skew.every((x) =>\n        !Number.isNaN(+x)\n      ) && skew.some((x) => x !== 0)\n    ) {\n      matrix = skew[0] ? matrix.skewX(skew[0]) : matrix;\n      matrix = skew[1] ? matrix.skewY(skew[1]) : matrix;\n    } else if (typeof skew === \"number\" && !Number.isNaN(skew)) {\n      matrix = matrix.skewX(skew);\n    }\n\n    // set scale\n    if (\n      Array.isArray(scale) && scale.length >= 2 && scale.every((x) =>\n        !Number.isNaN(+x)\n      ) && scale.some((x) => x !== 1)\n    ) {\n      matrix = matrix.scale(...(scale as [number, number, number?]));\n    } else if (typeof scale === \"number\" && !Number.isNaN(scale)) {\n      matrix = matrix.scale(scale);\n    }\n    // set SVG transform-origin\n    matrix = matrix.translate(-originX, -originY);\n  }\n\n  return matrix;\n};\nexport default getSVGMatrix;\n","import defaultOptions from \"../options/options\";\nimport type { ParserParams } from \"../interface\";\nimport roundTo from \"../math/roundTo\";\nimport type {\n  AbsoluteSegment,\n  NormalSegment,\n  PathCommand,\n  ShortSegment,\n  SSegment,\n  TSegment,\n} from \"../types\";\n\n/**\n * Shorten a single segment of a `pathArray` object.\n *\n * @param segment the `absoluteSegment` object\n * @param normalSegment the `normalSegment` object\n * @param params the coordinates of the previous segment\n * @param prevCommand the path command of the previous segment\n * @returns the shortened segment\n */\nconst shortenSegment = (\n  segment: AbsoluteSegment,\n  normalSegment: NormalSegment,\n  params: ParserParams,\n  prevCommand: PathCommand,\n): ShortSegment => {\n  const [pathCommand] = segment;\n  const { round: defaultRound } = defaultOptions;\n  const round = typeof defaultRound === \"number\"\n    ? defaultRound\n    : /* istanbul ignore next */ 4;\n  const normalValues = normalSegment.slice(1) as number[];\n  const { x1, y1, x2, y2, x, y } = params;\n  const [nx, ny] = normalValues.slice(-2);\n  const result = segment;\n\n  if (!\"TQ\".includes(pathCommand)) {\n    // optional but good to be cautious\n    params.qx = null;\n    params.qy = null;\n  }\n\n  if (pathCommand === \"L\") {\n    if (roundTo(x, round) === roundTo(nx, round)) {\n      return [\"V\", ny];\n    } else if (roundTo(y, round) === roundTo(ny, round)) {\n      return [\"H\", nx];\n    }\n  } else if (pathCommand === \"C\") {\n    const [nx1, ny1] = normalValues;\n    params.x1 = nx1;\n    params.y1 = ny1;\n\n    if (\n      \"CS\".includes(prevCommand) &&\n      ((roundTo(nx1, round) === roundTo(x1 * 2 - x2, round) &&\n        roundTo(ny1, round) === roundTo(y1 * 2 - y2, round)) ||\n        (roundTo(x1, round) === roundTo(x2 * 2 - x, round) &&\n          roundTo(y1, round) === roundTo(y2 * 2 - y, round)))\n    ) {\n      return [\n        \"S\",\n        normalValues[2],\n        normalValues[3],\n        normalValues[4],\n        normalValues[5],\n      ] as SSegment;\n    }\n  } else if (pathCommand === \"Q\") {\n    const [qx, qy] = normalValues;\n    params.qx = qx;\n    params.qy = qy;\n\n    if (\n      \"QT\".includes(prevCommand) &&\n      roundTo(qx, round) === roundTo(x1 * 2 - x2, round) &&\n      roundTo(qy, round) === roundTo(y1 * 2 - y2, round)\n    ) {\n      return [\"T\", normalValues[2], normalValues[3]] as TSegment;\n    }\n  }\n\n  // ['V', 'H', 'S', 'T', 'Z'].includes(pathCommand)\n  return result as ShortSegment;\n};\n\nexport default shortenSegment;\n","import type { PathCommand, PathSegment } from \"../types\";\nimport roundTo from \"../math/roundTo\";\n\nconst roundSegment = <T extends PathSegment>(\n  segment: T,\n  roundOption: number,\n) => {\n  const values = (segment.slice(1) as number[]).map((n) =>\n    roundTo(n, roundOption)\n  );\n  return [segment[0] as PathCommand | number].concat(values) as T;\n};\n\nexport default roundSegment;\n","import type { AbsoluteSegment, PathArray, PathCommand } from \"../types\";\nimport pathToAbsolute from \"../convert/pathToAbsolute\";\nimport shortenSegment from \"./shortenSegment\";\nimport paramsParser from \"../parser/paramsParser\";\nimport iterate from \"./iterate\";\nimport normalizeSegment from \"./normalizeSegment\";\nimport relativizeSegment from \"./relativizeSegment\";\nimport roundSegment from \"./roundSegment\";\n\n/**\n * Optimizes a `pathArray` object:\n * * convert segments to shorthand if possible\n * * select shortest segments from absolute and relative `pathArray`s\n *\n * @param pathInput a string or `pathArray`\n * @param roundOption the amount of decimals to round values to\n * @returns the optimized `pathArray`\n */\nconst optimizePath = (pathInput: PathArray, roundOption?: number) => {\n  const path = pathToAbsolute(pathInput);\n  // allow for ZERO decimals or use an aggressive value of 2\n  const round = typeof roundOption === \"number\" && roundOption >= 0\n    ? roundOption\n    : /* istanbul ignore next @preserve */ 2;\n  // this utility overrides the iterator params\n  const optimParams = { ...paramsParser };\n\n  const allPathCommands = [] as PathCommand[];\n  let pathCommand = \"M\" as PathCommand;\n  let prevCommand = \"Z\" as PathCommand;\n\n  return iterate(path, (seg, i, lastX, lastY) => {\n    optimParams.x = lastX;\n    optimParams.y = lastY;\n    const normalizedSegment = normalizeSegment(seg, optimParams);\n    let result = seg;\n    [pathCommand] = seg;\n\n    // Save current path command\n    allPathCommands[i] = pathCommand;\n    if (i) {\n      // Get previous path command for `shortenSegment`\n      prevCommand = allPathCommands[i - 1];\n      const shortSegment = shortenSegment(\n        seg as AbsoluteSegment,\n        normalizedSegment,\n        optimParams,\n        prevCommand,\n      );\n      const absSegment = roundSegment(shortSegment, round);\n      const absString = absSegment.join(\"\");\n      const relativeSegment = relativizeSegment(shortSegment, i, lastX, lastY);\n      const relSegment = roundSegment(relativeSegment, round);\n      const relString = relSegment.join(\"\");\n      result = absString.length < relString.length ? absSegment : relSegment;\n    }\n\n    const seglen = normalizedSegment.length;\n    optimParams.x1 = +normalizedSegment[seglen - 2];\n    optimParams.y1 = +normalizedSegment[seglen - 1];\n    optimParams.x2 = +normalizedSegment[seglen - 4] || optimParams.x1;\n    optimParams.y2 = +normalizedSegment[seglen - 3] || optimParams.y1;\n\n    return result;\n  });\n};\n\nexport default optimizePath;\n","import CSSMatrix from \"@thednp/dommatrix\";\nimport { type PointTuple } from \"../types\";\n\n/**\n * Transforms a specified point using a matrix, returning a new\n * Tuple *Object* comprising of the transformed point.\n * Neither the matrix nor the original point are altered.\n *\n * @copyright thednp © 2021\n *\n * @param cssm CSSMatrix instance\n * @param v Tuple\n * @return the resulting Tuple\n */\nconst translatePoint = (\n  cssm: CSSMatrix,\n  v: [number, number, number, number],\n): [number, number, number, number] => {\n  let m = CSSMatrix.Translate(v[0], v[1], v[2]);\n\n  [, , , m.m44] = v;\n  m = cssm.multiply(m);\n\n  return [m.m41, m.m42, m.m43, m.m44];\n};\n\n/**\n * Returns the [x,y] projected coordinates for a given an [x,y] point\n * and an [x,y,z] perspective origin point.\n *\n * Equation found here =>\n * http://en.wikipedia.org/wiki/3D_projection#Diagram\n * Details =>\n * https://stackoverflow.com/questions/23792505/predicted-rendering-of-css-3d-transformed-pixel\n *\n * @param m the transformation matrix\n * @param point2D the initial [x,y] coordinates\n * @param origin the [x,y,z] transform origin\n * @returns the projected [x,y] coordinates\n */\nconst projection2d = (\n  m: CSSMatrix,\n  point2D: PointTuple,\n  origin: [number, number, number],\n): PointTuple => {\n  const [originX, originY, originZ] = origin;\n  const [x, y, z] = translatePoint(m, [point2D[0], point2D[1], 0, 1]);\n\n  const relativePositionX = x - originX;\n  const relativePositionY = y - originY;\n  const relativePositionZ = z - originZ;\n\n  return [\n    // protect against division by ZERO\n    relativePositionX * (Math.abs(originZ) / Math.abs(relativePositionZ) || 1) +\n    originX,\n    relativePositionY * (Math.abs(originZ) / Math.abs(relativePositionZ) || 1) +\n    originY,\n  ];\n};\nexport default projection2d;\n","import type { CSegment, CurveArray, MSegment, PathCommand } from \"../types\";\n\n/**\n * Reverses all segments of a `pathArray`\n * which consists of only C (cubic-bezier) path commands.\n *\n * @param path the source `pathArray`\n * @returns the reversed `pathArray`\n */\nconst reverseCurve = (path: CurveArray) => {\n  const rotatedCurve = path\n    .slice(1)\n    .map((x, i, curveOnly) =>\n      !i\n        ? path[0].slice(1).concat(x.slice(1) as number[])\n        : curveOnly[i - 1].slice(-2).concat(x.slice(1))\n    )\n    .map((x) => x.map((_, i) => x[x.length - i - 2 * (1 - (i % 2))]))\n    .reverse() as (MSegment | CSegment)[];\n\n  return [[\"M\" as PathCommand | number].concat(rotatedCurve[0].slice(0, 2))]\n    .concat(\n      rotatedCurve.map((x) => [\"C\" as PathCommand | number].concat(x.slice(2))),\n    ) as CurveArray;\n};\n\nexport default reverseCurve;\n","import type {\n  ASegment,\n  CSegment,\n  HSegment,\n  MSegment,\n  PathArray,\n  PathSegment,\n  PointTuple,\n  QSegment,\n  SSegment,\n  TSegment,\n  VSegment,\n} from \"../types\";\nimport pathToAbsolute from \"../convert/pathToAbsolute\";\nimport normalizePath from \"./normalizePath\";\nimport iterate from \"./iterate\";\n\n/**\n * Reverses all segments of a `pathArray` and returns a new `pathArray` instance\n * with absolute values.\n *\n * @param pathInput the source `pathArray`\n * @returns the reversed `pathArray`\n */\nconst reversePath = (pathInput: PathArray) => {\n  const absolutePath = pathToAbsolute(pathInput);\n  const normalizedPath = normalizePath(absolutePath);\n  const pLen = absolutePath.length;\n  const isClosed = absolutePath[pLen - 1][0] === \"Z\";\n\n  const reversedPath = iterate(absolutePath, (segment, i) => {\n    const normalizedSegment = normalizedPath[i];\n    const prevSeg = i && absolutePath[i - 1];\n    const prevCommand = prevSeg && prevSeg[0];\n    const nextSeg = absolutePath[i + 1];\n    const nextCommand = nextSeg && nextSeg[0];\n    const [pathCommand] = segment;\n    const [x, y] = normalizedPath[i ? i - 1 : pLen - 1].slice(-2) as PointTuple;\n    let result = segment;\n\n    switch (pathCommand) {\n      case \"M\":\n        result = (isClosed ? [\"Z\"] : [pathCommand, x, y]) as PathSegment;\n        break;\n      case \"A\":\n        result = [\n          pathCommand,\n          segment[1],\n          segment[2],\n          segment[3],\n          segment[4],\n          segment[5] === 1 ? 0 : 1,\n          x,\n          y,\n        ] as ASegment;\n        break;\n      case \"C\":\n        if (nextSeg && nextCommand === \"S\") {\n          result = [\"S\", segment[1], segment[2], x, y] as SSegment;\n        } else {\n          result = [\n            pathCommand,\n            segment[3],\n            segment[4],\n            segment[1],\n            segment[2],\n            x,\n            y,\n          ] as CSegment;\n        }\n        break;\n      case \"S\":\n        if (\n          prevCommand && \"CS\".includes(prevCommand) &&\n          (!nextSeg || nextCommand !== \"S\")\n        ) {\n          result = [\n            \"C\",\n            normalizedSegment[3],\n            normalizedSegment[4],\n            normalizedSegment[1],\n            normalizedSegment[2],\n            x,\n            y,\n          ] as CSegment;\n        } else {\n          result = [\n            pathCommand,\n            normalizedSegment[1],\n            normalizedSegment[2],\n            x,\n            y,\n          ] as SSegment;\n        }\n        break;\n      case \"Q\":\n        if (nextSeg && nextCommand === \"T\") {\n          result = [\"T\", x, y] as TSegment;\n        } else {\n          result = [pathCommand, segment[1], segment[2], x, y] as QSegment;\n        }\n        break;\n      case \"T\":\n        if (\n          prevCommand && \"QT\".includes(prevCommand) &&\n          (!nextSeg || nextCommand !== \"T\")\n        ) {\n          result = [\n            \"Q\",\n            normalizedSegment[1],\n            normalizedSegment[2],\n            x,\n            y,\n          ] as QSegment;\n        } else {\n          result = [pathCommand, x, y] as TSegment;\n        }\n        break;\n      case \"Z\":\n        result = [\"M\", x, y] as MSegment;\n        break;\n      case \"H\":\n        result = [pathCommand, x] as HSegment;\n        break;\n      case \"V\":\n        result = [pathCommand, y] as VSegment;\n        break;\n      default:\n        result = [pathCommand as typeof pathCommand | number].concat(\n          segment.slice(1, -2),\n          x,\n          y,\n        ) as PathSegment;\n    }\n\n    return result;\n  });\n\n  return (\n    isClosed\n      ? reversedPath.reverse()\n      : [reversedPath[0] as PathSegment].concat(reversedPath.slice(1).reverse())\n  ) as PathArray;\n};\n\nexport default reversePath;\n","import type { PathArray } from \"../types\";\nimport defaultOptions from \"../options/options\";\nimport iterate from \"./iterate\";\nimport roundSegment from \"./roundSegment\";\n\n/**\n * Rounds the values of a `pathArray` instance to\n * a specified amount of decimals and returns it.\n *\n * @param path the source `pathArray`\n * @param roundOption the amount of decimals to round numbers to\n * @returns the resulted `pathArray` with rounded values\n */\nconst roundPath = (path: PathArray, roundOption?: number | \"off\") => {\n  let { round } = defaultOptions;\n  // allow for ZERO decimals\n  round = roundOption === \"off\"\n    ? roundOption\n    : typeof roundOption === \"number\" && roundOption >= 0\n    ? roundOption\n    : typeof round === \"number\" && round >= 0\n    ? round\n    : /* istanbul ignore next @preserve */ \"off\";\n\n  /* istanbul ignore else @preserve */\n  if (round === \"off\") return path.slice(0) as PathArray;\n\n  return iterate<typeof path>(path, (segment) => {\n    return roundSegment(segment, round);\n  });\n};\nexport default roundPath;\n","import midPoint from \"../math/midPoint\";\nimport type { CubicSegment, PointTuple } from \"../types\";\n\n/**\n * Split a cubic-bezier segment into two.\n *\n * @param pts the cubic-bezier parameters\n * @param ratio the cubic-bezier parameters\n * @return two new cubic-bezier segments\n */\nconst splitCubic = (\n  pts: number[],\n  ratio = 0.5,\n): [CubicSegment, CubicSegment] => {\n  const t = ratio;\n  const p0 = pts.slice(0, 2) as PointTuple;\n  const p1 = pts.slice(2, 4) as PointTuple;\n  const p2 = pts.slice(4, 6) as PointTuple;\n  const p3 = pts.slice(6, 8) as PointTuple;\n  const p4 = midPoint(p0, p1, t);\n  const p5 = midPoint(p1, p2, t);\n  const p6 = midPoint(p2, p3, t);\n  const p7 = midPoint(p4, p5, t);\n  const p8 = midPoint(p5, p6, t);\n  const p9 = midPoint(p7, p8, t);\n\n  return [\n    [\"C\", p4[0], p4[1], p7[0], p7[1], p9[0], p9[1]],\n    [\"C\", p8[0], p8[1], p6[0], p6[1], p3[0], p3[1]],\n  ];\n};\nexport default splitCubic;\n","import paramsParser from \"../parser/paramsParser\";\nimport type {\n  AbsoluteCommand,\n  HSegment,\n  MSegment,\n  PathArray,\n  PointTuple,\n  RelativeCommand,\n  VSegment,\n} from \"../types\";\n\n/**\n * Split a path into an `Array` of sub-path strings.\n *\n * In the process, values are converted to absolute\n * for visual consistency.\n *\n * @param pathInput the source `pathArray`\n * @return an array with all sub-path strings\n */\nconst splitPath = (pathInput: PathArray): PathArray[] => {\n  const composite = [] as PathArray[];\n  let path: PathArray;\n  let pi = -1;\n  let x = 0;\n  let y = 0;\n  let mx = 0;\n  let my = 0;\n  const params = { ...paramsParser };\n\n  pathInput.forEach((seg) => {\n    const [pathCommand] = seg;\n    const absCommand = pathCommand.toUpperCase() as AbsoluteCommand;\n    const relCommand = pathCommand.toLowerCase() as RelativeCommand;\n    const isRelative = pathCommand === relCommand;\n    const values = seg.slice(1) as number[];\n\n    if (absCommand === \"M\") {\n      pi += 1;\n      [x, y] = values as PointTuple;\n      x += isRelative ? params.x : 0;\n      y += isRelative ? params.y : 0;\n      mx = x;\n      my = y;\n      path = [(isRelative ? [absCommand, mx, my] : seg) as MSegment];\n    } else {\n      if (absCommand === \"Z\") {\n        x = mx;\n        y = my;\n      } else if (absCommand === \"H\") {\n        [, x] = seg as HSegment;\n        x += isRelative ? params.x : /* istanbul ignore next @preserve */ 0;\n      } else if (absCommand === \"V\") {\n        [, y] = seg as VSegment;\n        y += isRelative ? params.y : /* istanbul ignore next @preserve */ 0;\n      } else {\n        [x, y] = seg.slice(-2) as PointTuple;\n        x += isRelative ? params.x : 0;\n        y += isRelative ? params.y : 0;\n      }\n      path.push(seg);\n    }\n\n    params.x = x;\n    params.y = y;\n    composite[pi] = path;\n  });\n\n  return composite;\n};\nexport default splitPath;\n","import getSVGMatrix from \"./getSVGMatrix\";\nimport projection2d from \"./projection2d\";\nimport defaultOptions from \"../options/options\";\nimport type {\n  AbsoluteArray,\n  AbsoluteSegment,\n  CSegment,\n  LSegment,\n  PathArray,\n  TransformObjectValues,\n} from \"../types\";\nimport type { TransformObject } from \"../interface\";\nimport iterate from \"./iterate\";\nimport parsePathString from \"../parser/parsePathString\";\nimport absolutizeSegment from \"./absolutizeSegment\";\nimport arcToCubic from \"./arcToCubic\";\n\n/**\n * Apply a 2D / 3D transformation to a `pathArray` instance.\n *\n * Since *SVGElement* doesn't support 3D transformation, this function\n * creates a 2D projection of the <path> element.\n *\n * @param path the `pathArray` to apply transformation\n * @param transform the transform functions `Object`\n * @returns the resulted `pathArray`\n */\nconst transformPath = (\n  pathInput: PathArray | string,\n  transform?: Partial<TransformObject>,\n) => {\n  // last x and y transformed values\n  let x = 0;\n  let y = 0;\n  // new x and y transformed\n  let lx = 0;\n  let ly = 0;\n  // segment params iteration index and length\n  let j = 0;\n  let jj = 0;\n  let pathCommand = \"M\";\n  // transform uses it's own set of params\n  const path = parsePathString(pathInput);\n  const transformProps = transform && Object.keys(transform);\n\n  // when used as a static method, invalidate somehow\n  if (!transform || (transformProps && !transformProps.length)) {\n    return path.slice(0) as typeof path;\n  }\n\n  // transform origin is extremely important\n  if (!transform.origin) {\n    Object.assign(transform, { origin: defaultOptions.origin });\n  }\n  const origin = transform.origin as [number, number, number];\n  const matrixInstance = getSVGMatrix(transform as TransformObjectValues);\n\n  if (matrixInstance.isIdentity) return path.slice(0) as typeof path;\n\n  return iterate<AbsoluteArray>(path, (seg, index, lastX, lastY) => {\n    [pathCommand] = seg;\n    const absCommand = pathCommand.toUpperCase();\n    const isRelative = absCommand !== pathCommand;\n    const absoluteSegment = isRelative\n      ? absolutizeSegment(seg, index, lastX, lastY)\n      : (seg.slice(0) as AbsoluteSegment);\n\n    let result = absCommand === \"A\"\n      // ? segmentToCubic(absoluteSegment, transformParams)\n      ? ([\"C\" as string | number].concat(\n        arcToCubic(\n          lastX,\n          lastY,\n          absoluteSegment[1] as number,\n          absoluteSegment[2] as number,\n          absoluteSegment[3] as number,\n          absoluteSegment[4] as number,\n          absoluteSegment[5] as number,\n          absoluteSegment[6] as number,\n          absoluteSegment[7] as number,\n        ),\n      ) as CSegment)\n      : absCommand === \"V\"\n      ? ([\"L\", lastX, absoluteSegment[1]] as LSegment)\n      : absCommand === \"H\"\n      ? ([\"L\", absoluteSegment[1], lastY] as LSegment)\n      : absoluteSegment;\n\n    // update pathCommand\n    pathCommand = result[0];\n    const isLongArc = pathCommand === \"C\" && result.length > 7;\n    const tempSegment =\n      (isLongArc ? result.slice(0, 7) : result.slice(0)) as AbsoluteSegment;\n\n    if (isLongArc) {\n      path.splice(\n        index + 1,\n        0,\n        [\"C\" as typeof pathCommand | number].concat(\n          result.slice(7),\n        ) as CSegment,\n      );\n      result = tempSegment as CSegment;\n    }\n\n    if (pathCommand === \"L\") {\n      [lx, ly] = projection2d(matrixInstance, [\n        (result as LSegment)[1],\n        (result as LSegment)[2],\n      ], origin);\n\n      /* istanbul ignore else @preserve */\n      if (x !== lx && y !== ly) {\n        result = [\"L\", lx, ly];\n      } else if (y === ly) {\n        result = [\"H\", lx];\n      } else if (x === lx) {\n        result = [\"V\", ly];\n      }\n    } else {\n      for (j = 1, jj = result.length; j < jj; j += 2) {\n        [lx, ly] = projection2d(\n          matrixInstance,\n          [+result[j], +result[j + 1]],\n          origin,\n        );\n        result[j] = lx;\n        result[j + 1] = ly;\n      }\n    }\n    // now update x and y\n    x = lx;\n    y = ly;\n\n    return result;\n  });\n};\n\nexport default transformPath;\n"],"mappings":"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","names":["util_exports","__export","y","absolutizeSegment_default","arcToCubic_default","arcTools_exports","bezier_exports","cubicTools_exports","distanceEpsilon_default","distanceSquareRoot_default","finalizeSegment_default","getClosestPoint_default","getDrawDirection_default","getPathArea_default","getPathBBox_default","getPointAtLength_default","getPropertiesAtLength_default","getPropertiesAtPoint_default","getSVGMatrix_default","getSegmentAtLength_default","getSegmentOfPoint_default","getTotalLength_default","invalidPathValue_default","isAbsoluteArray_default","isArcCommand_default","isCurveArray_default","isDigit_default","isDigitStart_default","isMoveCommand_default","isNormalizedArray_default","isPathArray_default","isPathCommand_default","isPointInStroke_default","isRelativeArray_default","isSpace_default","isValidPath_default","iterate_default","lineToCubic_default","lineTools_exports","midPoint_default","normalizePath_default","normalizeSegment_default","optimizePath_default","paramsCount_default","paramsParser_default","parsePathString_default","PathParser","pathToAbsolute_default","pathToCurve_default","pathToRelative_default","pathToString_default","polygonTools_exports","projection2d_default","quadToCubic_default","quadTools_exports","relativizeSegment_default","reverseCurve_default","reversePath_default","rotateVector_default","roundPath_default","roundSegment_default","roundTo_default","scanFlag_default","scanParam_default","scanSegment_default","segmentToCubic_default","shapeParams_default","shapeToPath_default","shapeToPathArray_default","shortenSegment_default","skipSpaces_default","splitCubic_default","splitPath_default","transformPath_default","JSON_MATRIX","isCompatibleArray","array","x","isCompatibleObject","object","CSSMatrix","k","fromArray","m","a","m11","m12","m13","m14","m21","m22","m23","m24","m31","m32","m33","m34","m41","m42","m43","m44","M11","M12","M21","M22","M41","M42","fromMatrix","fromString","source","str","invalidStringError","f","tf","prop","value","components","n","y","z","xyz","xyza","values","sy","p","fn","axis","idx","def","axeValues","toArray","is2D","Translate","Rotate","rx","ry","rz","degToRad","radX","radY","radZ","cosx","sinx","cosy","siny","cosz","sinz","RotateAxisAngle","alpha","length","X","Y","Z","angle","sinA","cosA","sinA2","x2","y2","z2","Scale","Skew","angleX","angleY","tX","tY","SkewX","SkewY","Multiply","m1","m2","init","isIdentity","RX","RY","RZ","t","w","__publicField","arcTools_exports","__export","angleBetween","arcLength","arcPoint","getArcBBox","getArcLength","getArcProps","getPointAtArcLength","lineTools_exports","__export","getLineBBox","getLineLength","getPointAtLineLength","midPoint","a","b","t","ax","ay","bx","by","midPoint_default","distanceSquareRoot","a","b","distanceSquareRoot_default","getLineLength","x1","y1","x2","y2","distanceSquareRoot_default","getPointAtLineLength","distance","point","length","x","y","midPoint_default","getLineBBox","min","max","arcLength","rx","ry","theta","halfTheta","sinHalfTheta","cosHalfTheta","term1","term2","length","arcPoint","cx","cy","alpha","sin","cos","cosA","sinA","x","y","angleBetween","v0","v1","v0x","v0y","v1x","v1y","p","n","getArcProps","x1","y1","RX","RY","angle","LAF","SF","abs","sqrt","PI","xRotRad","dx","dy","transformedPoint","radiiCheck","cSquareNumerator","cSquareRootDenom","cRadicand","cCoef","transformedCenter","center","startVector","startAngle","endVector","sweepAngle","endAngle","getArcLength","getPointAtArcLength","distance","point","getPointAtLineLength","ellipseComponentX","ellipseComponentY","getArcBBox","deltaAngle","min","max","tan","atan2","tangent","angle1","angle2","angle3","angle4","xArray","yArray","xMin","xMax","yMin","yMax","angleAfterStart","pP2","angleBeforeEnd","pP3","p1","p2","p4","p3","bezier_exports","__export","CBEZIER_MINMAX_EPSILON","Cvalues","Tvalues","bezierLength","calculateBezier","computeBezier","deriveBezier","getBezierLength","minmaxC","minmaxQ","points","dpoints","p","d","c","list","j","t","order","mt","mt2","t2","a","b","derivativeFn","l","len","sum","i","curve","idx","step","v1","cp","v2","min","max","E","cp1","cp2","K","T","S","L","R","Q","cubicTools_exports","__export","getCubicBBox","getCubicLength","getPointAtCubicLength","getPointAtCubicSegmentLength","getPointAtCubicSegmentLength","x1","y1","c1x","c1y","c2x","c2y","x2","y2","t","t1","getCubicLength","getBezierLength","getPointAtCubicLength","distance","distanceIsNumber","point","currentLength","getCubicBBox","cxMinMax","minmaxC","cyMinMax","quadTools_exports","__export","getPointAtQuadLength","getPointAtQuadSegmentLength","getQuadBBox","getQuadLength","getPointAtQuadSegmentLength","x1","y1","cx","cy","x2","y2","t","t1","getQuadLength","getBezierLength","getPointAtQuadLength","distance","distanceIsNumber","point","currentLength","getQuadBBox","cxMinMax","minmaxQ","cyMinMax","polygonTools_exports","__export","polygonArea","polygonLength","polygonArea","polygon","n","i","a","b","area","polygonLength","length","point","distanceSquareRoot_default","paramsCount","paramsCount_default","finalizeSegment","path","pathCommand","relativeCommand","data","paramsCount_default","finalizeSegment_default","error","error_default","scanFlag","path","index","pathValue","code","error_default","scanFlag_default","isDigit","code","isDigit_default","invalidPathValue","invalidPathValue_default","scanParam","path","max","pathValue","start","index","zeroFirst","hasCeiling","hasDecimal","hasDot","ch","error_default","invalidPathValue_default","isDigit_default","scanParam_default","isSpace","ch","isSpace_default","skipSpaces","path","pathValue","max","isSpace_default","skipSpaces_default","isPathCommand","code","isPathCommand_default","isDigitStart","code","isDigit_default","isDigitStart_default","isArcCommand","code","isArcCommand_default","isMoveCommand","code","isMoveCommand_default","scanSegment","path","max","pathValue","index","segments","cmdCode","reqParams","paramsCount_default","isPathCommand_default","error_default","invalidPathValue_default","lastSegment","isMoveCommand_default","skipSpaces_default","finalizeSegment_default","i","isArcCommand_default","scanFlag_default","scanParam_default","isDigitStart_default","scanSegment_default","PathParser","pathString","parsePathString","pathInput","path","PathParser","skipSpaces_default","scanSegment_default","parsePathString_default","absolutizeSegment","segment","index","lastX","lastY","pathCommand","absCommand","isAbsolute","absValues","seglen","j","absolutizeSegment_default","iterate","path","iterator","pathLen","segment","pathCommand","absCommand","isRelative","x","y","mx","my","segLen","i","iteratorResult","iterate_default","pathToAbsolute","pathInput","path","parsePathString_default","iterate_default","absolutizeSegment_default","pathToAbsolute_default","relativizeSegment","segment","index","lastX","lastY","pathCommand","relCommand","isRelative","relValues","seglen","j","relativizeSegment_default","pathToRelative","pathInput","path","parsePathString_default","iterate_default","relativizeSegment_default","pathToRelative_default","rotateVector","x","y","rad","sin","cos","X","Y","rotateVector_default","arcToCubic","X1","Y1","RX","RY","angle","LAF","SF","X2","Y2","recursive","x1","y1","rx","ry","x2","y2","d120","rad","res","xy","f1","f2","cx","cy","rotateVector_default","x","y","h","rx2","ry2","k","df","f2old","x2old","y2old","c1","s1","c2","s2","t","hx","hy","m1","m2","m3","m4","newres","i","ii","arcToCubic_default","quadToCubic","x1","y1","qx","qy","x2","y2","r13","r23","quadToCubic_default","lineToCubic","x1","y1","x2","y2","c1","midPoint_default","c2","lineToCubic_default","segmentToCubic","segment","params","pathCommand","values","x","y","px1","py1","px","py","arcToCubic_default","quadToCubic_default","lineToCubic_default","segmentToCubic_default","normalizeSegment","segment","params","pathCommand","absCommand","isRelative","px1","py1","px2","py2","x","y","values","absValues","n","j","x1","y1","qx","qy","nqx","nqy","normalizeSegment_default","paramsParser","paramsParser_default","pathToCurve","pathInput","params","paramsParser_default","path","parsePathString_default","iterate_default","seg","index","lastX","lastY","normalSegment","normalizeSegment_default","result","segmentToCubic_default","seglen","pathToCurve_default","defaultOptions","options_default","roundTo","n","round","pow","roundTo_default","pathToString","path","roundOption","pathLen","round","options_default","segment","result","i","pathCommand","values","j","valLen","roundTo_default","pathToString_default","distanceEpsilon_default","normalizePath","pathInput","path","parsePathString_default","params","paramsParser_default","iterate_default","seg","_","lastX","lastY","result","normalizeSegment_default","seglen","normalizePath_default","getPointAtLength","pathInput","distance","path","normalizePath_default","isM","data","pathCommand","x","y","mx","my","distanceIsNumber","point","length","POINT","totalLength","distanceEpsilon_default","iterate_default","seg","_","lastX","lastY","getPointAtLineLength","getLineLength","getPointAtArcLength","getArcLength","getPointAtCubicLength","getCubicLength","getPointAtQuadLength","getQuadLength","getPointAtLength_default","getTotalLength","pathInput","path","parsePathString_default","paramX1","paramY1","paramX2","paramY2","paramQX","paramQY","pathCommand","mx","my","totalLength","iterate_default","seg","index","lastX","lastY","absCommand","absoluteSegment","absolutizeSegment_default","normalSegment","getLineLength","getArcLength","cp1x","cp1y","getCubicLength","getQuadLength","getTotalLength_default","getPropertiesAtLength","pathInput","distance","pathArray","parsePathString_default","pathTemp","pathLength","getTotalLength_default","index","lengthAtSegment","length","segment","segments","l","getPropertiesAtLength_default","getPropertiesAtPoint","pathInput","point","path","parsePathString_default","normalPath","normalizePath_default","pathLength","getTotalLength_default","distanceTo","p","dx","dy","precision","scan","closest","scanDistance","bestLength","bestDistance","scanLength","getPointAtLength_default","before","after","beforeLength","afterLength","beforeDistance","afterDistance","segment","getPropertiesAtLength_default","distance","getPropertiesAtPoint_default","getClosestPoint","pathInput","point","getPropertiesAtPoint_default","getClosestPoint_default","getCubicSegArea","x1","y1","c1x","c1y","c2x","c2y","x2","y2","getPathArea","path","x","y","len","pathToCurve_default","seg","a","b","getPathArea_default","getDrawDirection","path","getPathArea_default","pathToCurve_default","getDrawDirection_default","getPathBBox","pathInput","path","parsePathString_default","pathCommand","mx","my","max","min","xMin","yMin","xMax","yMax","minX","minY","maxX","maxY","paramX1","paramY1","paramX2","paramY2","paramQX","paramQY","iterate_default","seg","index","lastX","lastY","absCommand","absoluteSegment","absolutizeSegment_default","normalSegment","getLineBBox","getArcBBox","cp1x","cp1y","getCubicBBox","getQuadBBox","width","height","getPathBBox_default","getSegmentAtLength","pathInput","distance","getPropertiesAtLength_default","getSegmentAtLength_default","getSegmentOfPoint","path","point","getPropertiesAtPoint_default","getSegmentOfPoint_default","isPathArray","path","seg","lk","paramsCount_default","isPathArray_default","isAbsoluteArray","path","isPathArray_default","x","isAbsoluteArray_default","isNormalizedArray","path","isAbsoluteArray_default","pc","isNormalizedArray_default","isCurveArray","path","isNormalizedArray_default","pc","isCurveArray_default","isPointInStroke","pathInput","point","distance","getPropertiesAtPoint_default","distanceEpsilon_default","isPointInStroke_default","isRelativeArray","path","isPathArray_default","pc","isRelativeArray_default","isValidPath","pathString","path","PathParser","skipSpaces_default","scanSegment_default","isValidPath_default","shapeParams","shapeParams_default","isElement","node","isElement_default","getLinePath","attr","x1","y1","x2","y2","getPolyPath","pathArray","points","a","index","getCirclePath","cx","cy","r","getEllipsePath","rx","ry","getRectanglePath","x","y","w","h","shapeToPathArray","element","supportedShapes","shapeParams_default","targetIsElement","isElement_default","tagName","error_default","type","shapeAttrs","config","p","parsePathString_default","isPathArray_default","shapeToPathArray_default","shapeToPath","element","replace","ownerDocument","doc","supportedShapes","shapeParams_default","targetIsElement","isElement_default","tagName","error_default","s","path","type","shapeAttrs","config","round","options_default","pathArray","shapeToPathArray_default","description","pathToString_default","p","name","value","k","m","isValidPath_default","shapeToPath_default","getSVGMatrix","transform","matrix","y","origin","originX","originY","translate","rotate","skew","scale","x","getSVGMatrix_default","shortenSegment","segment","normalSegment","params","prevCommand","pathCommand","defaultRound","options_default","round","normalValues","x1","y1","x2","y2","x","y","nx","ny","result","roundTo_default","nx1","ny1","qx","qy","shortenSegment_default","roundSegment","segment","roundOption","values","n","roundTo_default","roundSegment_default","optimizePath","pathInput","roundOption","path","pathToAbsolute_default","round","optimParams","paramsParser_default","allPathCommands","pathCommand","prevCommand","iterate_default","seg","i","lastX","lastY","normalizedSegment","normalizeSegment_default","result","shortSegment","shortenSegment_default","absSegment","roundSegment_default","absString","relativeSegment","relativizeSegment_default","relSegment","relString","seglen","optimizePath_default","translatePoint","cssm","v","m","y","projection2d","point2D","origin","originX","originY","originZ","x","z","relativePositionX","relativePositionY","relativePositionZ","projection2d_default","reverseCurve","path","rotatedCurve","x","i","curveOnly","_","reverseCurve_default","reversePath","pathInput","absolutePath","pathToAbsolute_default","normalizedPath","normalizePath_default","pLen","isClosed","reversedPath","iterate_default","segment","normalizedSegment","prevSeg","prevCommand","nextSeg","nextCommand","pathCommand","x","y","result","reversePath_default","roundPath","path","roundOption","round","options_default","iterate_default","segment","roundSegment_default","roundPath_default","splitCubic","pts","ratio","t","p0","p1","p2","p3","p4","midPoint_default","p5","p6","p7","p8","p9","splitCubic_default","splitPath","pathInput","composite","path","pi","x","y","mx","my","params","paramsParser_default","seg","pathCommand","absCommand","relCommand","isRelative","values","splitPath_default","transformPath","pathInput","transform","x","y","lx","ly","j","jj","pathCommand","path","parsePathString_default","transformProps","options_default","origin","matrixInstance","getSVGMatrix_default","iterate_default","seg","index","lastX","lastY","absCommand","absoluteSegment","absolutizeSegment_default","result","arcToCubic_default","isLongArc","tempSegment","projection2d_default","transformPath_default"]}