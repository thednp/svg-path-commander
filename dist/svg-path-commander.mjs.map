{"version":3,"file":"svg-path-commander.mjs","sources":["../node_modules/@thednp/dommatrix/dist/dommatrix.mjs","../src/options/options.ts","../src/parser/paramsCount.ts","../src/parser/finalizeSegment.ts","../src/parser/error.ts","../src/parser/scanFlag.ts","../src/parser/isDigit.ts","../src/parser/invalidPathValue.ts","../src/parser/scanParam.ts","../src/parser/isSpace.ts","../src/parser/skipSpaces.ts","../src/parser/isPathCommand.ts","../src/parser/isDigitStart.ts","../src/parser/isArcCommand.ts","../src/parser/isMoveCommand.ts","../src/parser/scanSegment.ts","../src/parser/pathParser.ts","../src/parser/parsePathString.ts","../src/process/absolutizeSegment.ts","../src/process/iterate.ts","../src/convert/pathToAbsolute.ts","../src/process/relativizeSegment.ts","../src/convert/pathToRelative.ts","../src/math/rotateVector.ts","../src/process/arcToCubic.ts","../src/process/quadToCubic.ts","../src/math/midPoint.ts","../src/process/lineToCubic.ts","../src/process/segmentToCubic.ts","../src/process/normalizeSegment.ts","../src/parser/paramsParser.ts","../src/convert/pathToCurve.ts","../src/math/roundTo.ts","../src/convert/pathToString.ts","../src/math/distanceSquareRoot.ts","../src/math/lineTools.ts","../src/math/arcTools.ts","../src/math/bezier.ts","../src/math/cubicTools.ts","../src/math/quadTools.ts","../src/math/polygonTools.ts","../src/util/distanceEpsilon.ts","../src/process/normalizePath.ts","../src/util/getPointAtLength.ts","../src/util/getTotalLength.ts","../src/util/getPropertiesAtLength.ts","../src/util/getPropertiesAtPoint.ts","../src/util/getClosestPoint.ts","../src/util/getPathArea.ts","../src/util/getDrawDirection.ts","../src/util/getPathBBox.ts","../src/util/getSegmentAtLength.ts","../src/util/getSegmentOfPoint.ts","../src/util/isPathArray.ts","../src/util/isAbsoluteArray.ts","../src/util/isNormalizedArray.ts","../src/util/isCurveArray.ts","../src/util/isPointInStroke.ts","../src/util/isRelativeArray.ts","../src/util/isValidPath.ts","../src/util/shapeParams.ts","../src/util/isElement.ts","../src/util/shapeToPathArray.ts","../src/util/shapeToPath.ts","../src/process/getSVGMatrix.ts","../src/process/shortenSegment.ts","../src/process/roundSegment.ts","../src/process/optimizePath.ts","../src/process/projection2d.ts","../src/process/reverseCurve.ts","../src/process/reversePath.ts","../src/process/roundPath.ts","../src/process/splitCubic.ts","../src/process/splitPath.ts","../src/process/transformPath.ts","../src/index.ts"],"sourcesContent":["var Z = Object.defineProperty;\nvar z = (s, t, e) => t in s ? Z(s, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : s[t] = e;\nvar p = (s, t, e) => z(s, typeof t != \"symbol\" ? t + \"\" : t, e);\nconst $ = {\n  a: 1,\n  b: 0,\n  c: 0,\n  d: 1,\n  e: 0,\n  f: 0,\n  m11: 1,\n  m12: 0,\n  m13: 0,\n  m14: 0,\n  m21: 0,\n  m22: 1,\n  m23: 0,\n  m24: 0,\n  m31: 0,\n  m32: 0,\n  m33: 1,\n  m34: 0,\n  m41: 0,\n  m42: 0,\n  m43: 0,\n  m44: 1,\n  is2D: !0,\n  isIdentity: !0\n}, E = (s) => (s instanceof Float64Array || s instanceof Float32Array || Array.isArray(s) && s.every((t) => typeof t == \"number\")) && [6, 16].some((t) => s.length === t), P = (s) => s instanceof DOMMatrix || s instanceof y || typeof s == \"object\" && Object.keys($).every((t) => s && t in s), g = (s) => {\n  const t = new y(), e = Array.from(s);\n  if (!E(e))\n    throw TypeError(\n      `CSSMatrix: \"${e.join(\",\")}\" must be an array with 6/16 numbers.`\n    );\n  // istanbul ignore else @preserve\n  if (e.length === 16) {\n    const [\n      n,\n      i,\n      r,\n      a,\n      l,\n      m,\n      h,\n      c,\n      u,\n      f,\n      w,\n      o,\n      d,\n      A,\n      M,\n      b\n    ] = e;\n    t.m11 = n, t.a = n, t.m21 = l, t.c = l, t.m31 = u, t.m41 = d, t.e = d, t.m12 = i, t.b = i, t.m22 = m, t.d = m, t.m32 = f, t.m42 = A, t.f = A, t.m13 = r, t.m23 = h, t.m33 = w, t.m43 = M, t.m14 = a, t.m24 = c, t.m34 = o, t.m44 = b;\n  } else if (e.length === 6) {\n    const [n, i, r, a, l, m] = e;\n    t.m11 = n, t.a = n, t.m12 = i, t.b = i, t.m21 = r, t.c = r, t.m22 = a, t.d = a, t.m41 = l, t.e = l, t.m42 = m, t.f = m;\n  }\n  return t;\n}, X = (s) => {\n  if (P(s))\n    return g([\n      s.m11,\n      s.m12,\n      s.m13,\n      s.m14,\n      s.m21,\n      s.m22,\n      s.m23,\n      s.m24,\n      s.m31,\n      s.m32,\n      s.m33,\n      s.m34,\n      s.m41,\n      s.m42,\n      s.m43,\n      s.m44\n    ]);\n  throw TypeError(\n    `CSSMatrix: \"${JSON.stringify(s)}\" is not a DOMMatrix / CSSMatrix / JSON compatible object.`\n  );\n}, O = (s) => {\n  if (typeof s != \"string\")\n    throw TypeError(`CSSMatrix: \"${JSON.stringify(s)}\" is not a string.`);\n  const t = String(s).replace(/\\s/g, \"\");\n  let e = new y();\n  const n = `CSSMatrix: invalid transform string \"${s}\"`;\n  return t.split(\")\").filter((i) => i).forEach((i) => {\n    const [r, a] = i.split(\"(\");\n    if (!a) throw TypeError(n);\n    const l = a.split(\",\").map(\n      (o) => o.includes(\"rad\") ? parseFloat(o) * (180 / Math.PI) : parseFloat(o)\n    ), [m, h, c, u] = l, f = [m, h, c], w = [m, h, c, u];\n    if (r === \"perspective\" && m && [h, c].every((o) => o === void 0))\n      e.m34 = -1 / m;\n    else if (r.includes(\"matrix\") && [6, 16].includes(l.length) && l.every((o) => !Number.isNaN(+o))) {\n      const o = l.map((d) => Math.abs(d) < 1e-6 ? 0 : d);\n      e = e.multiply(g(o));\n    } else if (r === \"translate3d\" && f.every((o) => !Number.isNaN(+o)))\n      e = e.translate(m, h, c);\n    else if (r === \"translate\" && m && c === void 0)\n      e = e.translate(m, h || 0, 0);\n    else if (r === \"rotate3d\" && w.every((o) => !Number.isNaN(+o)) && u)\n      e = e.rotateAxisAngle(m, h, c, u);\n    else if (r === \"rotate\" && m && [h, c].every((o) => o === void 0))\n      e = e.rotate(0, 0, m);\n    else if (r === \"scale3d\" && f.every((o) => !Number.isNaN(+o)) && f.some((o) => o !== 1))\n      e = e.scale(m, h, c);\n    else if (\n      // prop === \"scale\" && !Number.isNaN(x) && x !== 1 && z === undefined\n      // prop === \"scale\" && !Number.isNaN(x) && [x, y].some((n) => n !== 1) &&\n      r === \"scale\" && !Number.isNaN(m) && (m !== 1 || h !== 1) && c === void 0\n    ) {\n      const d = Number.isNaN(+h) ? m : h;\n      e = e.scale(m, d, 1);\n    } else if (r === \"skew\" && (m || !Number.isNaN(m) && h) && c === void 0)\n      e = e.skew(m, h || 0);\n    else if ([\"translate\", \"rotate\", \"scale\", \"skew\"].some(\n      (o) => r.includes(o)\n    ) && /[XYZ]/.test(r) && m && [h, c].every((o) => o === void 0))\n      if (r === \"skewX\" || r === \"skewY\")\n        e = e[r](m);\n      else {\n        const o = r.replace(/[XYZ]/, \"\"), d = r.replace(o, \"\"), A = [\"X\", \"Y\", \"Z\"].indexOf(d), M = o === \"scale\" ? 1 : 0, b = [\n          A === 0 ? m : M,\n          A === 1 ? m : M,\n          A === 2 ? m : M\n        ];\n        e = e[o](...b);\n      }\n    else\n      throw TypeError(n);\n  }), e;\n}, x = (s, t) => t ? [s.a, s.b, s.c, s.d, s.e, s.f] : [\n  s.m11,\n  s.m12,\n  s.m13,\n  s.m14,\n  s.m21,\n  s.m22,\n  s.m23,\n  s.m24,\n  s.m31,\n  s.m32,\n  s.m33,\n  s.m34,\n  s.m41,\n  s.m42,\n  s.m43,\n  s.m44\n], Y = (s, t, e) => {\n  const n = new y();\n  return n.m41 = s, n.e = s, n.m42 = t, n.f = t, n.m43 = e, n;\n}, F = (s, t, e) => {\n  const n = new y(), i = Math.PI / 180, r = s * i, a = t * i, l = e * i, m = Math.cos(r), h = -Math.sin(r), c = Math.cos(a), u = -Math.sin(a), f = Math.cos(l), w = -Math.sin(l), o = c * f, d = -c * w;\n  n.m11 = o, n.a = o, n.m12 = d, n.b = d, n.m13 = u;\n  const A = h * u * f + m * w;\n  n.m21 = A, n.c = A;\n  const M = m * f - h * u * w;\n  return n.m22 = M, n.d = M, n.m23 = -h * c, n.m31 = h * w - m * u * f, n.m32 = h * f + m * u * w, n.m33 = m * c, n;\n}, T = (s, t, e, n) => {\n  const i = new y(), r = Math.sqrt(s * s + t * t + e * e);\n  if (r === 0)\n    return i;\n  const a = s / r, l = t / r, m = e / r, h = n * (Math.PI / 360), c = Math.sin(h), u = Math.cos(h), f = c * c, w = a * a, o = l * l, d = m * m, A = 1 - 2 * (o + d) * f;\n  i.m11 = A, i.a = A;\n  const M = 2 * (a * l * f + m * c * u);\n  i.m12 = M, i.b = M, i.m13 = 2 * (a * m * f - l * c * u);\n  const b = 2 * (l * a * f - m * c * u);\n  i.m21 = b, i.c = b;\n  const k = 1 - 2 * (d + w) * f;\n  return i.m22 = k, i.d = k, i.m23 = 2 * (l * m * f + a * c * u), i.m31 = 2 * (m * a * f + l * c * u), i.m32 = 2 * (m * l * f - a * c * u), i.m33 = 1 - 2 * (w + o) * f, i;\n}, I = (s, t, e) => {\n  const n = new y();\n  return n.m11 = s, n.a = s, n.m22 = t, n.d = t, n.m33 = e, n;\n}, v = (s, t) => {\n  const e = new y();\n  if (s) {\n    const n = s * Math.PI / 180, i = Math.tan(n);\n    e.m21 = i, e.c = i;\n  }\n  if (t) {\n    const n = t * Math.PI / 180, i = Math.tan(n);\n    e.m12 = i, e.b = i;\n  }\n  return e;\n}, R = (s) => v(s, 0), D = (s) => v(0, s), N = (s, t) => {\n  const e = t.m11 * s.m11 + t.m12 * s.m21 + t.m13 * s.m31 + t.m14 * s.m41, n = t.m11 * s.m12 + t.m12 * s.m22 + t.m13 * s.m32 + t.m14 * s.m42, i = t.m11 * s.m13 + t.m12 * s.m23 + t.m13 * s.m33 + t.m14 * s.m43, r = t.m11 * s.m14 + t.m12 * s.m24 + t.m13 * s.m34 + t.m14 * s.m44, a = t.m21 * s.m11 + t.m22 * s.m21 + t.m23 * s.m31 + t.m24 * s.m41, l = t.m21 * s.m12 + t.m22 * s.m22 + t.m23 * s.m32 + t.m24 * s.m42, m = t.m21 * s.m13 + t.m22 * s.m23 + t.m23 * s.m33 + t.m24 * s.m43, h = t.m21 * s.m14 + t.m22 * s.m24 + t.m23 * s.m34 + t.m24 * s.m44, c = t.m31 * s.m11 + t.m32 * s.m21 + t.m33 * s.m31 + t.m34 * s.m41, u = t.m31 * s.m12 + t.m32 * s.m22 + t.m33 * s.m32 + t.m34 * s.m42, f = t.m31 * s.m13 + t.m32 * s.m23 + t.m33 * s.m33 + t.m34 * s.m43, w = t.m31 * s.m14 + t.m32 * s.m24 + t.m33 * s.m34 + t.m34 * s.m44, o = t.m41 * s.m11 + t.m42 * s.m21 + t.m43 * s.m31 + t.m44 * s.m41, d = t.m41 * s.m12 + t.m42 * s.m22 + t.m43 * s.m32 + t.m44 * s.m42, A = t.m41 * s.m13 + t.m42 * s.m23 + t.m43 * s.m33 + t.m44 * s.m43, M = t.m41 * s.m14 + t.m42 * s.m24 + t.m43 * s.m34 + t.m44 * s.m44;\n  return g([\n    e,\n    n,\n    i,\n    r,\n    a,\n    l,\n    m,\n    h,\n    c,\n    u,\n    f,\n    w,\n    o,\n    d,\n    A,\n    M\n  ]);\n};\nclass y {\n  /**\n   * @constructor\n   * @param init accepts all parameter configurations:\n   * * valid CSS transform string,\n   * * CSSMatrix/DOMMatrix instance,\n   * * a 6/16 elements *Array*.\n   */\n  constructor(t) {\n    return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.e = 0, this.f = 0, this.m11 = 1, this.m12 = 0, this.m13 = 0, this.m14 = 0, this.m21 = 0, this.m22 = 1, this.m23 = 0, this.m24 = 0, this.m31 = 0, this.m32 = 0, this.m33 = 1, this.m34 = 0, this.m41 = 0, this.m42 = 0, this.m43 = 0, this.m44 = 1, t ? this.setMatrixValue(t) : this;\n  }\n  /**\n   * A `Boolean` whose value is `true` if the matrix is the identity matrix. The identity\n   * matrix is one in which every value is 0 except those on the main diagonal from top-left\n   * to bottom-right corner (in other words, where the offsets in each direction are equal).\n   *\n   * @return the current property value\n   */\n  get isIdentity() {\n    return this.m11 === 1 && this.m12 === 0 && this.m13 === 0 && this.m14 === 0 && this.m21 === 0 && this.m22 === 1 && this.m23 === 0 && this.m24 === 0 && this.m31 === 0 && this.m32 === 0 && this.m33 === 1 && this.m34 === 0 && this.m41 === 0 && this.m42 === 0 && this.m43 === 0 && this.m44 === 1;\n  }\n  /**\n   * A `Boolean` flag whose value is `true` if the matrix was initialized as a 2D matrix\n   * and `false` if the matrix is 3D.\n   *\n   * @return the current property value\n   */\n  get is2D() {\n    return this.m31 === 0 && this.m32 === 0 && this.m33 === 1 && this.m34 === 0 && this.m43 === 0 && this.m44 === 1;\n  }\n  /**\n   * The `setMatrixValue` method replaces the existing matrix with one computed\n   * in the browser. EG: `matrix(1,0.25,-0.25,1,0,0)`\n   *\n   * The method accepts any *Array* values, the result of\n   * `DOMMatrix` instance method `toFloat64Array()` / `toFloat32Array()` calls\n   * or `CSSMatrix` instance method `toArray()`.\n   *\n   * This method expects valid *matrix()* / *matrix3d()* string values, as well\n   * as other transform functions like *translateX(10px)*.\n   *\n   * @param source\n   * @return the matrix instance\n   */\n  setMatrixValue(t) {\n    return typeof t == \"string\" && t.length && t !== \"none\" ? O(t) : Array.isArray(t) || t instanceof Float64Array || t instanceof Float32Array ? g(t) : typeof t == \"object\" ? X(t) : this;\n  }\n  /**\n   * Returns a *Float32Array* containing elements which comprise the matrix.\n   * The method can return either the 16 elements or the 6 elements\n   * depending on the value of the `is2D` parameter.\n   *\n   * @param is2D *Array* representation of the matrix\n   * @return an *Array* representation of the matrix\n   */\n  toFloat32Array(t) {\n    return Float32Array.from(x(this, t));\n  }\n  /**\n   * Returns a *Float64Array* containing elements which comprise the matrix.\n   * The method can return either the 16 elements or the 6 elements\n   * depending on the value of the `is2D` parameter.\n   *\n   * @param is2D *Array* representation of the matrix\n   * @return an *Array* representation of the matrix\n   */\n  toFloat64Array(t) {\n    return Float64Array.from(x(this, t));\n  }\n  /**\n   * Creates and returns a string representation of the matrix in `CSS` matrix syntax,\n   * using the appropriate `CSS` matrix notation.\n   *\n   * matrix3d *matrix3d(m11, m12, m13, m14, m21, ...)*\n   * matrix *matrix(a, b, c, d, e, f)*\n   *\n   * @return a string representation of the matrix\n   */\n  toString() {\n    const { is2D: t } = this, e = this.toFloat64Array(t).join(\", \");\n    return `${t ? \"matrix\" : \"matrix3d\"}(${e})`;\n  }\n  /**\n   * Returns a JSON representation of the `CSSMatrix` instance, a standard *Object*\n   * that includes `{a,b,c,d,e,f}` and `{m11,m12,m13,..m44}` properties as well\n   * as the `is2D` & `isIdentity` properties.\n   *\n   * The result can also be used as a second parameter for the `fromMatrix` static method\n   * to load values into another matrix instance.\n   *\n   * @return an *Object* with all matrix values.\n   */\n  toJSON() {\n    const { is2D: t, isIdentity: e } = this;\n    return { ...this, is2D: t, isIdentity: e };\n  }\n  /**\n   * The Multiply method returns a new CSSMatrix which is the result of this\n   * matrix multiplied by the passed matrix, with the passed matrix to the right.\n   * This matrix is not modified.\n   *\n   * @param m2 CSSMatrix\n   * @return The resulted matrix.\n   */\n  multiply(t) {\n    return N(this, t);\n  }\n  /**\n   * The translate method returns a new matrix which is this matrix post\n   * multiplied by a translation matrix containing the passed values. If the z\n   * component is undefined, a 0 value is used in its place. This matrix is not\n   * modified.\n   *\n   * @param x X component of the translation value.\n   * @param y Y component of the translation value.\n   * @param z Z component of the translation value.\n   * @return The resulted matrix\n   */\n  translate(t, e, n) {\n    const i = t;\n    let r = e, a = n;\n    return typeof r > \"u\" && (r = 0), typeof a > \"u\" && (a = 0), N(this, Y(i, r, a));\n  }\n  /**\n   * The scale method returns a new matrix which is this matrix post multiplied by\n   * a scale matrix containing the passed values. If the z component is undefined,\n   * a 1 value is used in its place. If the y component is undefined, the x\n   * component value is used in its place. This matrix is not modified.\n   *\n   * @param x The X component of the scale value.\n   * @param y The Y component of the scale value.\n   * @param z The Z component of the scale value.\n   * @return The resulted matrix\n   */\n  scale(t, e, n) {\n    const i = t;\n    let r = e, a = n;\n    return typeof r > \"u\" && (r = t), typeof a > \"u\" && (a = 1), N(this, I(i, r, a));\n  }\n  /**\n   * The rotate method returns a new matrix which is this matrix post multiplied\n   * by each of 3 rotation matrices about the major axes, first X, then Y, then Z.\n   * If the y and z components are undefined, the x value is used to rotate the\n   * object about the z axis, as though the vector (0,0,x) were passed. All\n   * rotation values are in degrees. This matrix is not modified.\n   *\n   * @param rx The X component of the rotation, or Z if Y and Z are null.\n   * @param ry The (optional) Y component of the rotation value.\n   * @param rz The (optional) Z component of the rotation value.\n   * @return The resulted matrix\n   */\n  rotate(t, e, n) {\n    let i = t, r = e || 0, a = n || 0;\n    return typeof t == \"number\" && typeof e > \"u\" && typeof n > \"u\" && (a = i, i = 0, r = 0), N(this, F(i, r, a));\n  }\n  /**\n   * The rotateAxisAngle method returns a new matrix which is this matrix post\n   * multiplied by a rotation matrix with the given axis and `angle`. The right-hand\n   * rule is used to determine the direction of rotation. All rotation values are\n   * in degrees. This matrix is not modified.\n   *\n   * @param x The X component of the axis vector.\n   * @param y The Y component of the axis vector.\n   * @param z The Z component of the axis vector.\n   * @param angle The angle of rotation about the axis vector, in degrees.\n   * @return The resulted matrix\n   */\n  rotateAxisAngle(t, e, n, i) {\n    if ([t, e, n, i].some((r) => Number.isNaN(+r)))\n      throw new TypeError(\"CSSMatrix: expecting 4 values\");\n    return N(this, T(t, e, n, i));\n  }\n  /**\n   * Specifies a skew transformation along the `x-axis` by the given angle.\n   * This matrix is not modified.\n   *\n   * @param angle The angle amount in degrees to skew.\n   * @return The resulted matrix\n   */\n  skewX(t) {\n    return N(this, R(t));\n  }\n  /**\n   * Specifies a skew transformation along the `y-axis` by the given angle.\n   * This matrix is not modified.\n   *\n   * @param angle The angle amount in degrees to skew.\n   * @return The resulted matrix\n   */\n  skewY(t) {\n    return N(this, D(t));\n  }\n  /**\n   * Specifies a skew transformation along both the `x-axis` and `y-axis`.\n   * This matrix is not modified.\n   *\n   * @param angleX The X-angle amount in degrees to skew.\n   * @param angleY The angle amount in degrees to skew.\n   * @return The resulted matrix\n   */\n  skew(t, e) {\n    return N(this, v(t, e));\n  }\n  /**\n   * Transforms a specified vector using the matrix, returning a new\n   * {x,y,z,w} Tuple *Object* comprising the transformed vector.\n   * Neither the matrix nor the original vector are altered.\n   *\n   * The method is equivalent with `transformPoint()` method\n   * of the `DOMMatrix` constructor.\n   *\n   * @param t Tuple with `{x,y,z,w}` components\n   * @return the resulting Tuple\n   */\n  transformPoint(t) {\n    const e = this.m11 * t.x + this.m21 * t.y + this.m31 * t.z + this.m41 * t.w, n = this.m12 * t.x + this.m22 * t.y + this.m32 * t.z + this.m42 * t.w, i = this.m13 * t.x + this.m23 * t.y + this.m33 * t.z + this.m43 * t.w, r = this.m14 * t.x + this.m24 * t.y + this.m34 * t.z + this.m44 * t.w;\n    return t instanceof DOMPoint ? new DOMPoint(e, n, i, r) : {\n      x: e,\n      y: n,\n      z: i,\n      w: r\n    };\n  }\n}\np(y, \"Translate\", Y), p(y, \"Rotate\", F), p(y, \"RotateAxisAngle\", T), p(y, \"Scale\", I), p(y, \"SkewX\", R), p(y, \"SkewY\", D), p(y, \"Skew\", v), p(y, \"Multiply\", N), p(y, \"fromArray\", g), p(y, \"fromMatrix\", X), p(y, \"fromString\", O), p(y, \"toArray\", x), p(y, \"isCompatibleArray\", E), p(y, \"isCompatibleObject\", P);\nexport {\n  y as default\n};\n//# sourceMappingURL=dommatrix.mjs.map\n","import { Options } from \"../interface\";\r\n\r\n/** SVGPathCommander default options */\r\nconst defaultOptions: Options = {\r\n  origin: [0, 0, 0],\r\n  round: 4,\r\n};\r\n\r\nexport default defaultOptions;\r\n","/** Segment params length */\r\nconst paramsCount = {\r\n  a: 7,\r\n  c: 6,\r\n  h: 1,\r\n  l: 2,\r\n  m: 2,\r\n  r: 4,\r\n  q: 4,\r\n  s: 4,\r\n  t: 2,\r\n  v: 1,\r\n  z: 0,\r\n};\r\n\r\nexport default paramsCount;\r\n","import paramsCount from \"./paramsCount\";\r\nimport PathParser from \"./pathParser\";\r\nimport type { PathCommand, PathSegment, RelativeCommand } from \"../types\";\r\n\r\n/**\r\n * Breaks the parsing of a pathString once a segment is finalized.\r\n *\r\n * @param path the `PathParser` instance\r\n */\r\nconst finalizeSegment = (path: PathParser) => {\r\n  let pathCommand = path.pathValue[path.segmentStart] as PathCommand;\r\n  let relativeCommand = pathCommand.toLowerCase() as RelativeCommand;\r\n  const { data } = path;\r\n\r\n  while (data.length >= paramsCount[relativeCommand]) {\r\n    // overloaded `moveTo`\r\n    // https://github.com/rveciana/svg-path-properties/blob/master/src/parse.ts\r\n    if (relativeCommand === \"m\" && data.length > 2) {\r\n      path.segments.push(\r\n        [pathCommand as PathCommand | number].concat(\r\n          data.splice(0, 2) as number[],\r\n        ) as PathSegment,\r\n      );\r\n      relativeCommand = \"l\";\r\n      pathCommand = pathCommand === \"m\" ? \"l\" : \"L\";\r\n    } else {\r\n      path.segments.push(\r\n        [pathCommand as PathCommand | number].concat(\r\n          data.splice(0, paramsCount[relativeCommand]) as number[],\r\n        ) as PathSegment,\r\n      );\r\n    }\r\n\r\n    if (!paramsCount[relativeCommand]) {\r\n      break;\r\n    }\r\n  }\r\n};\r\nexport default finalizeSegment;\r\n","const error = \"SVGPathCommander Error\";\r\nexport default error;\r\n","import error from \"./error\";\r\nimport type PathParser from \"./pathParser\";\r\n\r\n/**\r\n * Validates an A (arc-to) specific path command value.\r\n * Usually a `large-arc-flag` or `sweep-flag`.\r\n *\r\n * @param path the `PathParser` instance\r\n */\r\nconst scanFlag = (path: PathParser) => {\r\n  const { index, pathValue } = path;\r\n  const code = pathValue.charCodeAt(index);\r\n\r\n  if (code === 0x30 /* 0 */) {\r\n    path.param = 0;\r\n    path.index += 1;\r\n    return;\r\n  }\r\n\r\n  if (code === 0x31 /* 1 */) {\r\n    path.param = 1;\r\n    path.index += 1;\r\n    return;\r\n  }\r\n\r\n  path.err = `${error}: invalid Arc flag \"${\r\n    pathValue[index]\r\n  }\", expecting 0 or 1 at index ${index}`;\r\n};\r\n\r\nexport default scanFlag;\r\n","import { DigitNumber } from \"../types\";\r\n\r\n/**\r\n * Checks if a character is a digit.\r\n *\r\n * @param code the character to check\r\n * @returns check result\r\n */\r\nconst isDigit = (code: number): code is DigitNumber => {\r\n  return code >= 48 && code <= 57; // 0..9\r\n};\r\nexport default isDigit;\r\n","const invalidPathValue = \"Invalid path value\";\r\nexport default invalidPathValue;\r\n","import isDigit from \"./isDigit\";\r\nimport invalidPathValue from \"./invalidPathValue\";\r\nimport error from \"./error\";\r\nimport type PathParser from \"./pathParser\";\r\n\r\n/**\r\n * Validates every character of the path string,\r\n * every path command, negative numbers or floating point numbers.\r\n *\r\n * @param path the `PathParser` instance\r\n */\r\nconst scanParam = (path: PathParser) => {\r\n  const { max, pathValue, index: start } = path;\r\n  let index = start;\r\n  let zeroFirst = false;\r\n  let hasCeiling = false;\r\n  let hasDecimal = false;\r\n  let hasDot = false;\r\n  let ch;\r\n\r\n  if (index >= max) {\r\n    path.err =\r\n      `${error}: ${invalidPathValue} at index ${index}, \"pathValue\" is missing param`;\r\n    return;\r\n  }\r\n  ch = pathValue.charCodeAt(index);\r\n\r\n  if (ch === 0x2b /* + */ || ch === 0x2d /* - */) {\r\n    index += 1;\r\n    // ch = (index < max) ? pathValue.charCodeAt(index) : 0;\r\n    ch = pathValue.charCodeAt(index);\r\n  }\r\n\r\n  // This logic is shamelessly borrowed from Esprima\r\n  // https://github.com/ariya/esprimas\r\n  if (!isDigit(ch) && ch !== 0x2e /* . */) {\r\n    // path.err = 'SvgPath: param should start with 0..9 or `.` (at pos ' + index + ')';\r\n    path.err = `${error}: ${invalidPathValue} at index ${index}, \"${\r\n      pathValue[index]\r\n    }\" is not a number`;\r\n    return;\r\n  }\r\n\r\n  if (ch !== 0x2e /* . */) {\r\n    zeroFirst = ch === 0x30 /* 0 */;\r\n    index += 1;\r\n\r\n    ch = pathValue.charCodeAt(index);\r\n\r\n    if (zeroFirst && index < max) {\r\n      // decimal number starts with '0' such as '09' is illegal.\r\n      if (ch && isDigit(ch)) {\r\n        // path.err = 'SvgPath: numbers started with `0` such as `09`\r\n        // are illegal (at pos ' + start + ')';\r\n        path.err = `${error}: ${invalidPathValue} at index ${start}, \"${\r\n          pathValue[start]\r\n        }\" illegal number`;\r\n        return;\r\n      }\r\n    }\r\n\r\n    while (index < max && isDigit(pathValue.charCodeAt(index))) {\r\n      index += 1;\r\n      hasCeiling = true;\r\n    }\r\n\r\n    ch = pathValue.charCodeAt(index);\r\n  }\r\n\r\n  if (ch === 0x2e /* . */) {\r\n    hasDot = true;\r\n    index += 1;\r\n    while (isDigit(pathValue.charCodeAt(index))) {\r\n      index += 1;\r\n      hasDecimal = true;\r\n    }\r\n\r\n    ch = pathValue.charCodeAt(index);\r\n  }\r\n\r\n  if (ch === 0x65 /* e */ || ch === 0x45 /* E */) {\r\n    if (hasDot && !hasCeiling && !hasDecimal) {\r\n      path.err = `${error}: ${invalidPathValue} at index ${index}, \"${\r\n        pathValue[index]\r\n      }\" invalid float exponent`;\r\n      return;\r\n    }\r\n\r\n    index += 1;\r\n\r\n    ch = pathValue.charCodeAt(index);\r\n\r\n    if (ch === 0x2b /* + */ || ch === 0x2d /* - */) {\r\n      index += 1;\r\n    }\r\n    if (index < max && isDigit(pathValue.charCodeAt(index))) {\r\n      while (index < max && isDigit(pathValue.charCodeAt(index))) {\r\n        index += 1;\r\n      }\r\n    } else {\r\n      path.err = `${error}: ${invalidPathValue} at index ${index}, \"${\r\n        pathValue[index]\r\n      }\" invalid integer exponent`;\r\n      return;\r\n    }\r\n  }\r\n\r\n  path.index = index;\r\n  path.param = +path.pathValue.slice(start, index);\r\n};\r\nexport default scanParam;\r\n","import type { SpaceNumber } from \"../types\";\r\n\r\n/**\r\n * Checks if the character is a space.\r\n *\r\n * @param ch the character to check\r\n * @returns check result\r\n */\r\n\r\nconst isSpace = (ch: number): ch is SpaceNumber => {\r\n  const allSpaces = [\r\n    // Special spaces\r\n    0x1680,\r\n    0x180e,\r\n    0x2000,\r\n    0x2001,\r\n    0x2002,\r\n    0x2003,\r\n    0x2004,\r\n    0x2005,\r\n    0x2006,\r\n    0x2007,\r\n    0x2008,\r\n    0x2009,\r\n    0x200a,\r\n    0x202f,\r\n    0x205f,\r\n    0x3000,\r\n    0xfeff,\r\n    // Line terminators\r\n    0x0a,\r\n    0x0d,\r\n    0x2028,\r\n    0x2029,\r\n    // White spaces\r\n    0x20,\r\n    0x09,\r\n    0x0b,\r\n    0x0c,\r\n    0xa0,\r\n  ];\r\n\r\n  return allSpaces.includes(ch);\r\n};\r\nexport default isSpace;\r\n","import isSpace from \"./isSpace\";\r\nimport type PathParser from \"./pathParser\";\r\n\r\n/**\r\n * Points the parser to the next character in the\r\n * path string every time it encounters any kind of\r\n * space character.\r\n *\r\n * @param path the `PathParser` instance\r\n */\r\nconst skipSpaces = (path: PathParser) => {\r\n  const { pathValue, max } = path;\r\n  while (path.index < max && isSpace(pathValue.charCodeAt(path.index))) {\r\n    path.index += 1;\r\n  }\r\n};\r\nexport default skipSpaces;\r\n","import type { PathCommandNumber } from \"../types\";\r\n\r\n/**\r\n * Checks if the character is a path command.\r\n *\r\n * @param code the character to check\r\n * @returns check result\r\n */\r\nconst isPathCommand = (code: number): code is PathCommandNumber => {\r\n  // eslint-disable-next-line no-bitwise -- Impossible to satisfy\r\n  switch (code | 0x20) {\r\n    case 0x6d /* m */:\r\n    case 0x7a /* z */:\r\n    case 0x6c /* l */:\r\n    case 0x68 /* h */:\r\n    case 0x76 /* v */:\r\n    case 0x63 /* c */:\r\n    case 0x73 /* s */:\r\n    case 0x71 /* q */:\r\n    case 0x74 /* t */:\r\n    case 0x61 /* a */:\r\n      // case 0x72/* r */:\r\n      return true;\r\n    default:\r\n      return false;\r\n  }\r\n};\r\nexport default isPathCommand;\r\n","import isDigit from \"./isDigit\";\r\nimport type { DigitNumber } from \"../types\";\r\n\r\n/**\r\n * Checks if the character is or belongs to a number.\r\n * [0-9]|+|-|.\r\n *\r\n * @param code the character to check\r\n * @returns check result\r\n */\r\nconst isDigitStart = (\r\n  code: number,\r\n): code is DigitNumber | 0x2b | 0x2d | 0x2e => {\r\n  return isDigit(code) /* 0..9 */ || code === 0x2b /* + */ ||\r\n    code === 0x2d /* - */ || code === 0x2e; /* . */\r\n};\r\nexport default isDigitStart;\r\n","/**\r\n * Checks if the character is an A (arc-to) path command.\r\n *\r\n * @param code the character to check\r\n * @returns check result\r\n */\r\nconst isArcCommand = (code: number): code is 0x61 => {\r\n  // eslint-disable-next-line no-bitwise -- Impossible to satisfy\r\n  return (code | 0x20) === 0x61;\r\n};\r\nexport default isArcCommand;\r\n","/**\r\n * Checks if the character is a MoveTo command.\r\n *\r\n * @param code the character to check\r\n * @returns check result\r\n */\r\nconst isMoveCommand = (code: number): code is 0x6d | 0x4d => {\r\n  // eslint-disable-next-line no-bitwise -- Impossible to satisfy\r\n  switch (code | 0x20) {\r\n    case 0x6d /* m */:\r\n    case 0x4d /* M */:\r\n      return true;\r\n    default:\r\n      return false;\r\n  }\r\n};\r\nexport default isMoveCommand;\r\n","import finalizeSegment from \"./finalizeSegment\";\r\nimport paramCounts from \"./paramsCount\";\r\nimport scanFlag from \"./scanFlag\";\r\nimport scanParam from \"./scanParam\";\r\nimport skipSpaces from \"./skipSpaces\";\r\nimport isPathCommand from \"./isPathCommand\";\r\nimport isDigitStart from \"./isDigitStart\";\r\nimport isArcCommand from \"./isArcCommand\";\r\nimport isMoveCommand from \"./isMoveCommand\";\r\nimport invalidPathValue from \"./invalidPathValue\";\r\nimport error from \"./error\";\r\n\r\nimport type PathParser from \"./pathParser\";\r\nimport type { PathSegment, RelativeCommand } from \"../types\";\r\n\r\n/**\r\n * Scans every character in the path string to determine\r\n * where a segment starts and where it ends.\r\n *\r\n * @param path the `PathParser` instance\r\n */\r\nconst scanSegment = (path: PathParser) => {\r\n  const { max, pathValue, index, segments } = path;\r\n  const cmdCode = pathValue.charCodeAt(index);\r\n  const reqParams =\r\n    paramCounts[pathValue[index].toLowerCase() as RelativeCommand];\r\n\r\n  path.segmentStart = index;\r\n\r\n  // segments always start with a path command\r\n  if (!isPathCommand(cmdCode)) {\r\n    path.err = `${error}: ${invalidPathValue} \"${\r\n      pathValue[index]\r\n    }\" is not a path command at index ${index}`;\r\n    return;\r\n  }\r\n\r\n  // after a Z segment, we only expect a MoveTo path command\r\n  const lastSegment = segments[segments.length - 1] as PathSegment | undefined;\r\n  if (\r\n    !isMoveCommand(cmdCode) && lastSegment?.[0]?.toLocaleLowerCase() === \"z\"\r\n  ) {\r\n    path.err = `${error}: ${invalidPathValue} \"${\r\n      pathValue[index]\r\n    }\" is not a MoveTo path command at index ${index}`;\r\n    return;\r\n  }\r\n\r\n  path.index += 1;\r\n  skipSpaces(path);\r\n\r\n  path.data = [];\r\n\r\n  if (!reqParams) {\r\n    // Z\r\n    finalizeSegment(path);\r\n    return;\r\n  }\r\n\r\n  for (;;) {\r\n    for (let i = reqParams; i > 0; i -= 1) {\r\n      if (isArcCommand(cmdCode) && (i === 3 || i === 4)) scanFlag(path);\r\n      else scanParam(path);\r\n\r\n      if (path.err.length) {\r\n        return;\r\n      }\r\n      path.data.push(path.param);\r\n\r\n      skipSpaces(path);\r\n\r\n      // after ',' param is mandatory\r\n      if (\r\n        path.index < max && pathValue.charCodeAt(path.index) === 0x2c /* , */\r\n      ) {\r\n        path.index += 1;\r\n        skipSpaces(path);\r\n      }\r\n    }\r\n\r\n    if (path.index >= path.max) {\r\n      break;\r\n    }\r\n\r\n    // Stop on next segment\r\n    if (!isDigitStart(pathValue.charCodeAt(path.index))) {\r\n      break;\r\n    }\r\n  }\r\n\r\n  finalizeSegment(path);\r\n};\r\nexport default scanSegment;\r\n","import type { PathArray, PathSegment } from \"../types\";\r\n\r\n/**\r\n * The `PathParser` is used by the `parsePathString` static method\r\n * to generate a `pathArray`.\r\n *\r\n * @param pathString\r\n */\r\nexport default class PathParser {\r\n  declare segments: PathArray | PathSegment[];\r\n  declare pathValue: string;\r\n  declare max: number;\r\n  declare index: number;\r\n  declare param: number;\r\n  declare segmentStart: number;\r\n  declare data: (string | number)[];\r\n  declare err: string;\r\n\r\n  constructor(pathString: string) {\r\n    this.segments = [];\r\n    this.pathValue = pathString;\r\n    this.max = pathString.length;\r\n    this.index = 0;\r\n    this.param = 0.0;\r\n    this.segmentStart = 0;\r\n    this.data = [];\r\n    this.err = \"\";\r\n  }\r\n}\r\n","import scanSegment from \"./scanSegment\";\r\nimport skipSpaces from \"./skipSpaces\";\r\nimport PathParser from \"./pathParser\";\r\nimport type { PathArray } from \"../types\";\r\n\r\n/**\r\n * Parses a path string value and returns an array\r\n * of segments we like to call `pathArray`.\r\n *\r\n * @param pathInput the string to be parsed\r\n * @returns the resulted `pathArray` or error string\r\n */\r\nconst parsePathString = <T extends PathArray>(pathInput: string | T) => {\r\n  if (typeof pathInput !== \"string\") {\r\n    return pathInput.slice(0) as typeof pathInput;\r\n  }\r\n\r\n  const path = new PathParser(pathInput);\r\n\r\n  skipSpaces(path);\r\n\r\n  while (path.index < path.max && !path.err.length) {\r\n    scanSegment(path);\r\n  }\r\n\r\n  if (path?.err.length) {\r\n    throw TypeError(path.err);\r\n  }\r\n  // force absolute first M\r\n  path.segments[0][0]='M';\r\n  return path.segments as PathArray;\r\n};\r\n\r\nexport default parsePathString;\r\n","import type {\r\n  AbsoluteCommand,\r\n  AbsoluteSegment,\r\n  ASegment,\r\n  CSegment,\r\n  HSegment,\r\n  LSegment,\r\n  MSegment,\r\n  PathSegment,\r\n  QSegment,\r\n  SSegment,\r\n  TSegment,\r\n  VSegment,\r\n} from \"../types\";\r\n\r\n/**\r\n * Returns an absolute segment of a `PathArray` object.\r\n *\r\n * @param segment the segment object\r\n * @param index the segment index\r\n * @param lastX the last known X value\r\n * @param lastY the last known Y value\r\n * @returns the absolute segment\r\n */\r\nconst absolutizeSegment = (\r\n  segment: PathSegment,\r\n  index: number,\r\n  lastX: number,\r\n  lastY: number,\r\n) => {\r\n  const [pathCommand] = segment;\r\n  const absCommand = pathCommand.toUpperCase() as AbsoluteCommand;\r\n  const isAbsolute = absCommand === pathCommand;\r\n\r\n  /* istanbul ignore else @preserve */\r\n  if (index === 0 || isAbsolute) return segment as MSegment | AbsoluteSegment;\r\n  // const values = segment.slice(1) as number[];\r\n  if (absCommand === \"A\") {\r\n    return [\r\n      absCommand,\r\n      segment[1],\r\n      segment[2],\r\n      segment[3],\r\n      segment[4],\r\n      segment[5],\r\n      (segment as ASegment)[6] + lastX,\r\n      (segment as ASegment)[7] + lastY,\r\n    ] as ASegment;\r\n  } else if (absCommand === \"V\") {\r\n    return [absCommand, (segment as VSegment)[1] + lastY] as VSegment;\r\n  } else if (absCommand === \"H\") {\r\n    return [absCommand, (segment as HSegment)[1] + lastX] as HSegment;\r\n  } else if (absCommand === \"L\") {\r\n    return [\r\n      absCommand,\r\n      (segment as LSegment)[1] + lastX,\r\n      (segment as LSegment)[2] + lastY,\r\n    ] as LSegment;\r\n  } else {\r\n    // use brakets for `eslint: no-case-declaration`\r\n    // https://stackoverflow.com/a/50753272/803358\r\n    const absValues = [] as number[];\r\n    const seglen = segment.length;\r\n    for (let j = 1; j < seglen; j += 1) {\r\n      absValues.push((segment[j] as number) + (j % 2 ? lastX : lastY));\r\n    }\r\n    // for c, s, q, t\r\n    return [absCommand as typeof absCommand | number].concat(absValues) as\r\n      | MSegment\r\n      | QSegment\r\n      | TSegment\r\n      | SSegment\r\n      | CSegment;\r\n  }\r\n};\r\nexport default absolutizeSegment;\r\n","// import paramsParser from '../parser/paramsParser';\r\nimport type {\r\n  AbsoluteCommand,\r\n  IteratorCallback,\r\n  PathArray,\r\n  PathCommand,\r\n  PathSegment,\r\n} from \"../types\";\r\n\r\nconst iterate = <T extends PathArray>(\r\n  path: PathArray,\r\n  iterator: IteratorCallback,\r\n) => {\r\n  let pathLen = path.length;\r\n  let segment: PathSegment;\r\n  let pathCommand = \"M\" as PathCommand;\r\n  let absCommand = \"M\" as AbsoluteCommand;\r\n  let isRelative = false;\r\n  let x = 0;\r\n  let y = 0;\r\n  let mx = 0;\r\n  let my = 0;\r\n  let segLen = 0;\r\n\r\n  for (let i = 0; i < pathLen; i += 1) {\r\n    segment = path[i];\r\n    [pathCommand] = segment;\r\n    segLen = segment.length;\r\n    absCommand = pathCommand.toUpperCase() as AbsoluteCommand;\r\n    isRelative = absCommand !== pathCommand;\r\n\r\n    const iteratorResult = iterator(segment, i, x, y);\r\n    // some methods like getPointAtLength would like to break\r\n    // when task is complete\r\n    if (iteratorResult === false) {\r\n      break;\r\n    }\r\n\r\n    // segment = path[i];\r\n    if (absCommand === \"Z\") {\r\n      x = mx;\r\n      y = my;\r\n    } else if (absCommand === \"H\") {\r\n      x = (segment[1] as number) + (isRelative ? x : 0);\r\n    } else if (absCommand === \"V\") {\r\n      y = (segment[1] as number) + (isRelative ? y : 0);\r\n    } else {\r\n      x = (segment[segLen - 2] as number) + (isRelative ? x : 0);\r\n      y = (segment[segLen - 1] as number) + (isRelative ? y : 0);\r\n\r\n      if (absCommand === \"M\") {\r\n        mx = x;\r\n        my = y;\r\n      }\r\n    }\r\n\r\n    if (iteratorResult) {\r\n      path[i] = iteratorResult;\r\n      if (iteratorResult[0] === \"C\") {\r\n        pathLen = path.length;\r\n      }\r\n    }\r\n  }\r\n  return path as T;\r\n};\r\n\r\nexport default iterate;\r\n","import parsePathString from \"../parser/parsePathString\";\r\nimport absolutizeSegment from \"../process/absolutizeSegment\";\r\nimport type { AbsoluteArray, PathArray } from \"../types\";\r\nimport iterate from \"../process/iterate\";\r\n\r\n/**\r\n * Parses a path string value or object and returns an array\r\n * of segments, all converted to absolute values.\r\n *\r\n * @param pathInput the path string | object\r\n * @returns the resulted `pathArray` with absolute values\r\n */\r\nconst pathToAbsolute = (pathInput: string | PathArray) => {\r\n  const path = parsePathString(pathInput);\r\n\r\n  return iterate<AbsoluteArray>(path, absolutizeSegment);\r\n};\r\nexport default pathToAbsolute;\r\n","import type {\r\n  aSegment,\r\n  cSegment,\r\n  hSegment,\r\n  lSegment,\r\n  MSegment,\r\n  PathSegment,\r\n  qSegment,\r\n  RelativeCommand,\r\n  RelativeSegment,\r\n  sSegment,\r\n  tSegment,\r\n  vSegment,\r\n} from \"../types\";\r\n\r\n/**\r\n * Returns a relative segment of a `PathArray` object.\r\n *\r\n * @param segment the segment object\r\n * @param index the segment index\r\n * @param lastX the last known X value\r\n * @param lastY the last known Y value\r\n * @returns the relative segment\r\n */\r\nconst relativizeSegment = (\r\n  segment: PathSegment,\r\n  index: number,\r\n  lastX: number,\r\n  lastY: number,\r\n) => {\r\n  const [pathCommand] = segment;\r\n  const relCommand = pathCommand.toLowerCase() as RelativeCommand;\r\n  const isRelative = pathCommand === relCommand;\r\n\r\n  /* istanbul ignore else @preserve */\r\n  if (index === 0 || isRelative) return segment as MSegment | RelativeSegment;\r\n\r\n  if (relCommand === \"a\") {\r\n    return [\r\n      relCommand,\r\n      segment[1],\r\n      segment[2],\r\n      segment[3],\r\n      segment[4],\r\n      segment[5],\r\n      (segment as aSegment)[6] - lastX,\r\n      (segment as aSegment)[7] - lastY,\r\n    ] as aSegment;\r\n  } else if (relCommand === \"v\") {\r\n    return [relCommand, (segment as vSegment)[1] - lastY] as vSegment;\r\n  } else if (relCommand === \"h\") {\r\n    return [relCommand, (segment as hSegment)[1] - lastX] as hSegment;\r\n  } else if (relCommand === \"l\") {\r\n    return [\r\n      relCommand,\r\n      (segment as lSegment)[1] - lastX,\r\n      (segment as lSegment)[2] - lastY,\r\n    ] as lSegment;\r\n  } else {\r\n    // use brakets for `eslint: no-case-declaration`\r\n    // https://stackoverflow.com/a/50753272/803358\r\n    const relValues = [] as number[];\r\n    const seglen = segment.length;\r\n    for (let j = 1; j < seglen; j += 1) {\r\n      relValues.push((segment[j] as number) - (j % 2 ? lastX : lastY));\r\n    }\r\n    // for c, s, q, t\r\n    return [relCommand as RelativeCommand | number].concat(relValues) as\r\n      | qSegment\r\n      | tSegment\r\n      | sSegment\r\n      | cSegment;\r\n  }\r\n};\r\n\r\nexport default relativizeSegment;\r\n","import type { PathArray, RelativeArray } from \"../types\";\r\nimport parsePathString from \"../parser/parsePathString\";\r\nimport iterate from \"../process/iterate\";\r\nimport relativizeSegment from \"../process/relativizeSegment\";\r\n\r\n/**\r\n * Parses a path string value or object and returns an array\r\n * of segments, all converted to relative values.\r\n *\r\n * @param pathInput the path string | object\r\n * @returns the resulted `pathArray` with relative values\r\n */\r\nconst pathToRelative = (pathInput: string | PathArray): RelativeArray => {\r\n  const path = parsePathString(pathInput);\r\n\r\n  return iterate<RelativeArray>(path, relativizeSegment);\r\n};\r\nexport default pathToRelative;\r\n","/**\r\n * Returns an {x,y} vector rotated by a given\r\n * angle in radian.\r\n *\r\n * @param x the initial vector x\r\n * @param y the initial vector y\r\n * @param rad the radian vector angle\r\n * @returns the rotated vector\r\n */\r\nconst rotateVector = (\r\n  x: number,\r\n  y: number,\r\n  rad: number,\r\n): { x: number; y: number } => {\r\n  const { sin, cos } = Math;\r\n  const X = x * cos(rad) - y * sin(rad);\r\n  const Y = x * sin(rad) + y * cos(rad);\r\n  return { x: X, y: Y };\r\n};\r\n\r\nexport default rotateVector;\r\n","import rotateVector from \"../math/rotateVector\";\r\n\r\n/**\r\n * Converts A (arc-to) segments to C (cubic-bezier-to).\r\n *\r\n * For more information of where this math came from visit:\r\n * http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\r\n *\r\n * @param X1 the starting x position\r\n * @param Y1 the starting y position\r\n * @param RX x-radius of the arc\r\n * @param RY y-radius of the arc\r\n * @param angle x-axis-rotation of the arc\r\n * @param LAF large-arc-flag of the arc\r\n * @param SF sweep-flag of the arc\r\n * @param X2 the ending x position\r\n * @param Y2 the ending y position\r\n * @param recursive the parameters needed to split arc into 2 segments\r\n * @return the resulting cubic-bezier segment(s)\r\n */\r\nconst arcToCubic = (\r\n  X1: number,\r\n  Y1: number,\r\n  RX: number,\r\n  RY: number,\r\n  angle: number,\r\n  LAF: number,\r\n  SF: number,\r\n  X2: number,\r\n  Y2: number,\r\n  recursive?: [number, number, number, number],\r\n): number[] => {\r\n  let x1 = X1;\r\n  let y1 = Y1;\r\n  let rx = RX;\r\n  let ry = RY;\r\n  let x2 = X2;\r\n  let y2 = Y2;\r\n  // for more information of where this Math came from visit:\r\n  // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\r\n  const d120 = (Math.PI * 120) / 180;\r\n\r\n  const rad = (Math.PI / 180) * (+angle || 0);\r\n  let res = [] as number[];\r\n  let xy;\r\n  let f1;\r\n  let f2;\r\n  let cx;\r\n  let cy;\r\n\r\n  if (!recursive) {\r\n    xy = rotateVector(x1, y1, -rad);\r\n    x1 = xy.x;\r\n    y1 = xy.y;\r\n    xy = rotateVector(x2, y2, -rad);\r\n    x2 = xy.x;\r\n    y2 = xy.y;\r\n\r\n    const x = (x1 - x2) / 2;\r\n    const y = (y1 - y2) / 2;\r\n    let h = (x * x) / (rx * rx) + (y * y) / (ry * ry);\r\n    if (h > 1) {\r\n      h = Math.sqrt(h);\r\n      rx *= h;\r\n      ry *= h;\r\n    }\r\n    const rx2 = rx * rx;\r\n    const ry2 = ry * ry;\r\n\r\n    const k = (LAF === SF ? -1 : 1) *\r\n      Math.sqrt(\r\n        Math.abs(\r\n          (rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x),\r\n        ),\r\n      );\r\n\r\n    cx = (k * rx * y) / ry + (x1 + x2) / 2;\r\n    cy = (k * -ry * x) / rx + (y1 + y2) / 2;\r\n    // eslint-disable-next-line no-bitwise -- Impossible to satisfy no-bitwise\r\n    f1 = Math.asin(((((y1 - cy) / ry) * 10 ** 9) >> 0) / 10 ** 9);\r\n    // eslint-disable-next-line no-bitwise -- Impossible to satisfy no-bitwise\r\n    f2 = Math.asin(((((y2 - cy) / ry) * 10 ** 9) >> 0) / 10 ** 9);\r\n\r\n    f1 = x1 < cx ? Math.PI - f1 : f1;\r\n    f2 = x2 < cx ? Math.PI - f2 : f2;\r\n    if (f1 < 0) f1 = Math.PI * 2 + f1;\r\n    if (f2 < 0) f2 = Math.PI * 2 + f2;\r\n    if (SF && f1 > f2) {\r\n      f1 -= Math.PI * 2;\r\n    }\r\n    if (!SF && f2 > f1) {\r\n      f2 -= Math.PI * 2;\r\n    }\r\n  } else {\r\n    [f1, f2, cx, cy] = recursive;\r\n  }\r\n  let df = f2 - f1;\r\n  if (Math.abs(df) > d120) {\r\n    const f2old = f2;\r\n    const x2old = x2;\r\n    const y2old = y2;\r\n    f2 = f1 + d120 * (SF && f2 > f1 ? 1 : -1);\r\n    x2 = cx + rx * Math.cos(f2);\r\n    y2 = cy + ry * Math.sin(f2);\r\n    res = arcToCubic(x2, y2, rx, ry, angle, 0, SF, x2old, y2old, [\r\n      f2,\r\n      f2old,\r\n      cx,\r\n      cy,\r\n    ]);\r\n  }\r\n  df = f2 - f1;\r\n  const c1 = Math.cos(f1);\r\n  const s1 = Math.sin(f1);\r\n  const c2 = Math.cos(f2);\r\n  const s2 = Math.sin(f2);\r\n  const t = Math.tan(df / 4);\r\n  const hx = (4 / 3) * rx * t;\r\n  const hy = (4 / 3) * ry * t;\r\n  const m1 = [x1, y1];\r\n  const m2 = [x1 + hx * s1, y1 - hy * c1];\r\n  const m3 = [x2 + hx * s2, y2 - hy * c2];\r\n  const m4 = [x2, y2];\r\n  m2[0] = 2 * m1[0] - m2[0];\r\n  m2[1] = 2 * m1[1] - m2[1];\r\n  if (recursive) {\r\n    return [m2[0], m2[1], m3[0], m3[1], m4[0], m4[1]].concat(res);\r\n  }\r\n  res = [m2[0], m2[1], m3[0], m3[1], m4[0], m4[1]].concat(res);\r\n  const newres = [];\r\n  for (let i = 0, ii = res.length; i < ii; i += 1) {\r\n    newres[i] = i % 2\r\n      ? rotateVector(res[i - 1], res[i], rad).y\r\n      : rotateVector(res[i], res[i + 1], rad).x;\r\n  }\r\n  return newres;\r\n};\r\nexport default arcToCubic;\r\n","/**\r\n * Converts a Q (quadratic-bezier) segment to C (cubic-bezier).\r\n *\r\n * @param x1 curve start x\r\n * @param y1 curve start y\r\n * @param qx control point x\r\n * @param qy control point y\r\n * @param x2 curve end x\r\n * @param y2 curve end y\r\n * @returns the cubic-bezier segment\r\n */\r\nconst quadToCubic = (\r\n  x1: number,\r\n  y1: number,\r\n  qx: number,\r\n  qy: number,\r\n  x2: number,\r\n  y2: number,\r\n): [number, number, number, number, number, number] => {\r\n  const r13 = 1 / 3;\r\n  const r23 = 2 / 3;\r\n  return [\r\n    r13 * x1 + r23 * qx, // cpx1\r\n    r13 * y1 + r23 * qy, // cpy1\r\n    r13 * x2 + r23 * qx, // cpx2\r\n    r13 * y2 + r23 * qy, // cpy2\r\n    x2,\r\n    y2, // x,y\r\n  ];\r\n};\r\nexport default quadToCubic;\r\n","import { PointTuple } from \"../types\";\r\n\r\n/**\r\n * Returns the coordinates of a specified distance\r\n * ratio between two points.\r\n *\r\n * @param a the first point coordinates\r\n * @param b the second point coordinates\r\n * @param t the ratio\r\n * @returns the midpoint coordinates\r\n */\r\nconst midPoint = (a: PointTuple, b: PointTuple, t: number): PointTuple => {\r\n  const [ax, ay] = a;\r\n  const [bx, by] = b;\r\n  return [ax + (bx - ax) * t, ay + (by - ay) * t];\r\n};\r\n\r\nexport default midPoint;\r\n","import midPoint from \"../math/midPoint\";\r\n\r\n/**\r\n * Converts an L (line-to) segment to C (cubic-bezier).\r\n *\r\n * @param x1 line start x\r\n * @param y1 line start y\r\n * @param x2 line end x\r\n * @param y2 line end y\r\n * @returns the cubic-bezier segment\r\n */\r\nconst lineToCubic = (x1: number, y1: number, x2: number, y2: number) => {\r\n  const c1 = midPoint([x1, y1], [x2, y2], 1.0 / 3.0);\r\n  const c2 = midPoint([x1, y1], [x2, y2], 2.0 / 3.0);\r\n  return [c1[0], c1[1], c2[0], c2[1], x2, y2];\r\n};\r\nexport default lineToCubic;\r\n","import arcToCubic from \"./arcToCubic\";\r\nimport quadToCubic from \"./quadToCubic\";\r\nimport lineToCubic from \"./lineToCubic\";\r\nimport type { CSegment, MSegment, PathSegment } from \"../types\";\r\nimport type { ParserParams } from \"../interface\";\r\n\r\n/**\r\n * Converts any segment to C (cubic-bezier).\r\n *\r\n * @param segment the source segment\r\n * @param params the source segment parameters\r\n * @returns the cubic-bezier segment\r\n */\r\nconst segmentToCubic = (segment: PathSegment, params: ParserParams) => {\r\n  const [pathCommand] = segment;\r\n  const values = segment.slice(1).map(Number);\r\n  const [x, y] = values;\r\n  // let args;\r\n  const { x1: px1, y1: py1, x: px, y: py } = params;\r\n\r\n  if (!\"TQ\".includes(pathCommand)) {\r\n    params.qx = null;\r\n    params.qy = null;\r\n  }\r\n\r\n  if (pathCommand === \"M\") {\r\n    params.x = x;\r\n    params.y = y;\r\n    return segment;\r\n  } else if (pathCommand === \"A\") {\r\n    return [\"C\" as string | number].concat(\r\n      arcToCubic(\r\n        px1,\r\n        py1,\r\n        values[0],\r\n        values[1],\r\n        values[2],\r\n        values[3],\r\n        values[4],\r\n        values[5],\r\n        values[6],\r\n      ),\r\n    ) as CSegment;\r\n  } else if (pathCommand === \"Q\") {\r\n    params.qx = x;\r\n    params.qy = y;\r\n    return [\"C\" as string | number].concat(\r\n      quadToCubic(px1, py1, values[0], values[1], values[2], values[3]),\r\n    ) as CSegment;\r\n  } else if (pathCommand === \"L\") {\r\n    return [\"C\" as string | number].concat(\r\n      lineToCubic(px1, py1, x, y),\r\n    ) as CSegment;\r\n  } else if (pathCommand === \"Z\") {\r\n    return [\"C\" as string | number].concat(\r\n      lineToCubic(px1, py1, px, py),\r\n    ) as CSegment;\r\n  }\r\n\r\n  return segment as MSegment | CSegment;\r\n};\r\nexport default segmentToCubic;\r\n","import type { ParserParams } from \"../interface\";\r\nimport type {\r\n  ASegment,\r\n  CSegment,\r\n  HSegment,\r\n  LSegment,\r\n  MSegment,\r\n  NormalSegment,\r\n  PathCommand,\r\n  PathSegment,\r\n  PointTuple,\r\n  QSegment,\r\n  VSegment,\r\n} from \"../types\";\r\n\r\n/**\r\n * Normalizes a single segment of a `pathArray` object.\r\n *\r\n * @param segment the segment object\r\n * @param params the normalization parameters\r\n * @returns the normalized segment\r\n */\r\nconst normalizeSegment = (segment: PathSegment, params: ParserParams) => {\r\n  const [pathCommand] = segment;\r\n  const absCommand = pathCommand.toUpperCase();\r\n  const isRelative = pathCommand !== absCommand;\r\n  const { x1: px1, y1: py1, x2: px2, y2: py2, x, y } = params;\r\n  const values = segment.slice(1) as number[];\r\n  let absValues = values.map((n, j) => n + (isRelative ? (j % 2 ? y : x) : 0));\r\n\r\n  if (!\"TQ\".includes(absCommand)) {\r\n    // optional but good to be cautious\r\n    params.qx = null;\r\n    params.qy = null;\r\n  }\r\n\r\n  // istanbul ignore else @preserve\r\n  if (absCommand === \"A\") {\r\n    absValues = values.slice(0, -2).concat(\r\n      values[5] + (isRelative ? x : 0),\r\n      values[6] + (isRelative ? y : 0),\r\n    );\r\n\r\n    return [\"A\" as PathCommand | number].concat(absValues) as ASegment;\r\n  } else if (absCommand === \"H\") {\r\n    return [\r\n      \"L\",\r\n      (segment as HSegment)[1] + (isRelative ? x : 0),\r\n      py1,\r\n    ] as LSegment;\r\n  } else if (absCommand === \"V\") {\r\n    return [\r\n      \"L\",\r\n      px1,\r\n      (segment as VSegment)[1] + (isRelative ? y : 0),\r\n    ] as LSegment;\r\n  } else if (absCommand === \"L\") {\r\n    return [\r\n      \"L\",\r\n      (segment as LSegment)[1] + (isRelative ? x : 0),\r\n      (segment as LSegment)[2] + (isRelative ? y : 0),\r\n    ] as LSegment;\r\n  } else if (absCommand === \"M\") {\r\n    return [\r\n      \"M\",\r\n      (segment as MSegment)[1] + (isRelative ? x : 0),\r\n      (segment as MSegment)[2] + (isRelative ? y : 0),\r\n    ] as MSegment;\r\n  } else if (absCommand === \"C\") {\r\n    return [\"C\" as PathCommand | number].concat(absValues) as CSegment;\r\n  } else if (absCommand === \"S\") {\r\n    const x1 = px1 * 2 - px2;\r\n    const y1 = py1 * 2 - py2;\r\n    params.x1 = x1;\r\n    params.y1 = y1;\r\n    return [\"C\", x1, y1].concat(absValues) as CSegment;\r\n  } else if (absCommand === \"T\") {\r\n    const qx = px1 * 2 - (params.qx ? params.qx : /* istanbul ignore next */ 0);\r\n    const qy = py1 * 2 - (params.qy ? params.qy : /* istanbul ignore next */ 0);\r\n    params.qx = qx;\r\n    params.qy = qy;\r\n    return [\"Q\", qx, qy].concat(absValues) as QSegment;\r\n  } else if (absCommand === \"Q\") {\r\n    const [nqx, nqy] = absValues as PointTuple;\r\n    params.qx = nqx;\r\n    params.qy = nqy;\r\n    return [\"Q\" as PathCommand | number].concat(absValues) as QSegment;\r\n  } else if (absCommand === \"Z\") {\r\n    return [\"Z\"] as NormalSegment;\r\n  }\r\n\r\n  // istanbul ignore next @preserve\r\n  return segment as NormalSegment;\r\n};\r\nexport default normalizeSegment;\r\n","import type { ParserParams } from \"../interface\";\r\n\r\nconst paramsParser: ParserParams = {\r\n  x1: 0,\r\n  y1: 0,\r\n  x2: 0,\r\n  y2: 0,\r\n  x: 0,\r\n  y: 0,\r\n  qx: null,\r\n  qy: null,\r\n};\r\n\r\nexport default paramsParser;\r\n","import segmentToCubic from \"../process/segmentToCubic\";\r\nimport { AbsoluteCommand, CSegment, CurveArray, PathArray } from \"../types\";\r\nimport iterate from \"../process/iterate\";\r\nimport parsePathString from \"../parser/parsePathString\";\r\nimport normalizeSegment from \"../process/normalizeSegment\";\r\nimport paramsParser from \"../parser/paramsParser\";\r\n\r\n/**\r\n * Parses a path string value or 'pathArray' and returns a new one\r\n * in which all segments are converted to cubic-bezier.\r\n *\r\n * In addition, un-necessary `Z` segment is removed if previous segment\r\n * extends to the `M` segment.\r\n *\r\n * @param pathInput the string to be parsed or 'pathArray'\r\n * @returns the resulted `pathArray` converted to cubic-bezier\r\n */\r\nconst pathToCurve = (pathInput: string | PathArray): CurveArray => {\r\n  const params = { ...paramsParser };\r\n  const path = parsePathString(pathInput);\r\n\r\n  return iterate<CurveArray>(path, (seg, index, lastX, lastY) => {\r\n    params.x = lastX;\r\n    params.y = lastY;\r\n    const normalSegment = normalizeSegment(seg, params);\r\n    let result = segmentToCubic(normalSegment, params);\r\n    const isLongArc = result[0] === \"C\" && result.length > 7;\r\n\r\n    if (isLongArc) {\r\n      path.splice(\r\n        index + 1,\r\n        0,\r\n        [\"C\" as AbsoluteCommand | number].concat(result.slice(7)) as CSegment,\r\n      );\r\n      result = result.slice(0, 7) as CSegment;\r\n    }\r\n\r\n    const seglen = result.length;\r\n    params.x1 = +result[seglen - 2];\r\n    params.y1 = +result[seglen - 1];\r\n    params.x2 = +result[seglen - 4] || params.x1;\r\n    params.y2 = +result[seglen - 3] || params.y1;\r\n\r\n    return result;\r\n  });\r\n};\r\nexport default pathToCurve;\r\n","const roundTo = (n: number, round: number) => {\r\n  const pow = round >= 1 ? 10 ** round : 1;\r\n\r\n  return round > 0 ? Math.round(n * pow) / pow : Math.round(n);\r\n};\r\n\r\nexport default roundTo;\r\n","import type { PathArray, PathSegment } from \"../types\";\r\nimport defaultOptions from \"../options/options\";\r\nimport roundTo from \"../math/roundTo\";\r\n\r\n/**\r\n * Returns a valid `d` attribute string value created\r\n * by rounding values and concatenating the `pathArray` segments.\r\n *\r\n * @param path the `pathArray` object\r\n * @param roundOption amount of decimals to round values to\r\n * @returns the concatenated path string\r\n */\r\nconst pathToString = (\r\n  path: PathArray,\r\n  roundOption?: number | \"off\",\r\n): string => {\r\n  const pathLen = path.length;\r\n  let { round } = defaultOptions;\r\n  let segment = path[0] as PathSegment;\r\n  let result = \"\";\r\n\r\n  // allow for ZERO decimals\r\n  round = roundOption === \"off\"\r\n    ? roundOption\r\n    : typeof roundOption === \"number\" && roundOption >= 0\r\n    ? roundOption\r\n    : typeof round === \"number\" && round >= 0\r\n    ? round\r\n    : /* istanbul ignore next @preserve */ \"off\";\r\n\r\n  for (let i = 0; i < pathLen; i += 1) {\r\n    segment = path[i];\r\n    const [pathCommand] = segment;\r\n    const values = segment.slice(1) as number[];\r\n    result += pathCommand;\r\n    if (round === \"off\") {\r\n      result += values.join(\" \");\r\n    } else {\r\n      let j = 0;\r\n      const valLen = values.length;\r\n      while (j < valLen) {\r\n        result += roundTo(values[j], round);\r\n        if (j !== valLen - 1) result += \" \";\r\n        j += 1;\r\n      }\r\n    }\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\nexport default pathToString;\r\n","import { type PointTuple } from \"../types\";\r\n\r\n/**\r\n * Returns the square root of the distance\r\n * between two given points.\r\n *\r\n * @param a the first point coordinates\r\n * @param b the second point coordinates\r\n * @returns the distance value\r\n */\r\nconst distanceSquareRoot = (a: PointTuple, b: PointTuple) => {\r\n  return Math.sqrt(\r\n    (a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1]),\r\n  );\r\n};\r\n\r\nexport default distanceSquareRoot;\r\n","import midPoint from \"./midPoint\";\r\nimport distanceSquareRoot from \"./distanceSquareRoot\";\r\n\r\n/**\r\n * Returns length for line segments (MoveTo, LineTo).\r\n *\r\n * @param x1 the starting point X\r\n * @param y1 the starting point Y\r\n * @param x2 the ending point X\r\n * @param y2 the ending point Y\r\n * @returns the line segment length\r\n */\r\nconst getLineLength = (x1: number, y1: number, x2: number, y2: number) => {\r\n  return distanceSquareRoot([x1, y1], [x2, y2]);\r\n};\r\n\r\n/**\r\n * Returns a point along the line segments (MoveTo, LineTo).\r\n *\r\n * @param x1 the starting point X\r\n * @param y1 the starting point Y\r\n * @param x2 the ending point X\r\n * @param y2 the ending point Y\r\n * @param distance the distance to point in [0-1] range\r\n * @returns the point at length\r\n */\r\nconst getPointAtLineLength = (\r\n  x1: number,\r\n  y1: number,\r\n  x2: number,\r\n  y2: number,\r\n  distance?: number,\r\n) => {\r\n  let point = { x: x1, y: y1 };\r\n\r\n  /* istanbul ignore else @preserve */\r\n  if (typeof distance === \"number\") {\r\n    const length = distanceSquareRoot([x1, y1], [x2, y2]);\r\n    if (distance <= 0) {\r\n      point = { x: x1, y: y1 };\r\n    } else if (distance >= length) {\r\n      point = { x: x2, y: y2 };\r\n    } else {\r\n      const [x, y] = midPoint([x1, y1], [x2, y2], distance / length);\r\n      point = { x, y };\r\n    }\r\n  }\r\n  return point;\r\n};\r\n\r\n/**\r\n * Returns bounding box for line segments (MoveTo, LineTo).\r\n *\r\n * @param x1 the starting point X\r\n * @param y1 the starting point Y\r\n * @param x2 the ending point X\r\n * @param y2 the ending point Y\r\n * @param distance the distance to point in [0-1] range\r\n * @returns the extrema for line segments\r\n */\r\nconst getLineBBox = (x1: number, y1: number, x2: number, y2: number) => {\r\n  const { min, max } = Math;\r\n\r\n  return [min(x1, x2), min(y1, y2), max(x1, x2), max(y1, y2)] as [\r\n    number,\r\n    number,\r\n    number,\r\n    number,\r\n  ];\r\n};\r\n\r\nexport { getLineBBox, getLineLength, getPointAtLineLength };\r\n","import { getPointAtLineLength } from \"./lineTools\";\r\nimport type { Point, PointTuple } from \"../types\";\r\n\r\n/**\r\n * Returns the Arc segment length.\r\n * @param rx radius along X axis\r\n * @param ry radius along Y axis\r\n * @param theta the angle in radians\r\n * @returns the arc length\r\n */\r\nconst arcLength = (rx: number, ry: number, theta: number) => {\r\n  const halfTheta = theta / 2;\r\n  const sinHalfTheta = Math.sin(halfTheta);\r\n  const cosHalfTheta = Math.cos(halfTheta);\r\n  const term1 = rx ** 2 * sinHalfTheta ** 2;\r\n  const term2 = ry ** 2 * cosHalfTheta ** 2;\r\n  const length = Math.sqrt(term1 + term2) * theta;\r\n  return Math.abs(length);\r\n};\r\n\r\n/**\r\n * Find point on ellipse at given angle around ellipse (theta);\r\n * @param cx the center X\r\n * @param cy the center Y\r\n * @param rx the radius X\r\n * @param ry the radius Y\r\n * @param alpha the arc rotation angle in radians\r\n * @param theta the arc sweep angle in radians\r\n * @returns a point around ellipse at given angle\r\n */\r\nconst arcPoint = (\r\n  cx: number,\r\n  cy: number,\r\n  rx: number,\r\n  ry: number,\r\n  alpha: number,\r\n  theta: number,\r\n) => {\r\n  const { sin, cos } = Math;\r\n  // theta is angle in radians around arc\r\n  // alpha is angle of rotation of ellipse in radians\r\n  const cosA = cos(alpha);\r\n  const sinA = sin(alpha);\r\n  const x = rx * cos(theta);\r\n  const y = ry * sin(theta);\r\n\r\n  return [cx + cosA * x - sinA * y, cy + sinA * x + cosA * y] as PointTuple;\r\n};\r\n\r\n/**\r\n * Returns the angle between two points.\r\n * @param v0 starting point\r\n * @param v1 ending point\r\n * @returns the angle in radian\r\n */\r\nconst angleBetween = (v0: Point, v1: Point) => {\r\n  const { x: v0x, y: v0y } = v0;\r\n  const { x: v1x, y: v1y } = v1;\r\n  const p = v0x * v1x + v0y * v1y;\r\n  const n = Math.sqrt((v0x ** 2 + v0y ** 2) * (v1x ** 2 + v1y ** 2));\r\n  const sign = v0x * v1y - v0y * v1x < 0 ? -1 : 1;\r\n  return sign * Math.acos(p / n);\r\n};\r\n\r\n/**\r\n * Returns the following properties for an Arc segment: center, start angle,\r\n * end angle, and radiuses on X and Y axis.\r\n *\r\n * @param x1 the starting point X\r\n * @param y1 the starting point Y\r\n * @param RX the radius on X axis\r\n * @param RY the radius on Y axis\r\n * @param angle the ellipse rotation in degrees\r\n * @param LAF the large arc flag\r\n * @param SF the sweep flag\r\n * @param x2 the ending point X\r\n * @param y2 the ending point Y\r\n * @returns properties specific to Arc segments\r\n */\r\nconst getArcProps = (\r\n  x1: number,\r\n  y1: number,\r\n  RX: number,\r\n  RY: number,\r\n  angle: number,\r\n  LAF: number,\r\n  SF: number,\r\n  x: number,\r\n  y: number,\r\n) => {\r\n  const { abs, sin, cos, sqrt, PI } = Math;\r\n  let rx = abs(RX);\r\n  let ry = abs(RY);\r\n  const xRot = ((angle % 360) + 360) % 360;\r\n  const xRotRad = xRot * (PI / 180);\r\n\r\n  // istanbul ignore next @preserve\r\n  if (x1 === x && y1 === y) {\r\n    return {\r\n      rx,\r\n      ry,\r\n      startAngle: 0,\r\n      endAngle: 0,\r\n      center: { x, y },\r\n    };\r\n  }\r\n\r\n  if (rx === 0 || ry === 0) {\r\n    return {\r\n      rx,\r\n      ry,\r\n      startAngle: 0,\r\n      endAngle: 0,\r\n      center: { x: (x + x1) / 2, y: (y + y1) / 2 },\r\n    };\r\n  }\r\n\r\n  const dx = (x1 - x) / 2;\r\n  const dy = (y1 - y) / 2;\r\n\r\n  const transformedPoint = {\r\n    x: cos(xRotRad) * dx + sin(xRotRad) * dy,\r\n    y: -sin(xRotRad) * dx + cos(xRotRad) * dy,\r\n  };\r\n\r\n  const radiiCheck = transformedPoint.x ** 2 / rx ** 2 +\r\n    transformedPoint.y ** 2 / ry ** 2;\r\n\r\n  if (radiiCheck > 1) {\r\n    rx *= sqrt(radiiCheck);\r\n    ry *= sqrt(radiiCheck);\r\n  }\r\n\r\n  const cSquareNumerator = rx ** 2 * ry ** 2 -\r\n    rx ** 2 * transformedPoint.y ** 2 - ry ** 2 * transformedPoint.x ** 2;\r\n  const cSquareRootDenom = rx ** 2 * transformedPoint.y ** 2 +\r\n    ry ** 2 * transformedPoint.x ** 2;\r\n\r\n  let cRadicand = cSquareNumerator / cSquareRootDenom;\r\n  /* istanbul ignore next @preserve */\r\n  cRadicand = cRadicand < 0 ? 0 : cRadicand;\r\n  const cCoef = (LAF !== SF ? 1 : -1) * sqrt(cRadicand);\r\n  const transformedCenter = {\r\n    x: cCoef * ((rx * transformedPoint.y) / ry),\r\n    y: cCoef * (-(ry * transformedPoint.x) / rx),\r\n  };\r\n\r\n  const center = {\r\n    x: cos(xRotRad) * transformedCenter.x - sin(xRotRad) * transformedCenter.y +\r\n      (x1 + x) / 2,\r\n    y: sin(xRotRad) * transformedCenter.x + cos(xRotRad) * transformedCenter.y +\r\n      (y1 + y) / 2,\r\n  };\r\n\r\n  const startVector = {\r\n    x: (transformedPoint.x - transformedCenter.x) / rx,\r\n    y: (transformedPoint.y - transformedCenter.y) / ry,\r\n  };\r\n\r\n  const startAngle = angleBetween({ x: 1, y: 0 }, startVector);\r\n\r\n  const endVector = {\r\n    x: (-transformedPoint.x - transformedCenter.x) / rx,\r\n    y: (-transformedPoint.y - transformedCenter.y) / ry,\r\n  };\r\n\r\n  let sweepAngle = angleBetween(startVector, endVector);\r\n  if (!SF && sweepAngle > 0) {\r\n    sweepAngle -= 2 * PI;\r\n  } else if (SF && sweepAngle < 0) {\r\n    sweepAngle += 2 * PI;\r\n  }\r\n  sweepAngle %= 2 * PI;\r\n\r\n  const endAngle = startAngle + sweepAngle;\r\n\r\n  // point.ellipticalArcStartAngle = startAngle;\r\n  // point.ellipticalArcEndAngle = startAngle + sweepAngle;\r\n  // point.ellipticalArcAngle = alpha;\r\n\r\n  // point.ellipticalArcCenter = center;\r\n  // point.resultantRx = rx;\r\n  // point.resultantRy = ry;\r\n\r\n  return {\r\n    center,\r\n    startAngle,\r\n    endAngle,\r\n    rx,\r\n    ry,\r\n  };\r\n};\r\n\r\n/**\r\n * Returns the length of an Arc segment.\r\n *\r\n * @param x1 the starting point X\r\n * @param y1 the starting point Y\r\n * @param c1x the first control point X\r\n * @param c1y the first control point Y\r\n * @param c2x the second control point X\r\n * @param c2y the second control point Y\r\n * @param x2 the ending point X\r\n * @param y2 the ending point Y\r\n * @returns the length of the Arc segment\r\n */\r\nconst getArcLength = (\r\n  x1: number,\r\n  y1: number,\r\n  RX: number,\r\n  RY: number,\r\n  angle: number,\r\n  LAF: number,\r\n  SF: number,\r\n  x: number,\r\n  y: number,\r\n) => {\r\n  const { rx, ry, startAngle, endAngle } = getArcProps(\r\n    x1,\r\n    y1,\r\n    RX,\r\n    RY,\r\n    angle,\r\n    LAF,\r\n    SF,\r\n    x,\r\n    y,\r\n  );\r\n  return arcLength(rx, ry, endAngle - startAngle);\r\n};\r\n\r\n/**\r\n * Returns a point along an Arc segment at a given distance.\r\n *\r\n * @param x1 the starting point X\r\n * @param y1 the starting point Y\r\n * @param RX the radius on X axis\r\n * @param RY the radius on Y axis\r\n * @param angle the ellipse rotation in degrees\r\n * @param LAF the large arc flag\r\n * @param SF the sweep flag\r\n * @param x2 the ending point X\r\n * @param y2 the ending point Y\r\n * @param distance a [0-1] ratio\r\n * @returns a point along the Arc segment\r\n */\r\nconst getPointAtArcLength = (\r\n  x1: number,\r\n  y1: number,\r\n  RX: number,\r\n  RY: number,\r\n  angle: number,\r\n  LAF: number,\r\n  SF: number,\r\n  x: number,\r\n  y: number,\r\n  distance?: number,\r\n) => {\r\n  let point = { x: x1, y: y1 };\r\n  const { center, rx, ry, startAngle, endAngle } = getArcProps(\r\n    x1,\r\n    y1,\r\n    RX,\r\n    RY,\r\n    angle,\r\n    LAF,\r\n    SF,\r\n    x,\r\n    y,\r\n  );\r\n\r\n  /* istanbul ignore else @preserve */\r\n  if (typeof distance === \"number\") {\r\n    const length = arcLength(rx, ry, endAngle - startAngle);\r\n    if (distance <= 0) {\r\n      point = { x: x1, y: y1 };\r\n    } else if (distance >= length) {\r\n      point = { x, y };\r\n    } else {\r\n      /* istanbul ignore next @preserve */\r\n      if (x1 === x && y1 === y) {\r\n        return { x, y };\r\n      }\r\n      /* istanbul ignore next @preserve */\r\n      if (rx === 0 || ry === 0) {\r\n        return getPointAtLineLength(x1, y1, x, y, distance);\r\n      }\r\n      const { PI, cos, sin } = Math;\r\n      const sweepAngle = endAngle - startAngle;\r\n      const xRot = ((angle % 360) + 360) % 360;\r\n      const xRotRad = xRot * (PI / 180);\r\n      const alpha = startAngle + sweepAngle * (distance / length);\r\n      const ellipseComponentX = rx * cos(alpha);\r\n      const ellipseComponentY = ry * sin(alpha);\r\n\r\n      point = {\r\n        x: cos(xRotRad) * ellipseComponentX - sin(xRotRad) * ellipseComponentY +\r\n          center.x,\r\n        y: sin(xRotRad) * ellipseComponentX + cos(xRotRad) * ellipseComponentY +\r\n          center.y,\r\n      };\r\n    }\r\n  }\r\n\r\n  return point;\r\n};\r\n\r\n/**\r\n * Returns the extrema for an Arc segment in the following format:\r\n * [MIN_X, MIN_Y, MAX_X, MAX_Y]\r\n *\r\n * @see https://github.com/herrstrietzel/svg-pathdata-getbbox\r\n *\r\n * @param x1 the starting point X\r\n * @param y1 the starting point Y\r\n * @param RX the radius on X axis\r\n * @param RY the radius on Y axis\r\n * @param angle the ellipse rotation in degrees\r\n * @param LAF the large arc flag\r\n * @param SF the sweep flag\r\n * @param x2 the ending point X\r\n * @param y2 the ending point Y\r\n * @returns the extrema of the Arc segment\r\n */\r\nconst getArcBBox = (\r\n  x1: number,\r\n  y1: number,\r\n  RX: number,\r\n  RY: number,\r\n  angle: number,\r\n  LAF: number,\r\n  SF: number,\r\n  x: number,\r\n  y: number,\r\n) => {\r\n  const { center, rx, ry, startAngle, endAngle } = getArcProps(\r\n    x1,\r\n    y1,\r\n    RX,\r\n    RY,\r\n    angle,\r\n    LAF,\r\n    SF,\r\n    x,\r\n    y,\r\n  );\r\n  const deltaAngle = endAngle - startAngle;\r\n  const { min, max, tan, atan2, PI } = Math;\r\n\r\n  // circle/elipse center coordinates\r\n  const { x: cx, y: cy } = center;\r\n\r\n  // rotation to radians\r\n  const alpha = (angle * PI) / 180;\r\n  const tangent = tan(alpha);\r\n\r\n  /**\r\n   * find min/max from zeroes of directional derivative along x and y\r\n   * along x axis\r\n   */\r\n  const theta = atan2(-ry * tangent, rx);\r\n  const angle1 = theta;\r\n  const angle2 = theta + PI;\r\n  const angle3 = atan2(ry, rx * tangent);\r\n  const angle4 = angle3 + PI;\r\n  const xArray = [x];\r\n  const yArray = [y];\r\n\r\n  // inner bounding box\r\n  let xMin = min(x1, x);\r\n  let xMax = max(x1, x);\r\n  let yMin = min(y1, y);\r\n  let yMax = max(y1, y);\r\n\r\n  // on path point close after start\r\n  const angleAfterStart = endAngle - deltaAngle * 0.00001;\r\n  const pP2 = arcPoint(cx, cy, rx, ry, alpha, angleAfterStart);\r\n\r\n  // on path point close before end\r\n  const angleBeforeEnd = endAngle - deltaAngle * 0.99999;\r\n  const pP3 = arcPoint(cx, cy, rx, ry, alpha, angleBeforeEnd);\r\n\r\n  /**\r\n   * expected extremes\r\n   * if leaving inner bounding box\r\n   * (between segment start and end point)\r\n   * otherwise exclude elliptic extreme points\r\n   */\r\n\r\n  // right\r\n  if (pP2[0] > xMax || pP3[0] > xMax) {\r\n    // get point for this theta\r\n    const p1 = arcPoint(cx, cy, rx, ry, alpha, angle1);\r\n    xArray.push(p1[0]);\r\n    yArray.push(p1[1]);\r\n  }\r\n\r\n  // left\r\n  if (pP2[0] < xMin || pP3[0] < xMin) {\r\n    // get anti-symmetric point\r\n    const p2 = arcPoint(cx, cy, rx, ry, alpha, angle2);\r\n    xArray.push(p2[0]);\r\n    yArray.push(p2[1]);\r\n  }\r\n\r\n  // top\r\n  if (pP2[1] < yMin || pP3[1] < yMin) {\r\n    // get anti-symmetric point\r\n    const p4 = arcPoint(cx, cy, rx, ry, alpha, angle4);\r\n    xArray.push(p4[0]);\r\n    yArray.push(p4[1]);\r\n  }\r\n\r\n  // bottom\r\n  if (pP2[1] > yMax || pP3[1] > yMax) {\r\n    // get point for this theta\r\n    const p3 = arcPoint(cx, cy, rx, ry, alpha, angle3);\r\n    xArray.push(p3[0]);\r\n    yArray.push(p3[1]);\r\n  }\r\n\r\n  xMin = min.apply([], xArray);\r\n  yMin = min.apply([], yArray);\r\n  xMax = max.apply([], xArray);\r\n  yMax = max.apply([], yArray);\r\n\r\n  return [xMin, yMin, xMax, yMax] as [number, number, number, number];\r\n};\r\n\r\nexport {\r\n  angleBetween,\r\n  arcLength,\r\n  arcPoint,\r\n  getArcBBox,\r\n  getArcLength,\r\n  getArcProps,\r\n  getPointAtArcLength,\r\n};\r\n","import type {\r\n  CubicCoordinates,\r\n  CubicPoints,\r\n  DeriveCallback,\r\n  DerivedCubicPoints,\r\n  DerivedPoint,\r\n  DerivedQuadPoints,\r\n  PointTuple,\r\n  QuadCoordinates,\r\n  QuadPoints,\r\n} from \"../types\";\r\n\r\n/**\r\n * Tools from bezier.js by Mike 'Pomax' Kamermans\r\n * @see https://github.com/Pomax/bezierjs\r\n */\r\n\r\nconst Tvalues = [\r\n  -0.0640568928626056260850430826247450385909,\r\n  0.0640568928626056260850430826247450385909,\r\n  -0.1911188674736163091586398207570696318404,\r\n  0.1911188674736163091586398207570696318404,\r\n  -0.3150426796961633743867932913198102407864,\r\n  0.3150426796961633743867932913198102407864,\r\n  -0.4337935076260451384870842319133497124524,\r\n  0.4337935076260451384870842319133497124524,\r\n  -0.5454214713888395356583756172183723700107,\r\n  0.5454214713888395356583756172183723700107,\r\n  -0.6480936519369755692524957869107476266696,\r\n  0.6480936519369755692524957869107476266696,\r\n  -0.7401241915785543642438281030999784255232,\r\n  0.7401241915785543642438281030999784255232,\r\n  -0.8200019859739029219539498726697452080761,\r\n  0.8200019859739029219539498726697452080761,\r\n  -0.8864155270044010342131543419821967550873,\r\n  0.8864155270044010342131543419821967550873,\r\n  -0.9382745520027327585236490017087214496548,\r\n  0.9382745520027327585236490017087214496548,\r\n  -0.9747285559713094981983919930081690617411,\r\n  0.9747285559713094981983919930081690617411,\r\n  -0.9951872199970213601799974097007368118745,\r\n  0.9951872199970213601799974097007368118745,\r\n];\r\n\r\nconst Cvalues = [\r\n  0.1279381953467521569740561652246953718517,\r\n  0.1279381953467521569740561652246953718517,\r\n  0.1258374563468282961213753825111836887264,\r\n  0.1258374563468282961213753825111836887264,\r\n  0.121670472927803391204463153476262425607,\r\n  0.121670472927803391204463153476262425607,\r\n  0.1155056680537256013533444839067835598622,\r\n  0.1155056680537256013533444839067835598622,\r\n  0.1074442701159656347825773424466062227946,\r\n  0.1074442701159656347825773424466062227946,\r\n  0.0976186521041138882698806644642471544279,\r\n  0.0976186521041138882698806644642471544279,\r\n  0.086190161531953275917185202983742667185,\r\n  0.086190161531953275917185202983742667185,\r\n  0.0733464814110803057340336152531165181193,\r\n  0.0733464814110803057340336152531165181193,\r\n  0.0592985849154367807463677585001085845412,\r\n  0.0592985849154367807463677585001085845412,\r\n  0.0442774388174198061686027482113382288593,\r\n  0.0442774388174198061686027482113382288593,\r\n  0.0285313886289336631813078159518782864491,\r\n  0.0285313886289336631813078159518782864491,\r\n  0.0123412297999871995468056670700372915759,\r\n  0.0123412297999871995468056670700372915759,\r\n];\r\n\r\n/**\r\n * @param points\r\n * @returns\r\n */\r\nconst deriveBezier = (points: QuadPoints | CubicPoints) => {\r\n  const dpoints = [] as (DerivedCubicPoints | DerivedQuadPoints)[];\r\n  for (let p = points, d = p.length, c = d - 1; d > 1; d -= 1, c -= 1) {\r\n    const list = [] as unknown as DerivedCubicPoints | DerivedQuadPoints;\r\n    for (let j = 0; j < c; j += 1) {\r\n      list.push({\r\n        x: c * (p[j + 1].x - p[j].x),\r\n        y: c * (p[j + 1].y - p[j].y),\r\n        t: 0,\r\n      });\r\n    }\r\n    dpoints.push(list);\r\n    p = list;\r\n  }\r\n  return dpoints;\r\n};\r\n\r\n/**\r\n * @param points\r\n * @param t\r\n */\r\nconst computeBezier = (\r\n  points: DerivedQuadPoints | DerivedCubicPoints,\r\n  t: number,\r\n) => {\r\n  // shortcuts\r\n  /* istanbul ignore next @preserve */\r\n  if (t === 0) {\r\n    points[0].t = 0;\r\n    return points[0];\r\n  }\r\n\r\n  const order = points.length - 1;\r\n\r\n  /* istanbul ignore next @preserve */\r\n  if (t === 1) {\r\n    points[order].t = 1;\r\n    return points[order];\r\n  }\r\n\r\n  const mt = 1 - t;\r\n  let p = points as typeof points | [\r\n    DerivedPoint,\r\n    DerivedPoint,\r\n    DerivedPoint,\r\n    DerivedPoint,\r\n  ];\r\n\r\n  // constant?\r\n  /* istanbul ignore next @preserve */\r\n  if (order === 0) {\r\n    points[0].t = t;\r\n    return points[0];\r\n  }\r\n\r\n  // linear?\r\n  /* istanbul ignore else @preserve */\r\n  if (order === 1) {\r\n    return {\r\n      x: mt * p[0].x + t * p[1].x,\r\n      y: mt * p[0].y + t * p[1].y,\r\n      t,\r\n    };\r\n  }\r\n\r\n  // quadratic/cubic curve?\r\n  const mt2 = mt * mt;\r\n  const t2 = t * t;\r\n  let a = 0;\r\n  let b = 0;\r\n  let c = 0;\r\n  let d = 0;\r\n  /* istanbul ignore else @preserve */\r\n  if (order === 2) {\r\n    p = [p[0], p[1], p[2], { x: 0, y: 0 } as DerivedPoint];\r\n    a = mt2;\r\n    b = mt * t * 2;\r\n    c = t2;\r\n  } else if (order === 3) {\r\n    a = mt2 * mt;\r\n    b = mt2 * t * 3;\r\n    c = mt * t2 * 3;\r\n    d = t * t2;\r\n  }\r\n  return {\r\n    x: a * p[0].x + b * p[1].x + c * p[2].x + d * p[3].x,\r\n    y: a * p[0].y + b * p[1].y + c * p[2].y + d * p[3].y,\r\n    t,\r\n  };\r\n};\r\n\r\nconst calculateBezier = (derivativeFn: DeriveCallback, t: number) => {\r\n  const d = derivativeFn(t);\r\n  const l = d.x * d.x + d.y * d.y;\r\n\r\n  return Math.sqrt(l);\r\n};\r\n\r\nconst bezierLength = (derivativeFn: DeriveCallback) => {\r\n  const z = 0.5;\r\n  const len = Tvalues.length;\r\n\r\n  let sum = 0;\r\n\r\n  for (let i = 0, t; i < len; i++) {\r\n    t = z * Tvalues[i] + z;\r\n    sum += Cvalues[i] * calculateBezier(derivativeFn, t);\r\n  }\r\n  return z * sum;\r\n};\r\n\r\n/**\r\n * Returns the length of CubicBezier / Quad segment.\r\n * @param curve cubic / quad bezier segment\r\n */\r\nconst getBezierLength = (curve: CubicCoordinates | QuadCoordinates) => {\r\n  const points = [] as unknown as CubicPoints | QuadPoints;\r\n  for (let idx = 0, len = curve.length, step = 2; idx < len; idx += step) {\r\n    points.push({\r\n      x: curve[idx],\r\n      y: curve[idx + 1],\r\n    });\r\n  }\r\n  const dpoints = deriveBezier(points);\r\n  return bezierLength((t: number) => {\r\n    return computeBezier(dpoints[0], t);\r\n  });\r\n};\r\n\r\n// Precision for consider cubic polynom as quadratic one\r\nconst CBEZIER_MINMAX_EPSILON = 0.00000001;\r\n\r\n/**\r\n * Returns the most extreme points in a Quad Bezier segment.\r\n * @param A an array which consist of X/Y values\r\n */\r\n// https://github.com/kpym/SVGPathy/blob/acd1a50c626b36d81969f6e98e8602e128ba4302/lib/box.js#L89\r\nconst minmaxQ = ([v1, cp, v2]: [number, number, number]) => {\r\n  const min = Math.min(v1, v2);\r\n  const max = Math.max(v1, v2);\r\n\r\n  /* istanbul ignore next @preserve */\r\n  if (cp >= v1 ? v2 >= cp : v2 <= cp) {\r\n    // if no extremum in ]0,1[\r\n    return [min, max] as PointTuple;\r\n  }\r\n\r\n  // check if the extremum E is min or max\r\n  const E = (v1 * v2 - cp * cp) / (v1 - 2 * cp + v2);\r\n  return (E < min ? [E, max] : [min, E]) as PointTuple;\r\n};\r\n\r\n/**\r\n * Returns the most extreme points in a Cubic Bezier segment.\r\n * @param A an array which consist of X/Y values\r\n * @see https://github.com/kpym/SVGPathy/blob/acd1a50c626b36d81969f6e98e8602e128ba4302/lib/box.js#L127\r\n */\r\nconst minmaxC = ([v1, cp1, cp2, v2]: [number, number, number, number]) => {\r\n  const K = v1 - 3 * cp1 + 3 * cp2 - v2;\r\n\r\n  // if the polynomial is (almost) quadratic and not cubic\r\n  /* istanbul ignore next @preserve */\r\n  if (Math.abs(K) < CBEZIER_MINMAX_EPSILON) {\r\n    if (v1 === v2 && v1 === cp1) {\r\n      // no curve, point targeting same location\r\n      return [v1, v2] as PointTuple;\r\n    }\r\n\r\n    return minmaxQ([v1, -0.5 * v1 + 1.5 * cp1, v1 - 3 * cp1 + 3 * cp2]);\r\n  }\r\n\r\n  // the reduced discriminant of the derivative\r\n  const T = -v1 * cp2 + v1 * v2 - cp1 * cp2 - cp1 * v2 + cp1 * cp1 + cp2 * cp2;\r\n\r\n  // if the polynomial is monotone in [0,1]\r\n  if (T <= 0) {\r\n    return [Math.min(v1, v2), Math.max(v1, v2)] as PointTuple;\r\n  }\r\n  const S = Math.sqrt(T);\r\n\r\n  // potential extrema\r\n  let min = Math.min(v1, v2);\r\n  let max = Math.max(v1, v2);\r\n\r\n  const L = v1 - 2 * cp1 + cp2;\r\n  // check local extrema\r\n  for (let R = (L + S) / K, i = 1; i <= 2; R = (L - S) / K, i++) {\r\n    // istanbul ignore next @preserve\r\n    if (R > 0 && R < 1) {\r\n      // if the extrema is for R in [0,1]\r\n      const Q = v1 * (1 - R) * (1 - R) * (1 - R) +\r\n        cp1 * 3 * (1 - R) * (1 - R) * R + cp2 * 3 * (1 - R) * R * R +\r\n        v2 * R * R * R;\r\n      if (Q < min) {\r\n        min = Q;\r\n      }\r\n      if (Q > max) {\r\n        max = Q;\r\n      }\r\n    }\r\n  }\r\n\r\n  return [min, max] as PointTuple;\r\n};\r\n\r\nexport {\r\n  bezierLength,\r\n  calculateBezier,\r\n  CBEZIER_MINMAX_EPSILON,\r\n  computeBezier,\r\n  Cvalues,\r\n  deriveBezier,\r\n  getBezierLength,\r\n  minmaxC,\r\n  minmaxQ,\r\n  Tvalues,\r\n};\r\n","import { getBezierLength, minmaxC } from \"./bezier\";\r\nimport { type CubicCoordinates } from \"../types\";\r\n\r\n/**\r\n * Returns a point at a given length of a CubicBezier segment.\r\n *\r\n * @param x1 the starting point X\r\n * @param y1 the starting point Y\r\n * @param c1x the first control point X\r\n * @param c1y the first control point Y\r\n * @param c2x the second control point X\r\n * @param c2y the second control point Y\r\n * @param x2 the ending point X\r\n * @param y2 the ending point Y\r\n * @param t a [0-1] ratio\r\n * @returns the point at cubic-bezier segment length\r\n */\r\nconst getPointAtCubicSegmentLength = (\r\n  [x1, y1, c1x, c1y, c2x, c2y, x2, y2]: CubicCoordinates,\r\n  t: number,\r\n) => {\r\n  const t1 = 1 - t;\r\n  return {\r\n    x: t1 ** 3 * x1 + 3 * t1 ** 2 * t * c1x + 3 * t1 * t ** 2 * c2x +\r\n      t ** 3 * x2,\r\n    y: t1 ** 3 * y1 + 3 * t1 ** 2 * t * c1y + 3 * t1 * t ** 2 * c2y +\r\n      t ** 3 * y2,\r\n  };\r\n};\r\n\r\n/**\r\n * Returns the length of a CubicBezier segment.\r\n *\r\n * @param x1 the starting point X\r\n * @param y1 the starting point Y\r\n * @param c1x the first control point X\r\n * @param c1y the first control point Y\r\n * @param c2x the second control point X\r\n * @param c2y the second control point Y\r\n * @param x2 the ending point X\r\n * @param y2 the ending point Y\r\n * @returns the CubicBezier segment length\r\n */\r\nconst getCubicLength = (\r\n  x1: number,\r\n  y1: number,\r\n  c1x: number,\r\n  c1y: number,\r\n  c2x: number,\r\n  c2y: number,\r\n  x2: number,\r\n  y2: number,\r\n) => {\r\n  return getBezierLength([x1, y1, c1x, c1y, c2x, c2y, x2, y2]);\r\n};\r\n\r\n/**\r\n * Returns the point along a CubicBezier segment at a given distance.\r\n *\r\n * @param x1 the starting point X\r\n * @param y1 the starting point Y\r\n * @param c1x the first control point X\r\n * @param c1y the first control point Y\r\n * @param c2x the second control point X\r\n * @param c2y the second control point Y\r\n * @param x2 the ending point X\r\n * @param y2 the ending point Y\r\n * @param distance the distance to look at\r\n * @returns the point at CubicBezier length\r\n */\r\nconst getPointAtCubicLength = (\r\n  x1: number,\r\n  y1: number,\r\n  c1x: number,\r\n  c1y: number,\r\n  c2x: number,\r\n  c2y: number,\r\n  x2: number,\r\n  y2: number,\r\n  distance?: number,\r\n) => {\r\n  const distanceIsNumber = typeof distance === \"number\";\r\n  let point = { x: x1, y: y1 };\r\n  /* istanbul ignore else @preserve */\r\n  if (distanceIsNumber) {\r\n    const currentLength = getBezierLength([x1, y1, c1x, c1y, c2x, c2y, x2, y2]);\r\n    if (distance <= 0) {\r\n      // first point already defined\r\n    } else if (distance >= currentLength) {\r\n      point = { x: x2, y: y2 };\r\n    } else {\r\n      point = getPointAtCubicSegmentLength(\r\n        [x1, y1, c1x, c1y, c2x, c2y, x2, y2],\r\n        distance / currentLength,\r\n      );\r\n    }\r\n  }\r\n  return point;\r\n};\r\n\r\n/**\r\n * Returns the boundig box of a CubicBezier segment in the following format:\r\n * [MIN_X, MIN_Y, MAX_X, MAX_Y]\r\n *\r\n * @param x1 the starting point X\r\n * @param y1 the starting point Y\r\n * @param c1x the first control point X\r\n * @param c1y the first control point Y\r\n * @param c2x the second control point X\r\n * @param c2y the second control point Y\r\n * @param x2 the ending point X\r\n * @param y2 the ending point Y\r\n * @returns the extrema of the CubicBezier segment\r\n */\r\nconst getCubicBBox = (\r\n  x1: number,\r\n  y1: number,\r\n  c1x: number,\r\n  c1y: number,\r\n  c2x: number,\r\n  c2y: number,\r\n  x2: number,\r\n  y2: number,\r\n) => {\r\n  const cxMinMax = minmaxC([x1, c1x, c2x, x2]);\r\n  const cyMinMax = minmaxC([y1, c1y, c2y, y2]);\r\n\r\n  return [cxMinMax[0], cyMinMax[0], cxMinMax[1], cyMinMax[1]] as [\r\n    number,\r\n    number,\r\n    number,\r\n    number,\r\n  ];\r\n};\r\n\r\nexport {\r\n  getCubicBBox,\r\n  getCubicLength,\r\n  getPointAtCubicLength,\r\n  getPointAtCubicSegmentLength,\r\n};\r\n","import { getBezierLength, minmaxQ } from \"./bezier\";\r\nimport { type QuadCoordinates } from \"../types\";\r\n\r\n/**\r\n * Returns the {x,y} coordinates of a point at a\r\n * given length of a quadratic-bezier segment.\r\n *\r\n * @see https://github.com/substack/point-at-length\r\n *\r\n * @param x1 the starting point X\r\n * @param y1 the starting point Y\r\n * @param cx the control point X\r\n * @param cy the control point Y\r\n * @param x2 the ending point X\r\n * @param y2 the ending point Y\r\n * @param t a [0-1] ratio\r\n * @returns the requested {x,y} coordinates\r\n */\r\nconst getPointAtQuadSegmentLength = (\r\n  [x1, y1, cx, cy, x2, y2]: QuadCoordinates,\r\n  t: number,\r\n) => {\r\n  const t1 = 1 - t;\r\n  return {\r\n    x: t1 ** 2 * x1 + 2 * t1 * t * cx + t ** 2 * x2,\r\n    y: t1 ** 2 * y1 + 2 * t1 * t * cy + t ** 2 * y2,\r\n  };\r\n};\r\n\r\n/**\r\n * Returns the length of a QuadraticBezier segment.\r\n *\r\n * @param x1 the starting point X\r\n * @param y1 the starting point Y\r\n * @param cx the control point X\r\n * @param cy the control point Y\r\n * @param x2 the ending point X\r\n * @param y2 the ending point Y\r\n * @returns the QuadraticBezier segment length\r\n */\r\nconst getQuadLength = (\r\n  x1: number,\r\n  y1: number,\r\n  cx: number,\r\n  cy: number,\r\n  x2: number,\r\n  y2: number,\r\n) => {\r\n  return getBezierLength([x1, y1, cx, cy, x2, y2]);\r\n};\r\n\r\n/**\r\n * Returns the point along a QuadraticBezier segment at a given distance.\r\n *\r\n * @param x1 the starting point X\r\n * @param y1 the starting point Y\r\n * @param cx the control point X\r\n * @param cy the control point Y\r\n * @param x2 the ending point X\r\n * @param y2 the ending point Y\r\n * @param distance the distance to look at\r\n * @returns the point at QuadraticBezier length\r\n */\r\nconst getPointAtQuadLength = (\r\n  x1: number,\r\n  y1: number,\r\n  cx: number,\r\n  cy: number,\r\n  x2: number,\r\n  y2: number,\r\n  distance?: number,\r\n) => {\r\n  const distanceIsNumber = typeof distance === \"number\";\r\n  let point = { x: x1, y: y1 };\r\n\r\n  /* istanbul ignore else @preserve */\r\n  if (distanceIsNumber) {\r\n    const currentLength = getBezierLength([x1, y1, cx, cy, x2, y2]);\r\n    if (distance <= 0) {\r\n      // first point already defined\r\n    } else if (distance >= currentLength) {\r\n      point = { x: x2, y: y2 };\r\n    } else {\r\n      point = getPointAtQuadSegmentLength(\r\n        [x1, y1, cx, cy, x2, y2],\r\n        distance / currentLength,\r\n      );\r\n    }\r\n  }\r\n  return point;\r\n};\r\n\r\n/**\r\n * Returns the boundig box of a QuadraticBezier segment in the following format:\r\n * [MIN_X, MIN_Y, MAX_X, MAX_Y]\r\n *\r\n * @param x1 the starting point X\r\n * @param y1 the starting point Y\r\n * @param cx the control point X\r\n * @param cy the control point Y\r\n * @param x2 the ending point X\r\n * @param y2 the ending point Y\r\n * @returns the extrema of the QuadraticBezier segment\r\n */\r\nconst getQuadBBox = (\r\n  x1: number,\r\n  y1: number,\r\n  cx: number,\r\n  cy: number,\r\n  x2: number,\r\n  y2: number,\r\n) => {\r\n  const cxMinMax = minmaxQ([x1, cx, x2]);\r\n  const cyMinMax = minmaxQ([y1, cy, y2]);\r\n  return [cxMinMax[0], cyMinMax[0], cxMinMax[1], cyMinMax[1]] as [\r\n    number,\r\n    number,\r\n    number,\r\n    number,\r\n  ];\r\n};\r\n\r\nexport {\r\n  getPointAtQuadLength,\r\n  getPointAtQuadSegmentLength,\r\n  getQuadBBox,\r\n  getQuadLength,\r\n};\r\n","import distanceSquareRoot from \"./distanceSquareRoot\";\r\nimport { type PointTuple } from \"../types\";\r\n\r\n/**\r\n * d3-polygon-area\r\n * https://github.com/d3/d3-polygon\r\n *\r\n * Returns the area of a polygon.\r\n *\r\n * @param polygon an array of coordinates\r\n * @returns the polygon area\r\n */\r\nconst polygonArea = (polygon: PointTuple[]) => {\r\n  const n = polygon.length;\r\n  let i = -1;\r\n  let a: PointTuple;\r\n  let b = polygon[n - 1];\r\n  let area = 0;\r\n\r\n  /* eslint-disable-next-line */\r\n  while (++i < n) {\r\n    a = b;\r\n    b = polygon[i];\r\n    area += a[1] * b[0] - a[0] * b[1];\r\n  }\r\n\r\n  return area / 2;\r\n};\r\n\r\n/**\r\n * d3-polygon-length\r\n * https://github.com/d3/d3-polygon\r\n *\r\n * Returns the perimeter of a polygon.\r\n *\r\n * @param polygon an array of coordinates\r\n * @returns the polygon length\r\n */\r\nconst polygonLength = (polygon: PointTuple[]) => {\r\n  return polygon.reduce((length, point, i) => {\r\n    if (i) {\r\n      return length + distanceSquareRoot(polygon[i - 1], point);\r\n    }\r\n    return 0;\r\n  }, 0);\r\n};\r\n\r\nexport { polygonArea, polygonLength };\r\n","const DISTANCE_EPSILON = 0.00001;\r\n\r\nexport default DISTANCE_EPSILON;\r\n","import normalizeSegment from \"./normalizeSegment\";\r\nimport type { NormalArray, PathArray } from \"../types\";\r\nimport iterate from \"./iterate\";\r\nimport parsePathString from \"../parser/parsePathString\";\r\nimport paramsParser from \"../parser/paramsParser\";\r\n\r\n/**\r\n * Normalizes a `pathArray` object for further processing:\r\n * * convert segments to absolute values\r\n * * convert shorthand path commands to their non-shorthand notation\r\n *\r\n * @param pathInput the string to be parsed or 'pathArray'\r\n * @returns the normalized `pathArray`\r\n */\r\nconst normalizePath = (pathInput: string | PathArray) => {\r\n  const path = parsePathString(pathInput);\r\n  const params = { ...paramsParser };\r\n\r\n  return iterate<NormalArray>(path, (seg, _, lastX, lastY) => {\r\n    params.x = lastX;\r\n    params.y = lastY;\r\n    const result = normalizeSegment(seg, params);\r\n\r\n    const seglen = result.length;\r\n    params.x1 = +result[seglen - 2];\r\n    params.y1 = +result[seglen - 1];\r\n    params.x2 = +result[seglen - 4] || params.x1;\r\n    params.y2 = +result[seglen - 3] || params.y1;\r\n\r\n    return result;\r\n  });\r\n};\r\nexport default normalizePath;\r\n","import DISTANCE_EPSILON from \"./distanceEpsilon\";\r\nimport type { MSegment, PathArray, PointTuple } from \"../types\";\r\nimport iterate from \"../process/iterate\";\r\nimport { getLineLength, getPointAtLineLength } from \"../math/lineTools\";\r\nimport { getArcLength, getPointAtArcLength } from \"../math/arcTools\";\r\nimport { getCubicLength, getPointAtCubicLength } from \"../math/cubicTools\";\r\nimport { getPointAtQuadLength, getQuadLength } from \"../math/quadTools\";\r\nimport normalizePath from \"../process/normalizePath\";\r\n\r\n/**\r\n * Returns [x,y] coordinates of a point at a given length of a shape.\r\n *\r\n * @param pathInput the `pathArray` to look into\r\n * @param distance the length of the shape to look at\r\n * @returns the requested {x, y} point coordinates\r\n */\r\nconst getPointAtLength = (pathInput: string | PathArray, distance?: number) => {\r\n  const path = normalizePath(pathInput);\r\n  let isM = false;\r\n  let data = [] as number[];\r\n  let pathCommand = \"M\";\r\n  let x = 0;\r\n  let y = 0;\r\n  let [mx, my] = path[0].slice(1) as PointTuple;\r\n  const distanceIsNumber = typeof distance === \"number\";\r\n  let point = { x: mx, y: my };\r\n  let length = 0;\r\n  let POINT = point;\r\n  let totalLength = 0;\r\n\r\n  if (!distanceIsNumber || distance < DISTANCE_EPSILON) return point;\r\n\r\n  // for (let i = 0; i < pathLen; i += 1) {\r\n  iterate(path, (seg, _, lastX, lastY) => {\r\n    [pathCommand] = seg;\r\n    isM = pathCommand === \"M\";\r\n    data = !isM ? [lastX, lastY].concat(seg.slice(1) as number[]) : data;\r\n\r\n    // this segment is always ZERO\r\n    /* istanbul ignore else @preserve */\r\n    if (isM) {\r\n      // remember mx, my for Z\r\n      [, mx, my] = seg as MSegment;\r\n      point = { x: mx, y: my };\r\n      length = 0;\r\n    } else if (pathCommand === \"L\") {\r\n      point = getPointAtLineLength(\r\n        data[0],\r\n        data[1],\r\n        data[2],\r\n        data[3],\r\n        distance - totalLength,\r\n      );\r\n      length = getLineLength(data[0], data[1], data[2], data[3]);\r\n    } else if (pathCommand === \"A\") {\r\n      point = getPointAtArcLength(\r\n        data[0],\r\n        data[1],\r\n        data[2],\r\n        data[3],\r\n        data[4],\r\n        data[5],\r\n        data[6],\r\n        data[7],\r\n        data[8],\r\n        distance - totalLength,\r\n      );\r\n      length = getArcLength(\r\n        data[0],\r\n        data[1],\r\n        data[2],\r\n        data[3],\r\n        data[4],\r\n        data[5],\r\n        data[6],\r\n        data[7],\r\n        data[8],\r\n      );\r\n    } else if (pathCommand === \"C\") {\r\n      point = getPointAtCubicLength(\r\n        data[0],\r\n        data[1],\r\n        data[2],\r\n        data[3],\r\n        data[4],\r\n        data[5],\r\n        data[6],\r\n        data[7],\r\n        distance - totalLength,\r\n      );\r\n      length = getCubicLength(\r\n        data[0],\r\n        data[1],\r\n        data[2],\r\n        data[3],\r\n        data[4],\r\n        data[5],\r\n        data[6],\r\n        data[7],\r\n      );\r\n    } else if (pathCommand === \"Q\") {\r\n      point = getPointAtQuadLength(\r\n        data[0],\r\n        data[1],\r\n        data[2],\r\n        data[3],\r\n        data[4],\r\n        data[5],\r\n        distance - totalLength,\r\n      );\r\n      length = getQuadLength(\r\n        data[0],\r\n        data[1],\r\n        data[2],\r\n        data[3],\r\n        data[4],\r\n        data[5],\r\n      );\r\n    } else if (pathCommand === \"Z\") {\r\n      data = [lastX, lastY, mx, my];\r\n      point = { x: mx, y: my };\r\n\r\n      length = getLineLength(data[0], data[1], data[2], data[3]);\r\n    }\r\n\r\n    [x, y] = data.slice(-2);\r\n\r\n    if (totalLength < distance) {\r\n      POINT = point;\r\n    } else {\r\n      // totalLength >= distance\r\n      // stop right here\r\n      // stop iterator now!\r\n      return false;\r\n    }\r\n\r\n    totalLength += length;\r\n    return;\r\n  });\r\n\r\n  // native `getPointAtLength` behavior when the given distance\r\n  // is higher than total length\r\n  if (distance > totalLength - DISTANCE_EPSILON) {\r\n    return { x, y };\r\n  }\r\n\r\n  return POINT;\r\n};\r\n\r\nexport default getPointAtLength;\r\n","import type { LSegment, MSegment, PathArray, PointTuple } from \"../types\";\r\nimport { getLineLength } from \"../math/lineTools\";\r\nimport { getArcLength } from \"../math/arcTools\";\r\nimport { getCubicLength } from \"../math/cubicTools\";\r\nimport { getQuadLength } from \"../math/quadTools\";\r\nimport iterate from \"../process/iterate\";\r\nimport parsePathString from \"../parser/parsePathString\";\r\nimport absolutizeSegment from \"../process/absolutizeSegment\";\r\n\r\n/**\r\n * Returns the shape total length, or the equivalent to `shape.getTotalLength()`.\r\n *\r\n * @param pathInput the target `pathArray`\r\n * @returns the shape total length\r\n */\r\nconst getTotalLength = (pathInput: string | PathArray) => {\r\n  const path = parsePathString(pathInput);\r\n  let paramX1 = 0;\r\n  let paramY1 = 0;\r\n  let paramX2 = 0;\r\n  let paramY2 = 0;\r\n  let paramQX = 0;\r\n  let paramQY = 0;\r\n  let pathCommand = \"M\";\r\n  let mx = 0;\r\n  let my = 0;\r\n  let totalLength = 0;\r\n\r\n  iterate(path, (seg, index, lastX, lastY) => {\r\n    [pathCommand] = seg;\r\n    const absCommand = pathCommand.toUpperCase();\r\n    const isRelative = absCommand !== pathCommand;\r\n    const absoluteSegment = isRelative\r\n      ? absolutizeSegment(seg, index, lastX, lastY)\r\n      : (seg.slice(0) as typeof seg);\r\n\r\n    const normalSegment = absCommand === \"V\"\r\n      ? ([\"L\", lastX, absoluteSegment[1]] as LSegment)\r\n      : absCommand === \"H\"\r\n      ? ([\"L\", absoluteSegment[1], lastY] as LSegment)\r\n      : absoluteSegment;\r\n    [pathCommand] = normalSegment;\r\n\r\n    if (!\"TQ\".includes(absCommand)) {\r\n      // optional but good to be cautious\r\n      paramQX = 0;\r\n      paramQY = 0;\r\n    }\r\n\r\n    // this segment is always ZERO\r\n    /* istanbul ignore else @preserve */\r\n    if (pathCommand === \"M\") {\r\n      // remember mx, my for Z\r\n      [, mx, my] = normalSegment as MSegment;\r\n    } else if (pathCommand === \"L\") {\r\n      totalLength += getLineLength(\r\n        lastX,\r\n        lastY,\r\n        normalSegment[1] as number,\r\n        normalSegment[2] as number,\r\n      );\r\n    } else if (pathCommand === \"A\") {\r\n      totalLength += getArcLength(\r\n        lastX,\r\n        lastY,\r\n        normalSegment[1] as number,\r\n        normalSegment[2] as number,\r\n        normalSegment[3] as number,\r\n        normalSegment[4] as number,\r\n        normalSegment[5] as number,\r\n        normalSegment[6] as number,\r\n        normalSegment[7] as number,\r\n      );\r\n    } else if (pathCommand === \"S\") {\r\n      const cp1x = paramX1 * 2 - paramX2;\r\n      const cp1y = paramY1 * 2 - paramY2;\r\n\r\n      totalLength += getCubicLength(\r\n        lastX,\r\n        lastY,\r\n        cp1x,\r\n        cp1y,\r\n        normalSegment[1] as number,\r\n        normalSegment[2] as number,\r\n        normalSegment[3] as number,\r\n        normalSegment[4] as number,\r\n      );\r\n    } else if (pathCommand === \"C\") {\r\n      totalLength += getCubicLength(\r\n        lastX,\r\n        lastY,\r\n        normalSegment[1] as number,\r\n        normalSegment[2] as number,\r\n        normalSegment[3] as number,\r\n        normalSegment[4] as number,\r\n        normalSegment[5] as number,\r\n        normalSegment[6] as number,\r\n      );\r\n    } else if (pathCommand === \"T\") {\r\n      paramQX = paramX1 * 2 - paramQX;\r\n      paramQY = paramY1 * 2 - paramQY;\r\n      totalLength += getQuadLength(\r\n        lastX,\r\n        lastY,\r\n        paramQX,\r\n        paramQY,\r\n        normalSegment[1] as number,\r\n        normalSegment[2] as number,\r\n      );\r\n    } else if (pathCommand === \"Q\") {\r\n      paramQX = normalSegment[1] as number;\r\n      paramQY = normalSegment[2] as number;\r\n      totalLength += getQuadLength(\r\n        lastX,\r\n        lastY,\r\n        normalSegment[1] as number,\r\n        normalSegment[2] as number,\r\n        normalSegment[3] as number,\r\n        normalSegment[4] as number,\r\n      );\r\n    } else if (pathCommand === \"Z\") {\r\n      totalLength += getLineLength(lastX, lastY, mx, my);\r\n    }\r\n\r\n    // update params\r\n    [paramX1, paramY1] = pathCommand === \"Z\"\r\n      ? [mx, my]\r\n      : (normalSegment.slice(-2) as PointTuple);\r\n    [paramX2, paramY2] = pathCommand === \"C\"\r\n      ? ([normalSegment[3], normalSegment[4]] as PointTuple)\r\n      : pathCommand === \"S\"\r\n      ? ([normalSegment[1], normalSegment[2]] as PointTuple)\r\n      : [paramX1, paramY1];\r\n  });\r\n\r\n  return totalLength;\r\n};\r\n\r\nexport default getTotalLength;\r\n","import type { PathArray, PathSegment } from \"../types\";\r\nimport type { SegmentProperties } from \"../interface\";\r\nimport parsePathString from \"../parser/parsePathString\";\r\nimport getTotalLength from \"./getTotalLength\";\r\n\r\n/**\r\n * Returns the segment, its index and length as well as\r\n * the length to that segment at a given length in a path.\r\n *\r\n * @param pathInput target `pathArray`\r\n * @param distance the given length\r\n * @returns the requested properties\r\n */\r\nconst getPropertiesAtLength = (\r\n  pathInput: string | PathArray,\r\n  distance?: number,\r\n): SegmentProperties => {\r\n  const pathArray = parsePathString(pathInput);\r\n\r\n  let pathTemp = pathArray.slice(0) as PathArray;\r\n  let pathLength = getTotalLength(pathTemp);\r\n  let index = pathTemp.length - 1;\r\n  let lengthAtSegment = 0;\r\n  let length = 0;\r\n  let segment = pathArray[0] as PathSegment;\r\n\r\n  // If the path is empty, return 0.\r\n  if (index <= 0 || !distance || !Number.isFinite(distance)) {\r\n    return {\r\n      segment,\r\n      index: 0,\r\n      length,\r\n      lengthAtSegment,\r\n    };\r\n  }\r\n\r\n  if (distance >= pathLength) {\r\n    pathTemp = pathArray.slice(0, -1) as PathArray;\r\n    lengthAtSegment = getTotalLength(pathTemp);\r\n    length = pathLength - lengthAtSegment;\r\n    segment = pathArray[index];\r\n    return {\r\n      segment,\r\n      index,\r\n      length,\r\n      lengthAtSegment,\r\n    };\r\n  }\r\n\r\n  const segments = [] as SegmentProperties[];\r\n  while (index > 0) {\r\n    segment = pathTemp[index];\r\n    pathTemp = pathTemp.slice(0, -1) as PathArray;\r\n    lengthAtSegment = getTotalLength(pathTemp);\r\n    length = pathLength - lengthAtSegment;\r\n    pathLength = lengthAtSegment;\r\n\r\n    segments.push({\r\n      segment,\r\n      index,\r\n      length,\r\n      lengthAtSegment,\r\n    });\r\n    index -= 1;\r\n  }\r\n\r\n  return segments.find(({ lengthAtSegment: l }) =>\r\n    l <= distance\r\n  ) as SegmentProperties;\r\n};\r\n\r\nexport default getPropertiesAtLength;\r\n","import type { PathArray, Point } from \"../types\";\r\nimport type { PointProperties } from \"../interface\";\r\nimport getPointAtLength from \"./getPointAtLength\";\r\nimport getPropertiesAtLength from \"./getPropertiesAtLength\";\r\nimport getTotalLength from \"./getTotalLength\";\r\nimport parsePathString from \"../parser/parsePathString\";\r\nimport normalizePath from \"../process/normalizePath\";\r\n\r\n/**\r\n * Returns the point and segment in path closest to a given point as well as\r\n * the distance to the path stroke.\r\n *\r\n * @see https://bl.ocks.org/mbostock/8027637\r\n *\r\n * @param pathInput target `pathArray`\r\n * @param point the given point\r\n * @returns the requested properties\r\n */\r\nconst getPropertiesAtPoint = (\r\n  pathInput: string | PathArray,\r\n  point: Point,\r\n): PointProperties => {\r\n  const path = parsePathString(pathInput);\r\n  const normalPath = normalizePath(path);\r\n  const pathLength = getTotalLength(normalPath);\r\n  const distanceTo = (p: Point) => {\r\n    const dx = p.x - point.x;\r\n    const dy = p.y - point.y;\r\n    return dx * dx + dy * dy;\r\n  };\r\n  let precision = 8;\r\n  let scan: Point;\r\n  let closest = { x: 0, y: 0 }; // make TS happy\r\n  let scanDistance = 0;\r\n  let bestLength = 0;\r\n  let bestDistance = Infinity;\r\n\r\n  // linear scan for coarse approximation\r\n  for (let scanLength = 0; scanLength <= pathLength; scanLength += precision) {\r\n    scan = getPointAtLength(normalPath, scanLength);\r\n    scanDistance = distanceTo(scan);\r\n\r\n    if (scanDistance < bestDistance) {\r\n      closest = scan;\r\n      bestLength = scanLength;\r\n      bestDistance = scanDistance;\r\n    }\r\n  }\r\n\r\n  // binary search for precise estimate\r\n  precision /= 2;\r\n  let before: { x: number; y: number };\r\n  let after: { x: number; y: number };\r\n  let beforeLength = 0;\r\n  let afterLength = 0;\r\n  let beforeDistance = 0;\r\n  let afterDistance = 0;\r\n\r\n  while (precision > 0.000001) {\r\n    beforeLength = bestLength - precision;\r\n    before = getPointAtLength(normalPath, beforeLength);\r\n    beforeDistance = distanceTo(before);\r\n    afterLength = bestLength + precision;\r\n    after = getPointAtLength(normalPath, afterLength);\r\n    afterDistance = distanceTo(after);\r\n\r\n    if (beforeLength >= 0 && beforeDistance < bestDistance) {\r\n      closest = before;\r\n      bestLength = beforeLength;\r\n      bestDistance = beforeDistance;\r\n    } else if (afterLength <= pathLength && afterDistance < bestDistance) {\r\n      closest = after;\r\n      bestLength = afterLength;\r\n      bestDistance = afterDistance;\r\n    } else {\r\n      precision /= 2;\r\n    }\r\n    if (precision < 0.00001) break;\r\n  }\r\n\r\n  const segment = getPropertiesAtLength(path, bestLength);\r\n  const distance = Math.sqrt(bestDistance);\r\n\r\n  return { closest, distance, segment };\r\n};\r\n\r\nexport default getPropertiesAtPoint;\r\n","import type { PathArray } from \"../types\";\r\nimport getPropertiesAtPoint from \"./getPropertiesAtPoint\";\r\n\r\n/**\r\n * Returns the point in path closest to a given point.\r\n *\r\n * @param pathInput target `pathArray`\r\n * @param point the given point\r\n * @returns the best match\r\n */\r\nconst getClosestPoint = (\r\n  pathInput: string | PathArray,\r\n  point: { x: number; y: number },\r\n) => {\r\n  return getPropertiesAtPoint(pathInput, point).closest;\r\n};\r\n\r\nexport default getClosestPoint;\r\n","import pathToCurve from \"../convert/pathToCurve\";\r\nimport type { PathArray, PointTuple } from \"../types\";\r\n\r\n/**\r\n * Returns the area of a single cubic-bezier segment.\r\n *\r\n * http://objectmix.com/graphics/133553-area-closed-bezier-curve.html\r\n *\r\n * @param x1 the starting point X\r\n * @param y1 the starting point Y\r\n * @param c1x the first control point X\r\n * @param c1y the first control point Y\r\n * @param c2x the second control point X\r\n * @param c2y the second control point Y\r\n * @param x2 the ending point X\r\n * @param y2 the ending point Y\r\n * @returns the area of the cubic-bezier segment\r\n */\r\nconst getCubicSegArea = (\r\n  x1: number,\r\n  y1: number,\r\n  c1x: number,\r\n  c1y: number,\r\n  c2x: number,\r\n  c2y: number,\r\n  x2: number,\r\n  y2: number,\r\n) => {\r\n  return (\r\n    (3 *\r\n      ((y2 - y1) * (c1x + c2x) -\r\n        (x2 - x1) * (c1y + c2y) +\r\n        c1y * (x1 - c2x) -\r\n        c1x * (y1 - c2y) +\r\n        y2 * (c2x + x1 / 3) -\r\n        x2 * (c2y + y1 / 3))) /\r\n    20\r\n  );\r\n};\r\n\r\n/**\r\n * Returns the area of a shape.\r\n *\r\n * @author Jrg Lehni & Jonathan Puckey\r\n *\r\n * @see https://github.com/paperjs/paper.js/blob/develop/src/path/Path.js\r\n *\r\n * @param path the shape `pathArray`\r\n * @returns the length of the cubic-bezier segment\r\n */\r\nconst getPathArea = (path: PathArray) => {\r\n  let x = 0;\r\n  let y = 0;\r\n  let len = 0;\r\n\r\n  return pathToCurve(path)\r\n    .map((seg) => {\r\n      switch (seg[0]) {\r\n        case \"M\":\r\n          [, x, y] = seg;\r\n          return 0;\r\n        default:\r\n          len = getCubicSegArea(\r\n            x,\r\n            y,\r\n            seg[1],\r\n            seg[2],\r\n            seg[3],\r\n            seg[4],\r\n            seg[5],\r\n            seg[6],\r\n          );\r\n          [x, y] = seg.slice(-2) as PointTuple;\r\n          return len;\r\n      }\r\n    })\r\n    .reduce((a, b) => a + b, 0);\r\n};\r\nexport default getPathArea;\r\n","import getPathArea from \"./getPathArea\";\r\nimport pathToCurve from \"../convert/pathToCurve\";\r\nimport type { PathArray } from \"../types\";\r\n\r\n/**\r\n * Check if a path is drawn clockwise and returns true if so,\r\n * false otherwise.\r\n *\r\n * @param path the path string or `pathArray`\r\n * @returns true when clockwise or false if not\r\n */\r\nconst getDrawDirection = (path: string | PathArray) => {\r\n  return getPathArea(pathToCurve(path)) >= 0;\r\n};\r\n\r\nexport default getDrawDirection;\r\n","import iterate from \"../process/iterate\";\r\nimport { PathBBox } from \"../interface\";\r\nimport { LSegment, MSegment, PathArray, PointTuple } from \"../types\";\r\nimport { getLineBBox } from \"../math/lineTools\";\r\nimport { getArcBBox } from \"../math/arcTools\";\r\nimport { getCubicBBox } from \"../math/cubicTools\";\r\nimport { getQuadBBox } from \"../math/quadTools\";\r\nimport parsePathString from \"../parser/parsePathString\";\r\nimport absolutizeSegment from \"../process/absolutizeSegment\";\r\n\r\nconst getPathBBox = (pathInput: PathArray | string) => {\r\n  if (!pathInput) {\r\n    return {\r\n      x: 0,\r\n      y: 0,\r\n      width: 0,\r\n      height: 0,\r\n      x2: 0,\r\n      y2: 0,\r\n      cx: 0,\r\n      cy: 0,\r\n      cz: 0,\r\n    };\r\n  }\r\n\r\n  const path = parsePathString(pathInput);\r\n  let pathCommand = \"M\";\r\n  let mx = 0;\r\n  let my = 0;\r\n  const { max, min } = Math;\r\n  let xMin = Infinity;\r\n  let yMin = Infinity;\r\n  let xMax = -Infinity;\r\n  let yMax = -Infinity;\r\n  let minX = 0;\r\n  let minY = 0;\r\n  let maxX = 0;\r\n  let maxY = 0;\r\n  let paramX1 = 0;\r\n  let paramY1 = 0;\r\n  let paramX2 = 0;\r\n  let paramY2 = 0;\r\n  let paramQX = 0;\r\n  let paramQY = 0;\r\n\r\n  iterate(path, (seg, index, lastX, lastY) => {\r\n    [pathCommand] = seg;\r\n    const absCommand = pathCommand.toUpperCase();\r\n    const isRelative = absCommand !== pathCommand;\r\n    const absoluteSegment = isRelative\r\n      ? absolutizeSegment(seg, index, lastX, lastY)\r\n      : (seg.slice(0) as typeof seg);\r\n\r\n    const normalSegment = absCommand === \"V\"\r\n      ? ([\"L\", lastX, absoluteSegment[1]] as LSegment)\r\n      : absCommand === \"H\"\r\n      ? ([\"L\", absoluteSegment[1], lastY] as LSegment)\r\n      : absoluteSegment;\r\n\r\n    [pathCommand] = normalSegment;\r\n\r\n    if (!\"TQ\".includes(absCommand)) {\r\n      // optional but good to be cautious\r\n      paramQX = 0;\r\n      paramQY = 0;\r\n    }\r\n\r\n    // this segment is always ZERO\r\n    /* istanbul ignore else @preserve */\r\n    if (pathCommand === \"M\") {\r\n      [, mx, my] = normalSegment as MSegment;\r\n      minX = mx;\r\n      minY = my;\r\n      maxX = mx;\r\n      maxY = my;\r\n    } else if (pathCommand === \"L\") {\r\n      [minX, minY, maxX, maxY] = getLineBBox(\r\n        lastX,\r\n        lastY,\r\n        normalSegment[1] as number,\r\n        normalSegment[2] as number,\r\n      );\r\n    } else if (pathCommand === \"A\") {\r\n      [minX, minY, maxX, maxY] = getArcBBox(\r\n        lastX,\r\n        lastY,\r\n        normalSegment[1] as number,\r\n        normalSegment[2] as number,\r\n        normalSegment[3] as number,\r\n        normalSegment[4] as number,\r\n        normalSegment[5] as number,\r\n        normalSegment[6] as number,\r\n        normalSegment[7] as number,\r\n      );\r\n    } else if (pathCommand === \"S\") {\r\n      const cp1x = paramX1 * 2 - paramX2;\r\n      const cp1y = paramY1 * 2 - paramY2;\r\n\r\n      [minX, minY, maxX, maxY] = getCubicBBox(\r\n        lastX,\r\n        lastY,\r\n        cp1x,\r\n        cp1y,\r\n        normalSegment[1] as number,\r\n        normalSegment[2] as number,\r\n        normalSegment[3] as number,\r\n        normalSegment[4] as number,\r\n      );\r\n    } else if (pathCommand === \"C\") {\r\n      [minX, minY, maxX, maxY] = getCubicBBox(\r\n        lastX,\r\n        lastY,\r\n        normalSegment[1] as number,\r\n        normalSegment[2] as number,\r\n        normalSegment[3] as number,\r\n        normalSegment[4] as number,\r\n        normalSegment[5] as number,\r\n        normalSegment[6] as number,\r\n      );\r\n    } else if (pathCommand === \"T\") {\r\n      paramQX = paramX1 * 2 - paramQX;\r\n      paramQY = paramY1 * 2 - paramQY;\r\n      [minX, minY, maxX, maxY] = getQuadBBox(\r\n        lastX,\r\n        lastY,\r\n        paramQX,\r\n        paramQY,\r\n        normalSegment[1] as number,\r\n        normalSegment[2] as number,\r\n      );\r\n    } else if (pathCommand === \"Q\") {\r\n      paramQX = normalSegment[1] as number;\r\n      paramQY = normalSegment[2] as number;\r\n      [minX, minY, maxX, maxY] = getQuadBBox(\r\n        lastX,\r\n        lastY,\r\n        normalSegment[1] as number,\r\n        normalSegment[2] as number,\r\n        normalSegment[3] as number,\r\n        normalSegment[4] as number,\r\n      );\r\n    } else if (pathCommand === \"Z\") {\r\n      [minX, minY, maxX, maxY] = getLineBBox(lastX, lastY, mx, my);\r\n    }\r\n    xMin = min(minX, xMin);\r\n    yMin = min(minY, yMin);\r\n    xMax = max(maxX, xMax);\r\n    yMax = max(maxY, yMax);\r\n\r\n    // update params\r\n    [paramX1, paramY1] = pathCommand === \"Z\"\r\n      ? [mx, my]\r\n      : (normalSegment.slice(-2) as PointTuple);\r\n    [paramX2, paramY2] = pathCommand === \"C\"\r\n      ? ([normalSegment[3], normalSegment[4]] as PointTuple)\r\n      : pathCommand === \"S\"\r\n      ? ([normalSegment[1], normalSegment[2]] as PointTuple)\r\n      : [paramX1, paramY1];\r\n  });\r\n\r\n  const width = xMax - xMin;\r\n  const height = yMax - yMin;\r\n\r\n  return {\r\n    width,\r\n    height,\r\n    x: xMin,\r\n    y: yMin,\r\n    x2: xMax,\r\n    y2: yMax,\r\n    cx: xMin + width / 2,\r\n    cy: yMin + height / 2,\r\n    // an estimated guess\r\n    cz: Math.max(width, height) + Math.min(width, height) / 2,\r\n  } satisfies PathBBox;\r\n};\r\n\r\nexport default getPathBBox;\r\n","import type { PathArray, PathSegment } from \"../types\";\r\nimport getPropertiesAtLength from \"./getPropertiesAtLength\";\r\n\r\n/**\r\n * Returns the segment at a given length.\r\n *\r\n * @param pathInput the target `pathArray`\r\n * @param distance the distance in path to look at\r\n * @returns the requested segment\r\n */\r\nconst getSegmentAtLength = (\r\n  pathInput: string | PathArray,\r\n  distance?: number,\r\n): PathSegment | undefined => {\r\n  return getPropertiesAtLength(pathInput, distance).segment;\r\n};\r\n\r\nexport default getSegmentAtLength;\r\n","import type { SegmentProperties } from \"../interface\";\r\nimport type { PathArray } from \"../types\";\r\nimport getPropertiesAtPoint from \"./getPropertiesAtPoint\";\r\n\r\n/**\r\n * Returns the path segment which contains a given point.\r\n *\r\n * @param path the `pathArray` to look into\r\n * @param point the point of the shape to look for\r\n * @returns the requested segment\r\n */\r\nconst getSegmentOfPoint = (\r\n  path: string | PathArray,\r\n  point: { x: number; y: number },\r\n): SegmentProperties | undefined => {\r\n  return getPropertiesAtPoint(path, point).segment;\r\n};\r\nexport default getSegmentOfPoint;\r\n","import type { PathArray, PathSegment, RelativeCommand } from \"../types\";\r\nimport paramsCount from \"../parser/paramsCount\";\r\n\r\n/**\r\n * Iterates an array to check if it's an actual `pathArray`.\r\n *\r\n * @param path the `pathArray` to be checked\r\n * @returns iteration result\r\n */\r\nconst isPathArray = (path: unknown): path is PathArray => {\r\n  return (\r\n    Array.isArray(path) &&\r\n    path.every((seg: PathSegment) => {\r\n      const lk = seg[0].toLowerCase() as RelativeCommand;\r\n      return (\r\n        paramsCount[lk] === seg.length - 1 &&\r\n        \"achlmqstvz\".includes(lk) &&\r\n        (seg.slice(1) as unknown[]).every(Number.isFinite)\r\n      );\r\n    }) &&\r\n    path.length > 0\r\n  );\r\n};\r\nexport default isPathArray;\r\n","import type { AbsoluteArray } from \"../types\";\r\nimport isPathArray from \"./isPathArray\";\r\n\r\n/**\r\n * Iterates an array to check if it's a `pathArray`\r\n * with all absolute values.\r\n *\r\n * @param path the `pathArray` to be checked\r\n * @returns iteration result\r\n */\r\nconst isAbsoluteArray = (path: unknown): path is AbsoluteArray => {\r\n  return (\r\n    isPathArray(path) &&\r\n    // `isPathArray` also checks if it's `Array`\r\n    path.every(([x]) => x === x.toUpperCase())\r\n  );\r\n};\r\nexport default isAbsoluteArray;\r\n","import type { NormalArray } from \"../types\";\r\nimport isAbsoluteArray from \"./isAbsoluteArray\";\r\n\r\n/**\r\n * Iterates an array to check if it's a `pathArray`\r\n * with all segments are in non-shorthand notation\r\n * with absolute values.\r\n *\r\n * @param {string | SVGPath.pathArray} path the `pathArray` to be checked\r\n * @returns {boolean} iteration result\r\n */\r\nconst isNormalizedArray = (path: unknown): path is NormalArray => {\r\n  // `isAbsoluteArray` also checks if it's `Array`\r\n  return isAbsoluteArray(path) && path.every(([pc]) => \"ACLMQZ\".includes(pc));\r\n};\r\nexport default isNormalizedArray;\r\n","import { CurveArray } from \"../types\";\r\nimport isNormalizedArray from \"./isNormalizedArray\";\r\n\r\n/**\r\n * Iterates an array to check if it's a `pathArray`\r\n * with all C (cubic bezier) segments.\r\n *\r\n * @param path the `Array` to be checked\r\n * @returns iteration result\r\n */\r\nconst isCurveArray = (path: unknown): path is CurveArray => {\r\n  // `isPathArray` also checks if it's `Array`\r\n  return isNormalizedArray(path) && path.every(([pc]) => \"MC\".includes(pc));\r\n};\r\nexport default isCurveArray;\r\n","import type { PathArray } from \"../types\";\r\nimport getPropertiesAtPoint from \"./getPropertiesAtPoint\";\r\nimport DISTANCE_EPSILON from \"./distanceEpsilon\";\r\n\r\n/**\r\n * Checks if a given point is in the stroke of a path.\r\n *\r\n * @param pathInput target path\r\n * @param point the given `{x,y}` point\r\n * @returns the query result\r\n */\r\nconst isPointInStroke = (\r\n  pathInput: string | PathArray,\r\n  point: { x: number; y: number },\r\n) => {\r\n  const { distance } = getPropertiesAtPoint(pathInput, point);\r\n  return Math.abs(distance) < DISTANCE_EPSILON; // 0.01 might be more permissive\r\n};\r\nexport default isPointInStroke;\r\n","import type { RelativeArray } from \"../types\";\r\nimport isPathArray from \"./isPathArray\";\r\n\r\n/**\r\n * Iterates an array to check if it's a `pathArray`\r\n * with relative values.\r\n *\r\n * @param path the `pathArray` to be checked\r\n * @returns iteration result\r\n */\r\nconst isRelativeArray = (path: unknown): path is RelativeArray => {\r\n  return (\r\n    isPathArray(path) &&\r\n    // `isPathArray` checks if it's `Array`\r\n    path.slice(1).every(([pc]) => pc === pc.toLowerCase())\r\n  );\r\n};\r\nexport default isRelativeArray;\r\n","import scanSegment from \"../parser/scanSegment\";\r\nimport skipSpaces from \"../parser/skipSpaces\";\r\nimport PathParser from \"../parser/pathParser\";\r\n\r\n/**\r\n * Parses a path string value to determine its validity\r\n * then returns true if it's valid or false otherwise.\r\n *\r\n * @param pathString the path string to be parsed\r\n * @returns the path string validity\r\n */\r\nconst isValidPath = (pathString: string) => {\r\n  if (typeof pathString !== \"string\" || !pathString.length) {\r\n    return false;\r\n  }\r\n\r\n  const path = new PathParser(pathString);\r\n\r\n  skipSpaces(path);\r\n\r\n  while (path.index < path.max && !path.err.length) {\r\n    scanSegment(path);\r\n  }\r\n\r\n  return !path.err.length && \"mM\".includes(path.segments[0][0]);\r\n};\r\nexport default isValidPath;\r\n","import type { ShapeParams } from \"../interface\";\r\n\r\n/**\r\n * Supported shapes and their specific parameters.\r\n */\r\nconst shapeParams: ShapeParams = {\r\n  line: [\"x1\", \"y1\", \"x2\", \"y2\"],\r\n  circle: [\"cx\", \"cy\", \"r\"],\r\n  ellipse: [\"cx\", \"cy\", \"rx\", \"ry\"],\r\n  rect: [\"width\", \"height\", \"x\", \"y\", \"rx\", \"ry\"],\r\n  polygon: [\"points\"],\r\n  polyline: [\"points\"],\r\n  glyph: [\"d\"],\r\n};\r\n\r\nexport default shapeParams;\r\n","const isElement = (node?: unknown): node is Element =>\r\n  node !== undefined && node !== null &&\r\n  typeof node === \"object\" &&\r\n  (node as Node).nodeType === 1; // ELEMENT_NODE\r\n\r\nexport default isElement;\r\n","import type {\r\n  CircleAttr,\r\n  EllipseAttr,\r\n  GlyphAttr,\r\n  LineAttr,\r\n  PolyAttr,\r\n  RectAttr,\r\n  ShapeParams,\r\n} from \"../interface\";\r\nimport type { PathArray, PathSegment, ShapeOps, ShapeTypes } from \"../types\";\r\nimport error from \"../parser/error\";\r\nimport parsePathString from \"../parser/parsePathString\";\r\nimport shapeParams from \"./shapeParams\";\r\nimport isPathArray from \"./isPathArray\";\r\nimport isElement from \"./isElement\";\r\n\r\n/**\r\n * Returns a new `pathArray` from line attributes.\r\n *\r\n * @param attr shape configuration\r\n * @returns a new line `pathArray`\r\n */\r\nexport const getLinePath = (attr: LineAttr): PathArray => {\r\n  let { x1, y1, x2, y2 } = attr;\r\n  [x1, y1, x2, y2] = [x1, y1, x2, y2].map((a) => +a);\r\n  return [\r\n    [\"M\", x1, y1],\r\n    [\"L\", x2, y2],\r\n  ];\r\n};\r\n\r\n/**\r\n * Returns a new `pathArray` like from polyline/polygon attributes.\r\n *\r\n * @param attr shape configuration\r\n * @return a new polygon/polyline `pathArray`\r\n */\r\nexport const getPolyPath = (attr: PolyAttr): PathArray => {\r\n  const pathArray = [] as PathSegment[];\r\n  const points = (attr.points || \"\")\r\n    .trim()\r\n    .split(/[\\s|,]/)\r\n    .map((a) => +a);\r\n\r\n  let index = 0;\r\n  while (index < points.length) {\r\n    pathArray.push([index ? \"L\" : \"M\", points[index], points[index + 1]]);\r\n    index += 2;\r\n  }\r\n\r\n  return (attr.type === \"polygon\"\r\n    ? [...pathArray, [\"z\"]]\r\n    : pathArray) as PathArray;\r\n};\r\n\r\n/**\r\n * Returns a new `pathArray` from circle attributes.\r\n *\r\n * @param attr shape configuration\r\n * @return a circle `pathArray`\r\n */\r\nexport const getCirclePath = (attr: CircleAttr): PathArray => {\r\n  let { cx, cy, r } = attr;\r\n  [cx, cy, r] = [cx, cy, r].map((a) => +a);\r\n\r\n  return [\r\n    [\"M\", cx - r, cy],\r\n    [\"a\", r, r, 0, 1, 0, 2 * r, 0],\r\n    [\"a\", r, r, 0, 1, 0, -2 * r, 0],\r\n  ];\r\n};\r\n\r\n/**\r\n * Returns a new `pathArray` from ellipse attributes.\r\n *\r\n * @param attr shape configuration\r\n * @return an ellipse `pathArray`\r\n */\r\nexport const getEllipsePath = (attr: EllipseAttr): PathArray => {\r\n  let { cx, cy } = attr;\r\n  let rx = attr.rx || 0;\r\n  let ry = attr.ry || rx;\r\n  [cx, cy, rx, ry] = [cx, cy, rx, ry].map((a) => +a);\r\n\r\n  return [\r\n    [\"M\", cx - rx, cy],\r\n    [\"a\", rx, ry, 0, 1, 0, 2 * rx, 0],\r\n    [\"a\", rx, ry, 0, 1, 0, -2 * rx, 0],\r\n  ];\r\n};\r\n\r\n/**\r\n * Returns a new `pathArray` like from rect attributes.\r\n *\r\n * @param attr object with properties above\r\n * @return a new `pathArray` from `<rect>` attributes\r\n */\r\nexport const getRectanglePath = (attr: RectAttr): PathArray => {\r\n  const x = +attr.x || 0;\r\n  const y = +attr.y || 0;\r\n  const w = +attr.width;\r\n  const h = +attr.height;\r\n  let rx = +(attr.rx || 0);\r\n  let ry = +(attr.ry || rx);\r\n\r\n  // Validity checks from http://www.w3.org/TR/SVG/shapes.html#RectElement:\r\n  if (rx || ry) {\r\n    // rx = !rx ? ry : rx;\r\n    // ry = !ry ? rx : ry;\r\n\r\n    /* istanbul ignore else @preserve */\r\n    if (rx * 2 > w) rx -= (rx * 2 - w) / 2;\r\n    /* istanbul ignore else @preserve */\r\n    if (ry * 2 > h) ry -= (ry * 2 - h) / 2;\r\n\r\n    return [\r\n      [\"M\", x + rx, y],\r\n      [\"h\", w - rx * 2],\r\n      [\"s\", rx, 0, rx, ry],\r\n      [\"v\", h - ry * 2],\r\n      [\"s\", 0, ry, -rx, ry],\r\n      [\"h\", -w + rx * 2],\r\n      [\"s\", -rx, 0, -rx, -ry],\r\n      [\"v\", -h + ry * 2],\r\n      [\"s\", 0, -ry, rx, -ry],\r\n    ];\r\n  }\r\n\r\n  return [[\"M\", x, y], [\"h\", w], [\"v\", h], [\"H\", x], [\"Z\"]];\r\n};\r\n\r\n/**\r\n * Returns a new `pathArray` created from attributes of a `<line>`, `<polyline>`,\r\n * `<polygon>`, `<rect>`, `<ellipse>`, `<circle>`, <path> or `<glyph>`.\r\n *\r\n * It can also work with an options object, see the type below\r\n * @see ShapeOps\r\n *\r\n * @param element target shape\r\n * @return the newly created `<path>` element\r\n */\r\nconst shapeToPathArray = (\r\n  element: ShapeTypes | ShapeOps,\r\n) => {\r\n  const supportedShapes = Object.keys(shapeParams) as (keyof ShapeParams)[];\r\n  const targetIsElement = isElement(element);\r\n  const tagName = targetIsElement ? element.tagName : null;\r\n\r\n  if (tagName && [...supportedShapes, \"path\"].every((s) => tagName !== s)) {\r\n    throw TypeError(`${error}: \"${tagName}\" is not SVGElement`);\r\n  }\r\n\r\n  const type =\r\n    (targetIsElement ? tagName : (element as ShapeOps).type) as ShapeOps[\r\n      \"type\"\r\n    ];\r\n  const shapeAttrs = shapeParams[type] as string[];\r\n  const config = { type } as Record<string, string>;\r\n\r\n  if (targetIsElement) {\r\n    shapeAttrs.forEach((p) => {\r\n      config[p] = element.getAttribute(p) as string;\r\n    });\r\n  } else {\r\n    Object.assign(config, element);\r\n  }\r\n\r\n  // set d\r\n  let pathArray = [] as unknown as PathArray;\r\n\r\n  /* istanbul ignore else */\r\n  if (type === \"circle\") {\r\n    pathArray = getCirclePath(config as unknown as CircleAttr);\r\n  } else if (type === \"ellipse\") {\r\n    pathArray = getEllipsePath(config as unknown as EllipseAttr);\r\n  } else if ([\"polyline\", \"polygon\"].includes(type)) {\r\n    pathArray = getPolyPath(config as unknown as PolyAttr);\r\n  } else if (type === \"rect\") {\r\n    pathArray = getRectanglePath(config as unknown as RectAttr);\r\n  } else if (type === \"line\") {\r\n    pathArray = getLinePath(config as unknown as LineAttr);\r\n  } else if ([\"glyph\", \"path\"].includes(type)) {\r\n    pathArray = parsePathString(\r\n      targetIsElement\r\n        ? element.getAttribute(\"d\") || /* istanbul ignore next @preserve */ \"\"\r\n        : (element as GlyphAttr).d || \"\",\r\n    );\r\n  }\r\n\r\n  // replace target element\r\n  if (isPathArray(pathArray) && pathArray.length) {\r\n    return pathArray;\r\n  }\r\n  return false;\r\n};\r\nexport default shapeToPathArray;\r\n","import type { ShapeParams } from \"../interface\";\r\nimport type { ShapeOps, ShapeTypes } from \"../types\";\r\nimport pathToString from \"../convert/pathToString\";\r\nimport defaultOptions from \"../options/options\";\r\nimport error from \"../parser/error\";\r\nimport isValidPath from \"./isValidPath\";\r\nimport isElement from \"./isElement\";\r\nimport shapeToPathArray from \"./shapeToPathArray\";\r\nimport shapeParams from \"./shapeParams\";\r\n\r\n/**\r\n * Returns a new `<path>` element created from attributes of a `<line>`, `<polyline>`,\r\n * `<polygon>`, `<rect>`, `<ellipse>`, `<circle>` or `<glyph>`. If `replace` parameter\r\n * is `true`, it will replace the target. The default `ownerDocument` is your current\r\n * `document` browser page, if you want to use in server-side using `jsdom`, you can\r\n * pass the `jsdom` `document` to `ownDocument`.\r\n *\r\n * It can also work with an options object, see the type below\r\n * @see ShapeOps\r\n *\r\n * The newly created `<path>` element keeps all non-specific\r\n * attributes like `class`, `fill`, etc.\r\n *\r\n * @param element target shape\r\n * @param replace option to replace target\r\n * @param ownerDocument document for create element\r\n * @return the newly created `<path>` element\r\n */\r\nconst shapeToPath = (\r\n  element: ShapeTypes | ShapeOps,\r\n  replace?: boolean,\r\n  ownerDocument?: Document,\r\n): SVGPathElement | false => {\r\n  const doc = ownerDocument || document;\r\n  const supportedShapes = Object.keys(shapeParams) as (keyof ShapeParams)[];\r\n  const targetIsElement = isElement(element);\r\n  const tagName = targetIsElement ? element.tagName : null;\r\n\r\n  if (tagName === \"path\") {\r\n    throw TypeError(`${error}: \"${tagName}\" is already SVGPathElement`);\r\n  }\r\n  if (tagName && supportedShapes.every((s) => tagName !== s)) {\r\n    throw TypeError(`${error}: \"${tagName}\" is not SVGElement`);\r\n  }\r\n\r\n  const path = doc.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\r\n  const type =\r\n    (targetIsElement ? tagName : (element as ShapeOps).type) as ShapeOps[\r\n      \"type\"\r\n    ];\r\n  const shapeAttrs = shapeParams[type] as string[];\r\n  const config = { type } as Record<string, string>;\r\n\r\n  // set d\r\n  const round = defaultOptions.round as number;\r\n  const pathArray = shapeToPathArray(element);\r\n  const description = pathArray && pathArray.length\r\n    ? pathToString(pathArray, round)\r\n    : \"\";\r\n\r\n  if (targetIsElement) {\r\n    shapeAttrs.forEach((p) => {\r\n      config[p] = element.getAttribute(p) as string;\r\n    });\r\n    // set no-specific shape attributes: fill, stroke, etc\r\n    Object.values(element.attributes).forEach(({ name, value }) => {\r\n      if (!shapeAttrs.includes(name)) path.setAttribute(name, value);\r\n    });\r\n  } else {\r\n    Object.assign(config, element);\r\n    // set no-specific shape attributes: fill, stroke, etc\r\n    Object.keys(config).forEach((k) => {\r\n      if (!shapeAttrs.includes(k) && k !== \"type\") {\r\n        path.setAttribute(\r\n          k.replace(/[A-Z]/g, (m) => `-${m.toLowerCase()}`),\r\n          config[k],\r\n        );\r\n      }\r\n    });\r\n  }\r\n\r\n  // replace target element\r\n  if (isValidPath(description)) {\r\n    path.setAttribute(\"d\", description);\r\n    if (replace && targetIsElement) {\r\n      element.before(path, element);\r\n      element.remove();\r\n    }\r\n    return path;\r\n  }\r\n  return false;\r\n};\r\n\r\nexport default shapeToPath;\r\n","import CSSMatrix from \"@thednp/dommatrix\";\r\n// import type { TransformObject } from '../interface';\r\nimport type { TransformObjectValues } from \"../types\";\r\n\r\n/**\r\n * Returns a transformation matrix to apply to `<path>` elements.\r\n *\r\n * @see TransformObjectValues\r\n *\r\n * @param transform the `transformObject`\r\n * @returns a new transformation matrix\r\n */\r\nconst getSVGMatrix = (transform: TransformObjectValues): CSSMatrix => {\r\n  let matrix = new CSSMatrix();\r\n  const { origin } = transform;\r\n  const [originX, originY] = origin as [number, number, number];\r\n  const { translate } = transform;\r\n  const { rotate } = transform;\r\n  const { skew } = transform;\r\n  const { scale } = transform;\r\n\r\n  // set translate\r\n  if (\r\n    Array.isArray(translate) &&\r\n    translate.length >= 2 &&\r\n    translate.every((x) => !Number.isNaN(+x)) &&\r\n    translate.some((x) => x !== 0)\r\n  ) {\r\n    matrix = matrix.translate(...(translate as [number, number, number?]));\r\n  } else if (typeof translate === \"number\" && !Number.isNaN(translate)) {\r\n    matrix = matrix.translate(translate);\r\n  }\r\n\r\n  if (rotate || skew || scale) {\r\n    // set SVG transform-origin, always defined\r\n    matrix = matrix.translate(originX, originY);\r\n\r\n    // set rotation\r\n    if (\r\n      Array.isArray(rotate) &&\r\n      rotate.length >= 2 &&\r\n      rotate.every((x) => !Number.isNaN(+x)) &&\r\n      rotate.some((x) => x !== 0)\r\n    ) {\r\n      matrix = matrix.rotate(...(rotate as [number, number, number?]));\r\n    } else if (typeof rotate === \"number\" && !Number.isNaN(rotate)) {\r\n      matrix = matrix.rotate(rotate);\r\n    }\r\n\r\n    // set skew(s)\r\n    if (\r\n      Array.isArray(skew) && skew.length === 2 && skew.every((x) =>\r\n        !Number.isNaN(+x)\r\n      ) && skew.some((x) => x !== 0)\r\n    ) {\r\n      matrix = skew[0] ? matrix.skewX(skew[0]) : matrix;\r\n      matrix = skew[1] ? matrix.skewY(skew[1]) : matrix;\r\n    } else if (typeof skew === \"number\" && !Number.isNaN(skew)) {\r\n      matrix = matrix.skewX(skew);\r\n    }\r\n\r\n    // set scale\r\n    if (\r\n      Array.isArray(scale) && scale.length >= 2 && scale.every((x) =>\r\n        !Number.isNaN(+x)\r\n      ) && scale.some((x) => x !== 1)\r\n    ) {\r\n      matrix = matrix.scale(...(scale as [number, number, number?]));\r\n    } else if (typeof scale === \"number\" && !Number.isNaN(scale)) {\r\n      matrix = matrix.scale(scale);\r\n    }\r\n    // set SVG transform-origin\r\n    matrix = matrix.translate(-originX, -originY);\r\n  }\r\n\r\n  return matrix;\r\n};\r\nexport default getSVGMatrix;\r\n","import defaultOptions from \"../options/options\";\r\nimport type { ParserParams } from \"../interface\";\r\nimport roundTo from \"../math/roundTo\";\r\nimport type {\r\n  AbsoluteSegment,\r\n  NormalSegment,\r\n  PathCommand,\r\n  ShortSegment,\r\n  SSegment,\r\n  TSegment,\r\n} from \"../types\";\r\n\r\n/**\r\n * Shorten a single segment of a `pathArray` object.\r\n *\r\n * @param segment the `absoluteSegment` object\r\n * @param normalSegment the `normalSegment` object\r\n * @param params the coordinates of the previous segment\r\n * @param prevCommand the path command of the previous segment\r\n * @returns the shortened segment\r\n */\r\nconst shortenSegment = (\r\n  segment: AbsoluteSegment,\r\n  normalSegment: NormalSegment,\r\n  params: ParserParams,\r\n  prevCommand: PathCommand,\r\n): ShortSegment => {\r\n  const [pathCommand] = segment;\r\n  const { round: defaultRound } = defaultOptions;\r\n  const round = typeof defaultRound === \"number\"\r\n    ? defaultRound\r\n    : /* istanbul ignore next */ 4;\r\n  const normalValues = normalSegment.slice(1) as number[];\r\n  const { x1, y1, x2, y2, x, y } = params;\r\n  const [nx, ny] = normalValues.slice(-2);\r\n  const result = segment;\r\n\r\n  if (!\"TQ\".includes(pathCommand)) {\r\n    // optional but good to be cautious\r\n    params.qx = null;\r\n    params.qy = null;\r\n  }\r\n\r\n  if (pathCommand === \"L\") {\r\n    if (roundTo(x, round) === roundTo(nx, round)) {\r\n      return [\"V\", ny];\r\n    } else if (roundTo(y, round) === roundTo(ny, round)) {\r\n      return [\"H\", nx];\r\n    }\r\n  } else if (pathCommand === \"C\") {\r\n    const [nx1, ny1] = normalValues;\r\n    params.x1 = nx1;\r\n    params.y1 = ny1;\r\n\r\n    if (\r\n      \"CS\".includes(prevCommand) &&\r\n      ((roundTo(nx1, round) === roundTo(x1 * 2 - x2, round) &&\r\n        roundTo(ny1, round) === roundTo(y1 * 2 - y2, round)) ||\r\n        (roundTo(x1, round) === roundTo(x2 * 2 - x, round) &&\r\n          roundTo(y1, round) === roundTo(y2 * 2 - y, round)))\r\n    ) {\r\n      return [\r\n        \"S\",\r\n        normalValues[2],\r\n        normalValues[3],\r\n        normalValues[4],\r\n        normalValues[5],\r\n      ] as SSegment;\r\n    }\r\n  } else if (pathCommand === \"Q\") {\r\n    const [qx, qy] = normalValues;\r\n    params.qx = qx;\r\n    params.qy = qy;\r\n\r\n    if (\r\n      \"QT\".includes(prevCommand) &&\r\n      roundTo(qx, round) === roundTo(x1 * 2 - x2, round) &&\r\n      roundTo(qy, round) === roundTo(y1 * 2 - y2, round)\r\n    ) {\r\n      return [\"T\", normalValues[2], normalValues[3]] as TSegment;\r\n    }\r\n  }\r\n\r\n  // ['V', 'H', 'S', 'T', 'Z'].includes(pathCommand)\r\n  return result as ShortSegment;\r\n};\r\n\r\nexport default shortenSegment;\r\n","import type { PathCommand, PathSegment } from \"../types\";\r\nimport roundTo from \"../math/roundTo\";\r\n\r\nconst roundSegment = <T extends PathSegment>(\r\n  segment: T,\r\n  roundOption: number,\r\n) => {\r\n  const values = (segment.slice(1) as number[]).map((n) =>\r\n    roundTo(n, roundOption)\r\n  );\r\n  return [segment[0] as PathCommand | number].concat(values) as T;\r\n};\r\n\r\nexport default roundSegment;\r\n","import type { AbsoluteSegment, PathArray, PathCommand } from \"../types\";\r\nimport pathToAbsolute from \"../convert/pathToAbsolute\";\r\nimport shortenSegment from \"./shortenSegment\";\r\nimport paramsParser from \"../parser/paramsParser\";\r\nimport iterate from \"./iterate\";\r\nimport normalizeSegment from \"./normalizeSegment\";\r\nimport relativizeSegment from \"./relativizeSegment\";\r\nimport roundSegment from \"./roundSegment\";\r\n\r\n/**\r\n * Optimizes a `pathArray` object:\r\n * * convert segments to shorthand if possible\r\n * * select shortest segments from absolute and relative `pathArray`s\r\n *\r\n * @param pathInput a string or `pathArray`\r\n * @param roundOption the amount of decimals to round values to\r\n * @returns the optimized `pathArray`\r\n */\r\nconst optimizePath = (pathInput: PathArray, roundOption?: number) => {\r\n  const path = pathToAbsolute(pathInput);\r\n  // allow for ZERO decimals or use an aggressive value of 2\r\n  const round = typeof roundOption === \"number\" && roundOption >= 0\r\n    ? roundOption\r\n    : /* istanbul ignore next @preserve */ 2;\r\n  // this utility overrides the iterator params\r\n  const optimParams = { ...paramsParser };\r\n\r\n  const allPathCommands = [] as PathCommand[];\r\n  let pathCommand = \"M\" as PathCommand;\r\n  let prevCommand = \"Z\" as PathCommand;\r\n\r\n  return iterate(path, (seg, i, lastX, lastY) => {\r\n    optimParams.x = lastX;\r\n    optimParams.y = lastY;\r\n    const normalizedSegment = normalizeSegment(seg, optimParams);\r\n    let result = seg;\r\n    [pathCommand] = seg;\r\n\r\n    // Save current path command\r\n    allPathCommands[i] = pathCommand;\r\n    if (i) {\r\n      // Get previous path command for `shortenSegment`\r\n      prevCommand = allPathCommands[i - 1];\r\n      const shortSegment = shortenSegment(\r\n        seg as AbsoluteSegment,\r\n        normalizedSegment,\r\n        optimParams,\r\n        prevCommand,\r\n      );\r\n      const absSegment = roundSegment(shortSegment, round);\r\n      const absString = absSegment.join(\"\");\r\n      const relativeSegment = relativizeSegment(shortSegment, i, lastX, lastY);\r\n      const relSegment = roundSegment(relativeSegment, round);\r\n      const relString = relSegment.join(\"\");\r\n      result = absString.length < relString.length ? absSegment : relSegment;\r\n    }\r\n\r\n    const seglen = normalizedSegment.length;\r\n    optimParams.x1 = +normalizedSegment[seglen - 2];\r\n    optimParams.y1 = +normalizedSegment[seglen - 1];\r\n    optimParams.x2 = +normalizedSegment[seglen - 4] || optimParams.x1;\r\n    optimParams.y2 = +normalizedSegment[seglen - 3] || optimParams.y1;\r\n\r\n    return result;\r\n  });\r\n};\r\n\r\nexport default optimizePath;\r\n","import CSSMatrix from \"@thednp/dommatrix\";\r\nimport { type PointTuple } from \"../types\";\r\n\r\n/**\r\n * Transforms a specified point using a matrix, returning a new\r\n * Tuple *Object* comprising of the transformed point.\r\n * Neither the matrix nor the original point are altered.\r\n *\r\n * @copyright thednp  2021\r\n *\r\n * @param cssm CSSMatrix instance\r\n * @param v Tuple\r\n * @return the resulting Tuple\r\n */\r\nconst translatePoint = (\r\n  cssm: CSSMatrix,\r\n  v: [number, number, number, number],\r\n): [number, number, number, number] => {\r\n  let m = CSSMatrix.Translate(v[0], v[1], v[2]);\r\n\r\n  [, , , m.m44] = v;\r\n  m = cssm.multiply(m);\r\n\r\n  return [m.m41, m.m42, m.m43, m.m44];\r\n};\r\n\r\n/**\r\n * Returns the [x,y] projected coordinates for a given an [x,y] point\r\n * and an [x,y,z] perspective origin point.\r\n *\r\n * Equation found here =>\r\n * http://en.wikipedia.org/wiki/3D_projection#Diagram\r\n * Details =>\r\n * https://stackoverflow.com/questions/23792505/predicted-rendering-of-css-3d-transformed-pixel\r\n *\r\n * @param m the transformation matrix\r\n * @param point2D the initial [x,y] coordinates\r\n * @param origin the [x,y,z] transform origin\r\n * @returns the projected [x,y] coordinates\r\n */\r\nconst projection2d = (\r\n  m: CSSMatrix,\r\n  point2D: PointTuple,\r\n  origin: [number, number, number],\r\n): PointTuple => {\r\n  const [originX, originY, originZ] = origin;\r\n  const [x, y, z] = translatePoint(m, [point2D[0], point2D[1], 0, 1]);\r\n\r\n  const relativePositionX = x - originX;\r\n  const relativePositionY = y - originY;\r\n  const relativePositionZ = z - originZ;\r\n\r\n  return [\r\n    // protect against division by ZERO\r\n    relativePositionX * (Math.abs(originZ) / Math.abs(relativePositionZ) || 1) +\r\n    originX,\r\n    relativePositionY * (Math.abs(originZ) / Math.abs(relativePositionZ) || 1) +\r\n    originY,\r\n  ];\r\n};\r\nexport default projection2d;\r\n","import type { CSegment, CurveArray, MSegment, PathCommand } from \"../types\";\r\n\r\n/**\r\n * Reverses all segments of a `pathArray`\r\n * which consists of only C (cubic-bezier) path commands.\r\n *\r\n * @param path the source `pathArray`\r\n * @returns the reversed `pathArray`\r\n */\r\nconst reverseCurve = (path: CurveArray) => {\r\n  const rotatedCurve = path\r\n    .slice(1)\r\n    .map((x, i, curveOnly) =>\r\n      !i\r\n        ? path[0].slice(1).concat(x.slice(1) as number[])\r\n        : curveOnly[i - 1].slice(-2).concat(x.slice(1))\r\n    )\r\n    .map((x) => x.map((_, i) => x[x.length - i - 2 * (1 - (i % 2))]))\r\n    .reverse() as (MSegment | CSegment)[];\r\n\r\n  return [[\"M\" as PathCommand | number].concat(rotatedCurve[0].slice(0, 2))]\r\n    .concat(\r\n      rotatedCurve.map((x) => [\"C\" as PathCommand | number].concat(x.slice(2))),\r\n    ) as CurveArray;\r\n};\r\n\r\nexport default reverseCurve;\r\n","import type {\r\n  ASegment,\r\n  CSegment,\r\n  HSegment,\r\n  MSegment,\r\n  PathArray,\r\n  PathSegment,\r\n  PointTuple,\r\n  QSegment,\r\n  SSegment,\r\n  TSegment,\r\n  VSegment,\r\n} from \"../types\";\r\nimport pathToAbsolute from \"../convert/pathToAbsolute\";\r\nimport normalizePath from \"./normalizePath\";\r\nimport iterate from \"./iterate\";\r\n\r\n/**\r\n * Reverses all segments of a `pathArray` and returns a new `pathArray` instance\r\n * with absolute values.\r\n *\r\n * @param pathInput the source `pathArray`\r\n * @returns the reversed `pathArray`\r\n */\r\nconst reversePath = (pathInput: PathArray) => {\r\n  const absolutePath = pathToAbsolute(pathInput);\r\n  const normalizedPath = normalizePath(absolutePath);\r\n  const pLen = absolutePath.length;\r\n  const isClosed = absolutePath[pLen - 1][0] === \"Z\";\r\n\r\n  const reversedPath = iterate(absolutePath, (segment, i) => {\r\n    const normalizedSegment = normalizedPath[i];\r\n    const prevSeg = i && absolutePath[i - 1];\r\n    const prevCommand = prevSeg && prevSeg[0];\r\n    const nextSeg = absolutePath[i + 1];\r\n    const nextCommand = nextSeg && nextSeg[0];\r\n    const [pathCommand] = segment;\r\n    const [x, y] = normalizedPath[i ? i - 1 : pLen - 1].slice(-2) as PointTuple;\r\n    let result = segment;\r\n\r\n    switch (pathCommand) {\r\n      case \"M\":\r\n        result = (isClosed ? [\"Z\"] : [pathCommand, x, y]) as PathSegment;\r\n        break;\r\n      case \"A\":\r\n        result = [\r\n          pathCommand,\r\n          segment[1],\r\n          segment[2],\r\n          segment[3],\r\n          segment[4],\r\n          segment[5] === 1 ? 0 : 1,\r\n          x,\r\n          y,\r\n        ] as ASegment;\r\n        break;\r\n      case \"C\":\r\n        if (nextSeg && nextCommand === \"S\") {\r\n          result = [\"S\", segment[1], segment[2], x, y] as SSegment;\r\n        } else {\r\n          result = [\r\n            pathCommand,\r\n            segment[3],\r\n            segment[4],\r\n            segment[1],\r\n            segment[2],\r\n            x,\r\n            y,\r\n          ] as CSegment;\r\n        }\r\n        break;\r\n      case \"S\":\r\n        if (\r\n          prevCommand && \"CS\".includes(prevCommand) &&\r\n          (!nextSeg || nextCommand !== \"S\")\r\n        ) {\r\n          result = [\r\n            \"C\",\r\n            normalizedSegment[3],\r\n            normalizedSegment[4],\r\n            normalizedSegment[1],\r\n            normalizedSegment[2],\r\n            x,\r\n            y,\r\n          ] as CSegment;\r\n        } else {\r\n          result = [\r\n            pathCommand,\r\n            normalizedSegment[1],\r\n            normalizedSegment[2],\r\n            x,\r\n            y,\r\n          ] as SSegment;\r\n        }\r\n        break;\r\n      case \"Q\":\r\n        if (nextSeg && nextCommand === \"T\") {\r\n          result = [\"T\", x, y] as TSegment;\r\n        } else {\r\n          result = [pathCommand, segment[1], segment[2], x, y] as QSegment;\r\n        }\r\n        break;\r\n      case \"T\":\r\n        if (\r\n          prevCommand && \"QT\".includes(prevCommand) &&\r\n          (!nextSeg || nextCommand !== \"T\")\r\n        ) {\r\n          result = [\r\n            \"Q\",\r\n            normalizedSegment[1],\r\n            normalizedSegment[2],\r\n            x,\r\n            y,\r\n          ] as QSegment;\r\n        } else {\r\n          result = [pathCommand, x, y] as TSegment;\r\n        }\r\n        break;\r\n      case \"Z\":\r\n        result = [\"M\", x, y] as MSegment;\r\n        break;\r\n      case \"H\":\r\n        result = [pathCommand, x] as HSegment;\r\n        break;\r\n      case \"V\":\r\n        result = [pathCommand, y] as VSegment;\r\n        break;\r\n      default:\r\n        result = [pathCommand as typeof pathCommand | number].concat(\r\n          segment.slice(1, -2),\r\n          x,\r\n          y,\r\n        ) as PathSegment;\r\n    }\r\n\r\n    return result;\r\n  });\r\n\r\n  return (\r\n    isClosed\r\n      ? reversedPath.reverse()\r\n      : [reversedPath[0] as PathSegment].concat(reversedPath.slice(1).reverse())\r\n  ) as PathArray;\r\n};\r\n\r\nexport default reversePath;\r\n","import type { PathArray } from \"../types\";\r\nimport defaultOptions from \"../options/options\";\r\nimport iterate from \"./iterate\";\r\nimport roundSegment from \"./roundSegment\";\r\n\r\n/**\r\n * Rounds the values of a `pathArray` instance to\r\n * a specified amount of decimals and returns it.\r\n *\r\n * @param path the source `pathArray`\r\n * @param roundOption the amount of decimals to round numbers to\r\n * @returns the resulted `pathArray` with rounded values\r\n */\r\nconst roundPath = (path: PathArray, roundOption?: number | \"off\") => {\r\n  let { round } = defaultOptions;\r\n  // allow for ZERO decimals\r\n  round = roundOption === \"off\"\r\n    ? roundOption\r\n    : typeof roundOption === \"number\" && roundOption >= 0\r\n    ? roundOption\r\n    : typeof round === \"number\" && round >= 0\r\n    ? round\r\n    : /* istanbul ignore next @preserve */ \"off\";\r\n\r\n  /* istanbul ignore else @preserve */\r\n  if (round === \"off\") return path.slice(0) as PathArray;\r\n\r\n  return iterate<typeof path>(path, (segment) => {\r\n    return roundSegment(segment, round);\r\n  });\r\n};\r\nexport default roundPath;\r\n","import midPoint from \"../math/midPoint\";\r\nimport type { CubicSegment, PointTuple } from \"../types\";\r\n\r\n/**\r\n * Split a cubic-bezier segment into two.\r\n *\r\n * @param pts the cubic-bezier parameters\r\n * @param ratio the cubic-bezier parameters\r\n * @return two new cubic-bezier segments\r\n */\r\nconst splitCubic = (\r\n  pts: number[],\r\n  ratio = 0.5,\r\n): [CubicSegment, CubicSegment] => {\r\n  const t = ratio;\r\n  const p0 = pts.slice(0, 2) as PointTuple;\r\n  const p1 = pts.slice(2, 4) as PointTuple;\r\n  const p2 = pts.slice(4, 6) as PointTuple;\r\n  const p3 = pts.slice(6, 8) as PointTuple;\r\n  const p4 = midPoint(p0, p1, t);\r\n  const p5 = midPoint(p1, p2, t);\r\n  const p6 = midPoint(p2, p3, t);\r\n  const p7 = midPoint(p4, p5, t);\r\n  const p8 = midPoint(p5, p6, t);\r\n  const p9 = midPoint(p7, p8, t);\r\n\r\n  return [\r\n    [\"C\", p4[0], p4[1], p7[0], p7[1], p9[0], p9[1]],\r\n    [\"C\", p8[0], p8[1], p6[0], p6[1], p3[0], p3[1]],\r\n  ];\r\n};\r\nexport default splitCubic;\r\n","import paramsParser from \"../parser/paramsParser\";\r\nimport type {\r\n  AbsoluteCommand,\r\n  HSegment,\r\n  MSegment,\r\n  PathArray,\r\n  PointTuple,\r\n  RelativeCommand,\r\n  VSegment,\r\n} from \"../types\";\r\n\r\n/**\r\n * Split a path into an `Array` of sub-path strings.\r\n *\r\n * In the process, values are converted to absolute\r\n * for visual consistency.\r\n *\r\n * @param pathInput the source `pathArray`\r\n * @return an array with all sub-path strings\r\n */\r\nconst splitPath = (pathInput: PathArray): PathArray[] => {\r\n  const composite = [] as PathArray[];\r\n  let path: PathArray;\r\n  let pi = -1;\r\n  let x = 0;\r\n  let y = 0;\r\n  let mx = 0;\r\n  let my = 0;\r\n  const params = { ...paramsParser };\r\n\r\n  pathInput.forEach((seg) => {\r\n    const [pathCommand] = seg;\r\n    const absCommand = pathCommand.toUpperCase() as AbsoluteCommand;\r\n    const relCommand = pathCommand.toLowerCase() as RelativeCommand;\r\n    const isRelative = pathCommand === relCommand;\r\n    const values = seg.slice(1) as number[];\r\n\r\n    if (absCommand === \"M\") {\r\n      pi += 1;\r\n      [x, y] = values as PointTuple;\r\n      x += isRelative ? params.x : 0;\r\n      y += isRelative ? params.y : 0;\r\n      mx = x;\r\n      my = y;\r\n      path = [(isRelative ? [absCommand, mx, my] : seg) as MSegment];\r\n    } else {\r\n      if (absCommand === \"Z\") {\r\n        x = mx;\r\n        y = my;\r\n      } else if (absCommand === \"H\") {\r\n        [, x] = seg as HSegment;\r\n        x += isRelative ? params.x : /* istanbul ignore next @preserve */ 0;\r\n      } else if (absCommand === \"V\") {\r\n        [, y] = seg as VSegment;\r\n        y += isRelative ? params.y : /* istanbul ignore next @preserve */ 0;\r\n      } else {\r\n        [x, y] = seg.slice(-2) as PointTuple;\r\n        x += isRelative ? params.x : 0;\r\n        y += isRelative ? params.y : 0;\r\n      }\r\n      path.push(seg);\r\n    }\r\n\r\n    params.x = x;\r\n    params.y = y;\r\n    composite[pi] = path;\r\n  });\r\n\r\n  return composite;\r\n};\r\nexport default splitPath;\r\n","import getSVGMatrix from \"./getSVGMatrix\";\r\nimport projection2d from \"./projection2d\";\r\nimport defaultOptions from \"../options/options\";\r\nimport type {\r\n  AbsoluteArray,\r\n  AbsoluteSegment,\r\n  CSegment,\r\n  LSegment,\r\n  PathArray,\r\n  TransformObjectValues,\r\n} from \"../types\";\r\nimport type { TransformObject } from \"../interface\";\r\nimport iterate from \"./iterate\";\r\nimport parsePathString from \"../parser/parsePathString\";\r\nimport absolutizeSegment from \"./absolutizeSegment\";\r\nimport arcToCubic from \"./arcToCubic\";\r\n\r\n/**\r\n * Apply a 2D / 3D transformation to a `pathArray` instance.\r\n *\r\n * Since *SVGElement* doesn't support 3D transformation, this function\r\n * creates a 2D projection of the <path> element.\r\n *\r\n * @param path the `pathArray` to apply transformation\r\n * @param transform the transform functions `Object`\r\n * @returns the resulted `pathArray`\r\n */\r\nconst transformPath = (\r\n  pathInput: PathArray | string,\r\n  transform?: Partial<TransformObject>,\r\n) => {\r\n  // last x and y transformed values\r\n  let x = 0;\r\n  let y = 0;\r\n  // new x and y transformed\r\n  let lx = 0;\r\n  let ly = 0;\r\n  // segment params iteration index and length\r\n  let j = 0;\r\n  let jj = 0;\r\n  let pathCommand = \"M\";\r\n  // transform uses it's own set of params\r\n  const path = parsePathString(pathInput);\r\n  const transformProps = transform && Object.keys(transform);\r\n\r\n  // when used as a static method, invalidate somehow\r\n  if (!transform || (transformProps && !transformProps.length)) {\r\n    return path.slice(0) as typeof path;\r\n  }\r\n\r\n  // transform origin is extremely important\r\n  if (!transform.origin) {\r\n    Object.assign(transform, { origin: defaultOptions.origin });\r\n  }\r\n  const origin = transform.origin as [number, number, number];\r\n  const matrixInstance = getSVGMatrix(transform as TransformObjectValues);\r\n\r\n  if (matrixInstance.isIdentity) return path.slice(0) as typeof path;\r\n\r\n  return iterate<AbsoluteArray>(path, (seg, index, lastX, lastY) => {\r\n    [pathCommand] = seg;\r\n    const absCommand = pathCommand.toUpperCase();\r\n    const isRelative = absCommand !== pathCommand;\r\n    const absoluteSegment = isRelative\r\n      ? absolutizeSegment(seg, index, lastX, lastY)\r\n      : (seg.slice(0) as AbsoluteSegment);\r\n\r\n    let result = absCommand === \"A\"\r\n      // ? segmentToCubic(absoluteSegment, transformParams)\r\n      ? ([\"C\" as string | number].concat(\r\n        arcToCubic(\r\n          lastX,\r\n          lastY,\r\n          absoluteSegment[1] as number,\r\n          absoluteSegment[2] as number,\r\n          absoluteSegment[3] as number,\r\n          absoluteSegment[4] as number,\r\n          absoluteSegment[5] as number,\r\n          absoluteSegment[6] as number,\r\n          absoluteSegment[7] as number,\r\n        ),\r\n      ) as CSegment)\r\n      : absCommand === \"V\"\r\n      ? ([\"L\", lastX, absoluteSegment[1]] as LSegment)\r\n      : absCommand === \"H\"\r\n      ? ([\"L\", absoluteSegment[1], lastY] as LSegment)\r\n      : absoluteSegment;\r\n\r\n    // update pathCommand\r\n    pathCommand = result[0];\r\n    const isLongArc = pathCommand === \"C\" && result.length > 7;\r\n    const tempSegment =\r\n      (isLongArc ? result.slice(0, 7) : result.slice(0)) as AbsoluteSegment;\r\n\r\n    if (isLongArc) {\r\n      path.splice(\r\n        index + 1,\r\n        0,\r\n        [\"C\" as typeof pathCommand | number].concat(\r\n          result.slice(7),\r\n        ) as CSegment,\r\n      );\r\n      result = tempSegment as CSegment;\r\n    }\r\n\r\n    if (pathCommand === \"L\") {\r\n      [lx, ly] = projection2d(matrixInstance, [\r\n        (result as LSegment)[1],\r\n        (result as LSegment)[2],\r\n      ], origin);\r\n\r\n      /* istanbul ignore else @preserve */\r\n      if (x !== lx && y !== ly) {\r\n        result = [\"L\", lx, ly];\r\n      } else if (y === ly) {\r\n        result = [\"H\", lx];\r\n      } else if (x === lx) {\r\n        result = [\"V\", ly];\r\n      }\r\n    } else {\r\n      for (j = 1, jj = result.length; j < jj; j += 2) {\r\n        [lx, ly] = projection2d(\r\n          matrixInstance,\r\n          [+result[j], +result[j + 1]],\r\n          origin,\r\n        );\r\n        result[j] = lx;\r\n        result[j + 1] = ly;\r\n      }\r\n    }\r\n    // now update x and y\r\n    x = lx;\r\n    y = ly;\r\n\r\n    return result;\r\n  });\r\n};\r\n\r\nexport default transformPath;\r\n","\"use strict\";\r\nimport CSSMatrix from \"@thednp/dommatrix\";\r\nimport { PathArray, PointTuple, TransformObjectValues } from \"./types\";\r\nimport type { Options, TransformEntries, TransformObject } from \"./interface\";\r\nexport * from \"./types\";\r\nexport * from \"./interface\";\r\nimport defaultOptions from \"./options/options\";\r\n\r\nimport pathToAbsolute from \"./convert/pathToAbsolute\";\r\nimport pathToRelative from \"./convert/pathToRelative\";\r\nimport pathToCurve from \"./convert/pathToCurve\";\r\nimport pathToString from \"./convert/pathToString\";\r\nimport * as arcTools from \"./math/arcTools\";\r\nimport {\r\n  bezierLength,\r\n  calculateBezier,\r\n  CBEZIER_MINMAX_EPSILON,\r\n  computeBezier,\r\n  Cvalues,\r\n  deriveBezier,\r\n  getBezierLength,\r\n  minmaxC,\r\n  minmaxQ,\r\n  Tvalues,\r\n} from \"./math/bezier\";\r\nimport {\r\n  getCubicBBox,\r\n  getCubicLength,\r\n  getPointAtCubicLength,\r\n  getPointAtCubicSegmentLength,\r\n} from \"./math/cubicTools\";\r\nimport {\r\n  getLineBBox,\r\n  getLineLength,\r\n  getPointAtLineLength,\r\n} from \"./math/lineTools\";\r\nimport {\r\n  getPointAtQuadLength,\r\n  getPointAtQuadSegmentLength,\r\n  getQuadBBox,\r\n  getQuadLength,\r\n} from \"./math/quadTools\";\r\nimport { polygonArea, polygonLength } from \"./math/polygonTools\";\r\n\r\nimport distanceSquareRoot from \"./math/distanceSquareRoot\";\r\nimport midPoint from \"./math/midPoint\";\r\nimport rotateVector from \"./math/rotateVector\";\r\nimport roundTo from \"./math/roundTo\";\r\n\r\nimport error from \"./parser/error\";\r\nimport parsePathString from \"./parser/parsePathString\";\r\nimport finalizeSegment from \"./parser/finalizeSegment\";\r\nimport invalidPathValue from \"./parser/invalidPathValue\";\r\nimport isArcCommand from \"./parser/isArcCommand\";\r\nimport isDigit from \"./parser/isDigit\";\r\nimport isDigitStart from \"./parser/isDigitStart\";\r\nimport isMoveCommand from \"./parser/isMoveCommand\";\r\nimport isPathCommand from \"./parser/isPathCommand\";\r\nimport isSpace from \"./parser/isSpace\";\r\nimport paramsCount from \"./parser/paramsCount\";\r\nimport paramsParser from \"./parser/paramsParser\";\r\nimport pathParser from \"./parser/pathParser\";\r\nimport scanFlag from \"./parser/scanFlag\";\r\nimport scanParam from \"./parser/scanParam\";\r\nimport scanSegment from \"./parser/scanSegment\";\r\nimport skipSpaces from \"./parser/skipSpaces\";\r\n\r\nimport distanceEpsilon from \"./util/distanceEpsilon\";\r\nimport getClosestPoint from \"./util/getClosestPoint\";\r\nimport getDrawDirection from \"./util/getDrawDirection\";\r\nimport getPathArea from \"./util/getPathArea\";\r\nimport getPathBBox from \"./util/getPathBBox\";\r\nimport getPointAtLength from \"./util/getPointAtLength\";\r\nimport getPropertiesAtLength from \"./util/getPropertiesAtLength\";\r\nimport getPropertiesAtPoint from \"./util/getPropertiesAtPoint\";\r\nimport getSegmentAtLength from \"./util/getSegmentAtLength\";\r\nimport getSegmentOfPoint from \"./util/getSegmentOfPoint\";\r\nimport getTotalLength from \"./util/getTotalLength\";\r\n\r\nimport isAbsoluteArray from \"./util/isAbsoluteArray\";\r\nimport isCurveArray from \"./util/isCurveArray\";\r\nimport isNormalizedArray from \"./util/isNormalizedArray\";\r\nimport isPathArray from \"./util/isPathArray\";\r\nimport isPointInStroke from \"./util/isPointInStroke\";\r\nimport isRelativeArray from \"./util/isRelativeArray\";\r\nimport isValidPath from \"./util/isValidPath\";\r\nimport shapeParams from \"./util/shapeParams\";\r\nimport shapeToPath from \"./util/shapeToPath\";\r\nimport shapeToPathArray from \"./util/shapeToPathArray\";\r\n\r\nimport absolutizeSegment from \"./process/absolutizeSegment\";\r\nimport arcToCubic from \"./process/arcToCubic\";\r\nimport getSVGMatrix from \"./process/getSVGMatrix\";\r\nimport iterate from \"./process/iterate\";\r\nimport lineToCubic from \"./process/lineToCubic\";\r\nimport normalizePath from \"./process/normalizePath\";\r\nimport normalizeSegment from \"./process/normalizeSegment\";\r\nimport optimizePath from \"./process/optimizePath\";\r\nimport projection2d from \"./process/projection2d\";\r\nimport quadToCubic from \"./process/quadToCubic\";\r\nimport relativizeSegment from \"./process/relativizeSegment\";\r\nimport reverseCurve from \"./process/reverseCurve\";\r\nimport reversePath from \"./process/reversePath\";\r\nimport roundPath from \"./process/roundPath\";\r\nimport roundSegment from \"./process/roundSegment\";\r\nimport segmentToCubic from \"./process/segmentToCubic\";\r\nimport shortenSegment from \"./process/shortenSegment\";\r\nimport splitCubic from \"./process/splitCubic\";\r\nimport splitPath from \"./process/splitPath\";\r\nimport transformPath from \"./process/transformPath\";\r\n\r\n/**\r\n * Creates a new SVGPathCommander instance with the following properties:\r\n * * segments: `pathArray`\r\n * * round: number\r\n * * origin: [number, number, number?]\r\n *\r\n * @class\r\n * @author thednp <https://github.com/thednp/svg-path-commander>\r\n * @returns a new SVGPathCommander instance\r\n */\r\nclass SVGPathCommander {\r\n  public static CSSMatrix = CSSMatrix;\r\n  public static pathToAbsolute = pathToAbsolute;\r\n  public static pathToRelative = pathToRelative;\r\n  public static pathToCurve = pathToCurve;\r\n  public static pathToString = pathToString;\r\n  public static arcTools = arcTools;\r\n  public static bezierTools = {\r\n    Cvalues,\r\n    Tvalues,\r\n    minmaxC,\r\n    minmaxQ,\r\n    getBezierLength,\r\n    bezierLength,\r\n    calculateBezier,\r\n    computeBezier,\r\n    deriveBezier,\r\n    CBEZIER_MINMAX_EPSILON,\r\n  };\r\n  public static cubicTools = {\r\n    getCubicLength,\r\n    getCubicBBox,\r\n    getPointAtCubicLength,\r\n    getPointAtCubicSegmentLength,\r\n  };\r\n  public static lineTools = {\r\n    getPointAtLineLength,\r\n    getLineBBox,\r\n    getLineLength,\r\n  };\r\n  public static quadTools = {\r\n    getPointAtQuadSegmentLength,\r\n    getQuadLength,\r\n    getQuadBBox,\r\n    getPointAtQuadLength,\r\n  };\r\n  public static polygonTools = { polygonArea, polygonLength };\r\n  public static distanceSquareRoot = distanceSquareRoot;\r\n  public static distanceEpsilon = distanceEpsilon;\r\n  public static midPoint = midPoint;\r\n  public static rotateVector = rotateVector;\r\n  public static roundTo = roundTo;\r\n  public static finalizeSegment = finalizeSegment;\r\n  public static invalidPathValue = invalidPathValue;\r\n  public static isArcCommand = isArcCommand;\r\n  public static isDigit = isDigit;\r\n  public static isDigitStart = isDigitStart;\r\n  public static isMoveCommand = isMoveCommand;\r\n  public static isPathCommand = isPathCommand;\r\n  public static isSpace = isSpace;\r\n  public static paramsCount = paramsCount;\r\n  public static paramsParser = paramsParser;\r\n  public static pathParser = pathParser;\r\n  public static scanFlag = scanFlag;\r\n  public static scanParam = scanParam;\r\n  public static scanSegment = scanSegment;\r\n  public static skipSpaces = skipSpaces;\r\n  public static getPathBBox = getPathBBox;\r\n  public static getPathArea = getPathArea;\r\n  public static getTotalLength = getTotalLength;\r\n  public static getDrawDirection = getDrawDirection;\r\n  public static getPointAtLength = getPointAtLength;\r\n  public static getPropertiesAtLength = getPropertiesAtLength;\r\n  public static getPropertiesAtPoint = getPropertiesAtPoint;\r\n  public static getClosestPoint = getClosestPoint;\r\n  public static getSegmentOfPoint = getSegmentOfPoint;\r\n  public static getSegmentAtLength = getSegmentAtLength;\r\n  public static isPointInStroke = isPointInStroke;\r\n  public static isValidPath = isValidPath;\r\n  public static isPathArray = isPathArray;\r\n  public static isAbsoluteArray = isAbsoluteArray;\r\n  public static isRelativeArray = isRelativeArray;\r\n  public static isCurveArray = isCurveArray;\r\n  public static isNormalizedArray = isNormalizedArray;\r\n  public static shapeToPath = shapeToPath;\r\n  public static shapeToPathArray = shapeToPathArray;\r\n  public static shapeParams = shapeParams;\r\n  public static parsePathString = parsePathString;\r\n  public static absolutizeSegment = absolutizeSegment;\r\n  public static arcToCubic = arcToCubic;\r\n  public static getSVGMatrix = getSVGMatrix;\r\n  public static iterate = iterate;\r\n  public static lineToCubic = lineToCubic;\r\n  public static normalizePath = normalizePath;\r\n  public static normalizeSegment = normalizeSegment;\r\n  public static optimizePath = optimizePath;\r\n  public static projection2d = projection2d;\r\n  public static quadToCubic = quadToCubic;\r\n  public static relativizeSegment = relativizeSegment;\r\n  public static reverseCurve = reverseCurve;\r\n  public static reversePath = reversePath;\r\n  public static roundPath = roundPath;\r\n  public static roundSegment = roundSegment;\r\n  public static segmentToCubic = segmentToCubic;\r\n  public static shortenSegment = shortenSegment;\r\n  public static splitCubic = splitCubic;\r\n  public static splitPath = splitPath;\r\n  public static transformPath = transformPath;\r\n  // declare class properties\r\n  declare segments: PathArray;\r\n  declare round: number | \"off\";\r\n  declare origin: [number, number, number];\r\n\r\n  /**\r\n   * @constructor\r\n   * @param pathValue the path string\r\n   * @param config instance options\r\n   */\r\n  constructor(pathValue: string, config?: Partial<Options>) {\r\n    const instanceOptions = config || {};\r\n    const undefPath = typeof pathValue === \"undefined\";\r\n\r\n    if (undefPath || !pathValue.length) {\r\n      throw TypeError(\r\n        `${error}: \"pathValue\" is ${undefPath ? \"undefined\" : \"empty\"}`,\r\n      );\r\n    }\r\n\r\n    this.segments = parsePathString(pathValue);\r\n\r\n    // // set instance options.round\r\n    const { round: roundOption, origin: originOption } = instanceOptions;\r\n    let round: number | \"off\";\r\n\r\n    if (Number.isInteger(roundOption) || roundOption === \"off\") {\r\n      round = roundOption as number | \"off\";\r\n    } else {\r\n      round = defaultOptions.round as number;\r\n    }\r\n\r\n    // set instance options.origin\r\n    // the SVGPathCommander class will always override the default origin\r\n    let origin = defaultOptions.origin as [number, number, number];\r\n    /* istanbul ignore else @preserve */\r\n    if (Array.isArray(originOption) && originOption.length >= 2) {\r\n      const [originX, originY, originZ] = originOption.map(Number);\r\n      origin = [\r\n        !Number.isNaN(originX) ? originX : 0,\r\n        !Number.isNaN(originY) ? originY : 0,\r\n        !Number.isNaN(originZ) ? originZ : 0,\r\n      ];\r\n    }\r\n\r\n    this.round = round;\r\n    this.origin = origin;\r\n\r\n    return this;\r\n  }\r\n  get bbox() {\r\n    return getPathBBox(this.segments);\r\n  }\r\n  get length() {\r\n    return getTotalLength(this.segments);\r\n  }\r\n\r\n  /**\r\n   * Returns the path bounding box, equivalent to native `path.getBBox()`.\r\n   *\r\n   * @public\r\n   * @returns the pathBBox\r\n   */\r\n  getBBox() {\r\n    return this.bbox;\r\n  }\r\n\r\n  /**\r\n   * Returns the total path length, equivalent to native `path.getTotalLength()`.\r\n   *\r\n   * @public\r\n   * @returns the path total length\r\n   */\r\n  getTotalLength() {\r\n    return this.length;\r\n  }\r\n\r\n  /**\r\n   * Returns an `{x,y}` point in the path stroke at a given length,\r\n   * equivalent to the native `path.getPointAtLength()`.\r\n   *\r\n   * @public\r\n   * @param length the length\r\n   * @returns the requested point\r\n   */\r\n  getPointAtLength(length: number) {\r\n    return getPointAtLength(this.segments, length);\r\n  }\r\n\r\n  /**\r\n   * Convert path to absolute values\r\n   *\r\n   * @public\r\n   */\r\n  toAbsolute() {\r\n    const { segments } = this;\r\n    this.segments = pathToAbsolute(segments);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Convert path to relative values\r\n   *\r\n   * @public\r\n   */\r\n  toRelative() {\r\n    const { segments } = this;\r\n    this.segments = pathToRelative(segments);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Convert path to cubic-bezier values. In addition, un-necessary `Z`\r\n   * segment is removed if previous segment extends to the `M` segment.\r\n   *\r\n   * @public\r\n   */\r\n  toCurve() {\r\n    const { segments } = this;\r\n    this.segments = pathToCurve(segments);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Reverse the order of the segments and their values.\r\n   *\r\n   * @param onlySubpath option to reverse all sub-paths except first\r\n   * @public\r\n   */\r\n  reverse(onlySubpath?: boolean) {\r\n    const { segments } = this;\r\n    const split = splitPath(segments);\r\n    const subPath = split.length > 1 ? split : false;\r\n\r\n    const absoluteMultiPath = subPath\r\n      ? subPath.map((x, i) => {\r\n        if (onlySubpath) {\r\n          return i ? reversePath(x) : x.slice(0);\r\n        }\r\n        return reversePath(x);\r\n      })\r\n      : segments.slice(0);\r\n\r\n    let path = [] as unknown as PathArray;\r\n    if (subPath) {\r\n      path = absoluteMultiPath.flat(1) as PathArray;\r\n    } else {\r\n      path = onlySubpath ? segments : reversePath(segments);\r\n    }\r\n\r\n    this.segments = path.slice(0) as PathArray;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Normalize path in 2 steps:\r\n   * * convert `pathArray`(s) to absolute values\r\n   * * convert shorthand notation to standard notation\r\n   *\r\n   * @public\r\n   */\r\n  normalize() {\r\n    const { segments } = this;\r\n    this.segments = normalizePath(segments);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Optimize `pathArray` values:\r\n   * * convert segments to absolute and/or relative values\r\n   * * select segments with shortest resulted string\r\n   * * round values to the specified `decimals` option value\r\n   *\r\n   * @public\r\n   */\r\n  optimize() {\r\n    const { segments } = this;\r\n    const round = this.round === \"off\" ? 2 : this.round;\r\n\r\n    this.segments = optimizePath(segments, round);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Transform path using values from an `Object` defined as `transformObject`.\r\n   *\r\n   * @see TransformObject for a quick refference\r\n   *\r\n   * @param source a `transformObject`as described above\r\n   * @public\r\n   */\r\n  transform(source?: Partial<TransformObject>) {\r\n    if (\r\n      !source ||\r\n      typeof source !== \"object\" ||\r\n      (typeof source === \"object\" &&\r\n        ![\"translate\", \"rotate\", \"skew\", \"scale\"].some((x) => x in source))\r\n    ) {\r\n      return this;\r\n    }\r\n\r\n    const {\r\n      segments,\r\n      origin: [cx, cy, cz],\r\n    } = this;\r\n    const transform = {} as TransformObjectValues;\r\n    for (const [k, v] of Object.entries(source) as TransformEntries) {\r\n      // istanbul ignore else @preserve\r\n      if (k === \"skew\" && Array.isArray(v)) {\r\n        transform[k] = v.map(Number) as PointTuple;\r\n      } else if (\r\n        (k === \"rotate\" || k === \"translate\" || k === \"origin\" ||\r\n          k === \"scale\") && Array.isArray(v)\r\n      ) {\r\n        transform[k] = v.map(Number) as [number, number, number];\r\n      } else if (k !== \"origin\" && typeof Number(v) === \"number\") {\r\n        transform[k] = Number(v);\r\n      }\r\n    }\r\n\r\n    // if origin is not specified\r\n    // it's important that we have one\r\n    const { origin } = transform;\r\n\r\n    if (Array.isArray(origin) && origin.length >= 2) {\r\n      const [originX, originY, originZ] = origin.map(Number);\r\n      transform.origin = [\r\n        !Number.isNaN(originX) ? originX : cx,\r\n        !Number.isNaN(originY) ? originY : cy,\r\n        originZ || cz,\r\n      ];\r\n    } else {\r\n      transform.origin = [cx, cy, cz];\r\n    }\r\n\r\n    this.segments = transformPath(segments, transform);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Rotate path 180deg vertically\r\n   *\r\n   * @public\r\n   */\r\n  flipX() {\r\n    const { cx, cy } = this.bbox;\r\n    this.transform({ rotate: [0, 180, 0], origin: [cx, cy, 0] });\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Rotate path 180deg horizontally\r\n   *\r\n   * @public\r\n   */\r\n  flipY() {\r\n    const { cx, cy } = this.bbox;\r\n    this.transform({ rotate: [180, 0, 0], origin: [cx, cy, 0] });\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Export the current path to be used\r\n   * for the `d` (description) attribute.\r\n   *\r\n   * @public\r\n   * @return the path string\r\n   */\r\n  toString() {\r\n    return pathToString(this.segments, this.round);\r\n  }\r\n\r\n  /**\r\n   * Remove the instance.\r\n   *\r\n   * @public\r\n   * @return void\r\n   */\r\n  dispose() {\r\n    Object.keys(this).forEach((key) => delete this[key as keyof typeof this]);\r\n  }\r\n}\r\n\r\nexport default SVGPathCommander;\r\n"],"names":["Z","z","s","e","p","$","E","P","y","g","n","i","r","a","m","h","c","u","f","w","o","d","b","X","O","x","Y","F","T","k","I","v","R","D","N","defaultOptions","paramsCount","finalizeSegment","path","pathCommand","relativeCommand","data","error","scanFlag","index","pathValue","code","isDigit","invalidPathValue","scanParam","max","start","zeroFirst","hasCeiling","hasDecimal","hasDot","ch","isSpace","skipSpaces","isPathCommand","isDigitStart","isArcCommand","isMoveCommand","scanSegment","_a","segments","cmdCode","reqParams","paramCounts","lastSegment","PathParser","pathString","parsePathString","pathInput","absolutizeSegment","segment","lastX","lastY","absCommand","absValues","seglen","j","iterate","iterator","pathLen","isRelative","mx","my","segLen","iteratorResult","pathToAbsolute","relativizeSegment","relCommand","relValues","pathToRelative","rotateVector","rad","sin","cos","arcToCubic","X1","Y1","RX","RY","angle","LAF","SF","X2","Y2","recursive","x1","y1","rx","ry","x2","y2","d120","res","xy","f1","f2","cx","cy","rx2","ry2","df","f2old","x2old","y2old","c1","s1","c2","s2","t","hx","hy","m1","m2","m3","m4","newres","ii","quadToCubic","qx","qy","r13","r23","midPoint","ax","ay","bx","by","lineToCubic","segmentToCubic","params","values","px1","py1","px","py","normalizeSegment","px2","py2","nqx","nqy","paramsParser","pathToCurve","seg","normalSegment","result","roundTo","round","pow","pathToString","roundOption","valLen","distanceSquareRoot","getLineLength","getPointAtLineLength","distance","point","length","getLineBBox","min","arcLength","theta","halfTheta","sinHalfTheta","cosHalfTheta","term1","term2","arcPoint","alpha","cosA","sinA","angleBetween","v0","v1","v0x","v0y","v1x","v1y","getArcProps","abs","sqrt","PI","xRotRad","dx","dy","transformedPoint","radiiCheck","cSquareNumerator","cSquareRootDenom","cRadicand","cCoef","transformedCenter","center","startVector","startAngle","endVector","sweepAngle","endAngle","getArcLength","getPointAtArcLength","ellipseComponentX","ellipseComponentY","getArcBBox","deltaAngle","tan","atan2","tangent","angle1","angle2","angle3","angle4","xArray","yArray","xMin","xMax","yMin","yMax","angleAfterStart","pP2","angleBeforeEnd","pP3","p1","p2","p4","p3","Tvalues","Cvalues","deriveBezier","points","dpoints","list","computeBezier","order","mt","mt2","t2","calculateBezier","derivativeFn","l","bezierLength","len","sum","getBezierLength","curve","idx","step","CBEZIER_MINMAX_EPSILON","minmaxQ","cp","v2","minmaxC","cp1","cp2","K","S","L","Q","getPointAtCubicSegmentLength","c1x","c1y","c2x","c2y","t1","getCubicLength","getPointAtCubicLength","distanceIsNumber","currentLength","getCubicBBox","cxMinMax","cyMinMax","getPointAtQuadSegmentLength","getQuadLength","getPointAtQuadLength","getQuadBBox","polygonArea","polygon","area","polygonLength","DISTANCE_EPSILON","normalizePath","_","getPointAtLength","isM","POINT","totalLength","getTotalLength","paramX1","paramY1","paramX2","paramY2","paramQX","paramQY","absoluteSegment","cp1x","cp1y","getPropertiesAtLength","pathArray","pathTemp","pathLength","lengthAtSegment","getPropertiesAtPoint","normalPath","distanceTo","precision","scan","closest","scanDistance","bestLength","bestDistance","scanLength","before","after","beforeLength","afterLength","beforeDistance","afterDistance","getClosestPoint","getCubicSegArea","getPathArea","getDrawDirection","getPathBBox","minX","minY","maxX","maxY","width","height","getSegmentAtLength","getSegmentOfPoint","isPathArray","lk","isAbsoluteArray","isNormalizedArray","pc","isCurveArray","isPointInStroke","isRelativeArray","isValidPath","shapeParams","isElement","node","getLinePath","attr","getPolyPath","getCirclePath","getEllipsePath","getRectanglePath","shapeToPathArray","element","supportedShapes","targetIsElement","tagName","type","shapeAttrs","config","shapeToPath","replace","ownerDocument","doc","description","name","value","getSVGMatrix","transform","matrix","CSSMatrix","origin","originX","originY","translate","rotate","skew","scale","shortenSegment","prevCommand","defaultRound","normalValues","nx","ny","nx1","ny1","roundSegment","optimizePath","optimParams","allPathCommands","normalizedSegment","shortSegment","absSegment","absString","relativeSegment","relSegment","relString","translatePoint","cssm","projection2d","point2D","originZ","relativePositionX","relativePositionY","relativePositionZ","reverseCurve","rotatedCurve","curveOnly","reversePath","absolutePath","normalizedPath","pLen","isClosed","reversedPath","prevSeg","nextSeg","nextCommand","roundPath","splitCubic","pts","ratio","p0","p5","p6","p7","p8","p9","splitPath","composite","pi","transformPath","lx","ly","jj","transformProps","matrixInstance","isLongArc","tempSegment","SVGPathCommander","instanceOptions","undefPath","originOption","onlySubpath","split","subPath","absoluteMultiPath","source","cz","key","__publicField","arcTools","distanceEpsilon","pathParser"],"mappings":"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","x_google_ignoreList":[0]}