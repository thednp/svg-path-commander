{"version":3,"file":"svg-path-commander.mjs","sources":["../src/options/options.ts","../src/parser/error.ts","../src/parser/paramsCount.ts","../src/parser/finalizeSegment.ts","../src/parser/scanFlag.ts","../src/parser/isDigit.ts","../src/parser/invalidPathValue.ts","../src/parser/scanParam.ts","../src/parser/isSpace.ts","../src/parser/skipSpaces.ts","../src/parser/isPathCommand.ts","../src/parser/isDigitStart.ts","../src/parser/isArcCommand.ts","../src/parser/isMoveCommand.ts","../src/parser/scanSegment.ts","../src/parser/pathParser.ts","../src/parser/parsePathString.ts","../src/math/polygonArea.ts","../src/math/distanceSquareRoot.ts","../src/math/polygonLength.ts","../node_modules/.pnpm/@thednp+dommatrix@2.0.8/node_modules/@thednp/dommatrix/dist/dommatrix.mjs","../src/parser/paramsParser.ts","../src/process/iterate.ts","../src/process/absolutizeSegment.ts","../src/process/normalizeSegment.ts","../src/math/midPoint.ts","../src/math/lineTools.ts","../src/math/arcTools.ts","../src/math/bezier.ts","../src/math/cubicTools.ts","../src/math/quadTools.ts","../src/util/getPathBBox.ts","../src/math/rotateVector.ts","../src/process/arcToCubic.ts","../src/process/quadToCubic.ts","../src/process/lineToCubic.ts","../src/process/segmentToCubic.ts","../src/convert/pathToCurve.ts","../src/util/getPathArea.ts","../src/util/getTotalLength.ts","../src/util/getDrawDirection.ts","../src/util/distanceEpsilon.ts","../src/util/getPointAtLength.ts","../src/util/getPropertiesAtLength.ts","../src/process/normalizePath.ts","../src/util/getPropertiesAtPoint.ts","../src/util/getClosestPoint.ts","../src/util/getSegmentOfPoint.ts","../src/util/getSegmentAtLength.ts","../src/util/isPointInStroke.ts","../src/util/isValidPath.ts","../src/util/isPathArray.ts","../src/util/isAbsoluteArray.ts","../src/util/isRelativeArray.ts","../src/util/isNormalizedArray.ts","../src/util/isCurveArray.ts","../src/util/shapeParams.ts","../src/util/shapeToPathArray.ts","../src/process/roundPath.ts","../src/convert/pathToString.ts","../src/util/shapeToPath.ts","../src/process/splitPath.ts","../src/process/getSVGMatrix.ts","../src/convert/pathToAbsolute.ts","../src/process/relativizeSegment.ts","../src/convert/pathToRelative.ts","../src/process/shortenSegment.ts","../src/process/optimizePath.ts","../src/process/reverseCurve.ts","../src/process/reversePath.ts","../src/process/projection2d.ts","../src/process/transformPath.ts","../src/process/splitCubic.ts","../src/index.ts"],"sourcesContent":["import { Options } from '../interface';\n\n/** SVGPathCommander default options */\nconst defaultOptions: Options = {\n  origin: [0, 0, 0],\n  round: 4,\n};\n\nexport default defaultOptions;\n","const error = 'SVGPathCommander Error';\nexport default error;\n","/** Segment params length */\nconst paramsCount = {\n  a: 7,\n  c: 6,\n  h: 1,\n  l: 2,\n  m: 2,\n  r: 4,\n  q: 4,\n  s: 4,\n  t: 2,\n  v: 1,\n  z: 0,\n};\n\nexport default paramsCount;\n","import paramsCount from './paramsCount';\nimport PathParser from './pathParser';\nimport type { PathCommand, PathSegment, RelativeCommand } from '../types';\n\n/**\n * Breaks the parsing of a pathString once a segment is finalized.\n *\n * @param path the `PathParser` instance\n */\nconst finalizeSegment = (path: PathParser) => {\n  let pathCommand = path.pathValue[path.segmentStart] as PathCommand;\n  let LK = pathCommand.toLowerCase() as RelativeCommand;\n  const { data } = path;\n\n  while (data.length >= paramsCount[LK]) {\n    // overloaded `moveTo`\n    // https://github.com/rveciana/svg-path-properties/blob/master/src/parse.ts\n    if (LK === 'm' && data.length > 2) {\n      path.segments.push([pathCommand, ...(data.splice(0, 2) as number[])] as PathSegment);\n      LK = 'l';\n      pathCommand = pathCommand === 'm' ? 'l' : 'L';\n    } else {\n      path.segments.push([pathCommand, ...(data.splice(0, paramsCount[LK]) as number[])] as PathSegment);\n    }\n\n    if (!paramsCount[LK]) {\n      break;\n    }\n  }\n};\nexport default finalizeSegment;\n","import error from './error';\nimport type PathParser from './pathParser';\n\n/**\n * Validates an A (arc-to) specific path command value.\n * Usually a `large-arc-flag` or `sweep-flag`.\n *\n * @param path the `PathParser` instance\n */\nconst scanFlag = (path: PathParser) => {\n  const { index, pathValue } = path;\n  const code = pathValue.charCodeAt(index);\n\n  if (code === 0x30 /* 0 */) {\n    path.param = 0;\n    path.index += 1;\n    return;\n  }\n\n  if (code === 0x31 /* 1 */) {\n    path.param = 1;\n    path.index += 1;\n    return;\n  }\n\n  path.err = `${error}: invalid Arc flag \"${pathValue[index]}\", expecting 0 or 1 at index ${index}`;\n};\n\nexport default scanFlag;\n","import { DigitNumber } from '../types';\n\n/**\n * Checks if a character is a digit.\n *\n * @param code the character to check\n * @returns check result\n */\nconst isDigit = (code: number): code is DigitNumber => {\n  return code >= 48 && code <= 57; // 0..9\n};\nexport default isDigit;\n","const invalidPathValue = 'Invalid path value';\nexport default invalidPathValue;\n","import isDigit from './isDigit';\nimport invalidPathValue from './invalidPathValue';\nimport error from './error';\nimport type PathParser from './pathParser';\n\n/**\n * Validates every character of the path string,\n * every path command, negative numbers or floating point numbers.\n *\n * @param path the `PathParser` instance\n */\nconst scanParam = (path: PathParser) => {\n  const { max, pathValue, index: start } = path;\n  let index = start;\n  let zeroFirst = false;\n  let hasCeiling = false;\n  let hasDecimal = false;\n  let hasDot = false;\n  let ch;\n\n  if (index >= max) {\n    path.err = `${error}: ${invalidPathValue} at index ${index}, \"pathValue\" is missing param`;\n    return;\n  }\n  ch = pathValue.charCodeAt(index);\n\n  if (ch === 0x2b /* + */ || ch === 0x2d /* - */) {\n    index += 1;\n    // ch = (index < max) ? pathValue.charCodeAt(index) : 0;\n    ch = pathValue.charCodeAt(index);\n  }\n\n  // This logic is shamelessly borrowed from Esprima\n  // https://github.com/ariya/esprimas\n  if (!isDigit(ch) && ch !== 0x2e /* . */) {\n    // path.err = 'SvgPath: param should start with 0..9 or `.` (at pos ' + index + ')';\n    path.err = `${error}: ${invalidPathValue} at index ${index}, \"${pathValue[index]}\" is not a number`;\n    return;\n  }\n\n  if (ch !== 0x2e /* . */) {\n    zeroFirst = ch === 0x30 /* 0 */;\n    index += 1;\n\n    ch = pathValue.charCodeAt(index);\n\n    if (zeroFirst && index < max) {\n      // decimal number starts with '0' such as '09' is illegal.\n      if (ch && isDigit(ch)) {\n        // path.err = 'SvgPath: numbers started with `0` such as `09`\n        // are illegal (at pos ' + start + ')';\n        path.err = `${error}: ${invalidPathValue} at index ${start}, \"${pathValue[start]}\" illegal number`;\n        return;\n      }\n    }\n\n    while (index < max && isDigit(pathValue.charCodeAt(index))) {\n      index += 1;\n      hasCeiling = true;\n    }\n\n    ch = pathValue.charCodeAt(index);\n  }\n\n  if (ch === 0x2e /* . */) {\n    hasDot = true;\n    index += 1;\n    while (isDigit(pathValue.charCodeAt(index))) {\n      index += 1;\n      hasDecimal = true;\n    }\n\n    ch = pathValue.charCodeAt(index);\n  }\n\n  if (ch === 0x65 /* e */ || ch === 0x45 /* E */) {\n    if (hasDot && !hasCeiling && !hasDecimal) {\n      path.err = `${error}: ${invalidPathValue} at index ${index}, \"${pathValue[index]}\" invalid float exponent`;\n      return;\n    }\n\n    index += 1;\n\n    ch = pathValue.charCodeAt(index);\n\n    if (ch === 0x2b /* + */ || ch === 0x2d /* - */) {\n      index += 1;\n    }\n    if (index < max && isDigit(pathValue.charCodeAt(index))) {\n      while (index < max && isDigit(pathValue.charCodeAt(index))) {\n        index += 1;\n      }\n    } else {\n      path.err = `${error}: ${invalidPathValue} at index ${index}, \"${pathValue[index]}\" invalid integer exponent`;\n      return;\n    }\n  }\n\n  path.index = index;\n  path.param = +path.pathValue.slice(start, index);\n};\nexport default scanParam;\n","import type { SpaceNumber } from '../types';\n\n/**\n * Checks if the character is a space.\n *\n * @param ch the character to check\n * @returns check result\n */\n\nconst isSpace = (ch: number): ch is SpaceNumber => {\n  const allSpaces = [\n    // Special spaces\n    0x1680, 0x180e, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200a, 0x202f,\n    0x205f, 0x3000, 0xfeff,\n    // Line terminators\n    0x0a, 0x0d, 0x2028, 0x2029,\n    // White spaces\n    0x20, 0x09, 0x0b, 0x0c, 0xa0,\n  ];\n\n  return allSpaces.includes(ch);\n};\nexport default isSpace;\n","import isSpace from './isSpace';\nimport type PathParser from './pathParser';\n\n/**\n * Points the parser to the next character in the\n * path string every time it encounters any kind of\n * space character.\n *\n * @param path the `PathParser` instance\n */\nconst skipSpaces = (path: PathParser) => {\n  const { pathValue, max } = path;\n  while (path.index < max && isSpace(pathValue.charCodeAt(path.index))) {\n    path.index += 1;\n  }\n};\nexport default skipSpaces;\n","import type { PathCommandNumber } from '../types';\n\n/**\n * Checks if the character is a path command.\n *\n * @param code the character to check\n * @returns check result\n */\nconst isPathCommand = (code: number): code is PathCommandNumber => {\n  // eslint-disable-next-line no-bitwise -- Impossible to satisfy\n  switch (code | 0x20) {\n    case 0x6d /* m */:\n    case 0x7a /* z */:\n    case 0x6c /* l */:\n    case 0x68 /* h */:\n    case 0x76 /* v */:\n    case 0x63 /* c */:\n    case 0x73 /* s */:\n    case 0x71 /* q */:\n    case 0x74 /* t */:\n    case 0x61 /* a */:\n      // case 0x72/* r */:\n      return true;\n    default:\n      return false;\n  }\n};\nexport default isPathCommand;\n","import isDigit from './isDigit';\nimport type { DigitNumber } from '../types';\n\n/**\n * Checks if the character is or belongs to a number.\n * [0-9]|+|-|.\n *\n * @param code the character to check\n * @returns check result\n */\nconst isDigitStart = (code: number): code is DigitNumber | 0x2b | 0x2d | 0x2e => {\n  return isDigit(code) /* 0..9 */ || code === 0x2b /* + */ || code === 0x2d /* - */ || code === 0x2e; /* . */\n};\nexport default isDigitStart;\n","/**\n * Checks if the character is an A (arc-to) path command.\n *\n * @param code the character to check\n * @returns check result\n */\nconst isArcCommand = (code: number): code is 0x61 => {\n  // eslint-disable-next-line no-bitwise -- Impossible to satisfy\n  return (code | 0x20) === 0x61;\n};\nexport default isArcCommand;\n","/**\n * Checks if the character is a MoveTo command.\n *\n * @param code the character to check\n * @returns check result\n */\nconst isMoveCommand = (code: number): code is 0x6d | 0x4d => {\n  // eslint-disable-next-line no-bitwise -- Impossible to satisfy\n  switch (code | 0x20) {\n    case 0x6d /* m */:\n    case 0x4d /* M */:\n      return true;\n    default:\n      return false;\n  }\n};\nexport default isMoveCommand;\n","import finalizeSegment from './finalizeSegment';\nimport paramCounts from './paramsCount';\nimport scanFlag from './scanFlag';\nimport scanParam from './scanParam';\nimport skipSpaces from './skipSpaces';\nimport isPathCommand from './isPathCommand';\nimport isDigitStart from './isDigitStart';\nimport isArcCommand from './isArcCommand';\nimport isMoveCommand from './isMoveCommand';\nimport invalidPathValue from './invalidPathValue';\nimport error from './error';\n\nimport type PathParser from './pathParser';\nimport type { PathSegment, RelativeCommand } from '../types';\n\n/**\n * Scans every character in the path string to determine\n * where a segment starts and where it ends.\n *\n * @param path the `PathParser` instance\n */\nconst scanSegment = (path: PathParser) => {\n  const { max, pathValue, index, segments } = path;\n  const cmdCode = pathValue.charCodeAt(index);\n  const reqParams = paramCounts[pathValue[index].toLowerCase() as RelativeCommand];\n\n  path.segmentStart = index;\n\n  // segments always start with a path command\n  if (!isPathCommand(cmdCode)) {\n    path.err = `${error}: ${invalidPathValue} \"${pathValue[index]}\" is not a path command at index ${index}`;\n    return;\n  }\n\n  // after a Z segment, we only expect a MoveTo path command\n  const lastSegment = segments[segments.length - 1] as PathSegment | undefined;\n  if (!isMoveCommand(cmdCode) && lastSegment?.[0]?.toLocaleLowerCase() === 'z') {\n    path.err = `${error}: ${invalidPathValue} \"${pathValue[index]}\" is not a MoveTo path command at index ${index}`;\n    return;\n  }\n\n  path.index += 1;\n  skipSpaces(path);\n\n  path.data = [];\n\n  if (!reqParams) {\n    // Z\n    finalizeSegment(path);\n    return;\n  }\n\n  for (;;) {\n    for (let i = reqParams; i > 0; i -= 1) {\n      if (isArcCommand(cmdCode) && (i === 3 || i === 4)) scanFlag(path);\n      else scanParam(path);\n\n      if (path.err.length) {\n        return;\n      }\n      path.data.push(path.param);\n\n      skipSpaces(path);\n\n      // after ',' param is mandatory\n      if (path.index < max && pathValue.charCodeAt(path.index) === 0x2c /* , */) {\n        path.index += 1;\n        skipSpaces(path);\n      }\n    }\n\n    if (path.index >= path.max) {\n      break;\n    }\n\n    // Stop on next segment\n    if (!isDigitStart(pathValue.charCodeAt(path.index))) {\n      break;\n    }\n  }\n\n  finalizeSegment(path);\n};\nexport default scanSegment;\n","import type { PathArray, PathSegment } from '../types';\n\n/**\n * The `PathParser` is used by the `parsePathString` static method\n * to generate a `pathArray`.\n *\n * @param pathString\n */\nexport default class PathParser {\n  declare segments: PathArray | PathSegment[];\n  declare pathValue: string;\n  declare max: number;\n  declare index: number;\n  declare param: number;\n  declare segmentStart: number;\n  declare data: any[];\n  declare err: string;\n\n  constructor(pathString: string) {\n    this.segments = [];\n    this.pathValue = pathString;\n    this.max = pathString.length;\n    this.index = 0;\n    this.param = 0.0;\n    this.segmentStart = 0;\n    this.data = [];\n    this.err = '';\n  }\n}\n","import scanSegment from './scanSegment';\nimport skipSpaces from './skipSpaces';\nimport PathParser from './pathParser';\nimport type { PathArray } from '../types';\n\n/**\n * Parses a path string value and returns an array\n * of segments we like to call `pathArray`.\n *\n * @param pathInput the string to be parsed\n * @returns the resulted `pathArray` or error string\n */\nconst parsePathString = (pathInput: string | PathArray) => {\n  if (typeof pathInput !== 'string') {\n    return pathInput.slice(0) as PathArray;\n    // return pathInput;\n  }\n\n  const path = new PathParser(pathInput);\n\n  skipSpaces(path);\n\n  while (path.index < path.max && !path.err.length) {\n    scanSegment(path);\n  }\n\n  if (path?.err.length) {\n    throw TypeError(path.err);\n  }\n\n  return path.segments as PathArray;\n};\n\nexport default parsePathString;\n","import { type PointTuple } from '../types';\n\n/**\n * d3-polygon-area\n * https://github.com/d3/d3-polygon\n *\n * Returns the area of a polygon.\n *\n * @param polygon an array of coordinates\n * @returns the polygon area\n */\nconst polygonArea = (polygon: PointTuple[]): number => {\n  const n = polygon.length;\n  let i = -1;\n  let a;\n  let b = polygon[n - 1];\n  let area = 0;\n\n  /* eslint-disable-next-line */\n  while (++i < n) {\n    a = b;\n    b = polygon[i];\n    area += a[1] * b[0] - a[0] * b[1];\n  }\n\n  return area / 2;\n};\n\nexport default polygonArea;\n","import { type PointTuple } from '../types';\n\n/**\n * Returns the square root of the distance\n * between two given points.\n *\n * @param a the first point coordinates\n * @param b the second point coordinates\n * @returns the distance value\n */\nconst distanceSquareRoot = (a: PointTuple, b: PointTuple): number => {\n  return Math.sqrt((a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1]));\n};\n\nexport default distanceSquareRoot;\n","import { type PointTuple } from '../types';\nimport distanceSquareRoot from './distanceSquareRoot';\n\n/**\n * d3-polygon-length\n * https://github.com/d3/d3-polygon\n *\n * Returns the perimeter of a polygon.\n *\n * @param polygon an array of coordinates\n * @returns {number} the polygon length\n */\nconst polygonLength = (polygon: PointTuple[]): number => {\n  return polygon.reduce((length, point, i) => {\n    if (i) {\n      return length + distanceSquareRoot(polygon[i - 1], point);\n    }\n    return 0;\n  }, 0);\n};\n\nexport default polygonLength;\n","var Z = Object.defineProperty;\nvar z = (s, t, e) => t in s ? Z(s, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : s[t] = e;\nvar p = (s, t, e) => z(s, typeof t != \"symbol\" ? t + \"\" : t, e);\nconst $ = {\n  a: 1,\n  b: 0,\n  c: 0,\n  d: 1,\n  e: 0,\n  f: 0,\n  m11: 1,\n  m12: 0,\n  m13: 0,\n  m14: 0,\n  m21: 0,\n  m22: 1,\n  m23: 0,\n  m24: 0,\n  m31: 0,\n  m32: 0,\n  m33: 1,\n  m34: 0,\n  m41: 0,\n  m42: 0,\n  m43: 0,\n  m44: 1,\n  is2D: !0,\n  isIdentity: !0\n}, E = (s) => (s instanceof Float64Array || s instanceof Float32Array || Array.isArray(s) && s.every((t) => typeof t == \"number\")) && [6, 16].some((t) => s.length === t), P = (s) => s instanceof DOMMatrix || s instanceof y || typeof s == \"object\" && Object.keys($).every((t) => s && t in s), g = (s) => {\n  const t = new y(), e = Array.from(s);\n  if (!E(e))\n    throw TypeError(`CSSMatrix: \"${e.join(\",\")}\" must be an array with 6/16 numbers.`);\n  // istanbul ignore else @preserve\n  if (e.length === 16) {\n    const [n, i, r, a, l, m, h, c, u, f, w, o, d, A, M, b] = e;\n    t.m11 = n, t.a = n, t.m21 = l, t.c = l, t.m31 = u, t.m41 = d, t.e = d, t.m12 = i, t.b = i, t.m22 = m, t.d = m, t.m32 = f, t.m42 = A, t.f = A, t.m13 = r, t.m23 = h, t.m33 = w, t.m43 = M, t.m14 = a, t.m24 = c, t.m34 = o, t.m44 = b;\n  } else if (e.length === 6) {\n    const [n, i, r, a, l, m] = e;\n    t.m11 = n, t.a = n, t.m12 = i, t.b = i, t.m21 = r, t.c = r, t.m22 = a, t.d = a, t.m41 = l, t.e = l, t.m42 = m, t.f = m;\n  }\n  return t;\n}, X = (s) => {\n  if (P(s))\n    return g([\n      s.m11,\n      s.m12,\n      s.m13,\n      s.m14,\n      s.m21,\n      s.m22,\n      s.m23,\n      s.m24,\n      s.m31,\n      s.m32,\n      s.m33,\n      s.m34,\n      s.m41,\n      s.m42,\n      s.m43,\n      s.m44\n    ]);\n  throw TypeError(`CSSMatrix: \"${JSON.stringify(s)}\" is not a DOMMatrix / CSSMatrix / JSON compatible object.`);\n}, O = (s) => {\n  if (typeof s != \"string\")\n    throw TypeError(`CSSMatrix: \"${JSON.stringify(s)}\" is not a string.`);\n  const t = String(s).replace(/\\s/g, \"\");\n  let e = new y();\n  const n = `CSSMatrix: invalid transform string \"${s}\"`;\n  return t.split(\")\").filter((i) => i).forEach((i) => {\n    const [r, a] = i.split(\"(\");\n    if (!a) throw TypeError(n);\n    const l = a.split(\",\").map((o) => o.includes(\"rad\") ? parseFloat(o) * (180 / Math.PI) : parseFloat(o)), [m, h, c, u] = l, f = [m, h, c], w = [m, h, c, u];\n    if (r === \"perspective\" && m && [h, c].every((o) => o === void 0))\n      e.m34 = -1 / m;\n    else if (r.includes(\"matrix\") && [6, 16].includes(l.length) && l.every((o) => !Number.isNaN(+o))) {\n      const o = l.map((d) => Math.abs(d) < 1e-6 ? 0 : d);\n      e = e.multiply(g(o));\n    } else if (r === \"translate3d\" && f.every((o) => !Number.isNaN(+o)))\n      e = e.translate(m, h, c);\n    else if (r === \"translate\" && m && c === void 0)\n      e = e.translate(m, h || 0, 0);\n    else if (r === \"rotate3d\" && w.every((o) => !Number.isNaN(+o)) && u)\n      e = e.rotateAxisAngle(m, h, c, u);\n    else if (r === \"rotate\" && m && [h, c].every((o) => o === void 0))\n      e = e.rotate(0, 0, m);\n    else if (r === \"scale3d\" && f.every((o) => !Number.isNaN(+o)) && f.some((o) => o !== 1))\n      e = e.scale(m, h, c);\n    else if (r === \"scale\" && !Number.isNaN(m) && m !== 1 && c === void 0) {\n      const d = Number.isNaN(+h) ? m : h;\n      e = e.scale(m, d, 1);\n    } else if (r === \"skew\" && (m || !Number.isNaN(m) && h) && c === void 0)\n      e = e.skew(m, h || 0);\n    else if ([\"translate\", \"rotate\", \"scale\", \"skew\"].some((o) => r.includes(o)) && /[XYZ]/.test(r) && m && [h, c].every((o) => o === void 0))\n      if (r === \"skewX\" || r === \"skewY\")\n        e = e[r](m);\n      else {\n        const o = r.replace(/[XYZ]/, \"\"), d = r.replace(o, \"\"), A = [\"X\", \"Y\", \"Z\"].indexOf(d), M = o === \"scale\" ? 1 : 0, b = [A === 0 ? m : M, A === 1 ? m : M, A === 2 ? m : M];\n        e = e[o](...b);\n      }\n    else\n      throw TypeError(n);\n  }), e;\n}, x = (s, t) => t ? [s.a, s.b, s.c, s.d, s.e, s.f] : [\n  s.m11,\n  s.m12,\n  s.m13,\n  s.m14,\n  s.m21,\n  s.m22,\n  s.m23,\n  s.m24,\n  s.m31,\n  s.m32,\n  s.m33,\n  s.m34,\n  s.m41,\n  s.m42,\n  s.m43,\n  s.m44\n], Y = (s, t, e) => {\n  const n = new y();\n  return n.m41 = s, n.e = s, n.m42 = t, n.f = t, n.m43 = e, n;\n}, F = (s, t, e) => {\n  const n = new y(), i = Math.PI / 180, r = s * i, a = t * i, l = e * i, m = Math.cos(r), h = -Math.sin(r), c = Math.cos(a), u = -Math.sin(a), f = Math.cos(l), w = -Math.sin(l), o = c * f, d = -c * w;\n  n.m11 = o, n.a = o, n.m12 = d, n.b = d, n.m13 = u;\n  const A = h * u * f + m * w;\n  n.m21 = A, n.c = A;\n  const M = m * f - h * u * w;\n  return n.m22 = M, n.d = M, n.m23 = -h * c, n.m31 = h * w - m * u * f, n.m32 = h * f + m * u * w, n.m33 = m * c, n;\n}, T = (s, t, e, n) => {\n  const i = new y(), r = Math.sqrt(s * s + t * t + e * e);\n  if (r === 0)\n    return i;\n  const a = s / r, l = t / r, m = e / r, h = n * (Math.PI / 360), c = Math.sin(h), u = Math.cos(h), f = c * c, w = a * a, o = l * l, d = m * m, A = 1 - 2 * (o + d) * f;\n  i.m11 = A, i.a = A;\n  const M = 2 * (a * l * f + m * c * u);\n  i.m12 = M, i.b = M, i.m13 = 2 * (a * m * f - l * c * u);\n  const b = 2 * (l * a * f - m * c * u);\n  i.m21 = b, i.c = b;\n  const k = 1 - 2 * (d + w) * f;\n  return i.m22 = k, i.d = k, i.m23 = 2 * (l * m * f + a * c * u), i.m31 = 2 * (m * a * f + l * c * u), i.m32 = 2 * (m * l * f - a * c * u), i.m33 = 1 - 2 * (w + o) * f, i;\n}, I = (s, t, e) => {\n  const n = new y();\n  return n.m11 = s, n.a = s, n.m22 = t, n.d = t, n.m33 = e, n;\n}, v = (s, t) => {\n  const e = new y();\n  if (s) {\n    const n = s * Math.PI / 180, i = Math.tan(n);\n    e.m21 = i, e.c = i;\n  }\n  if (t) {\n    const n = t * Math.PI / 180, i = Math.tan(n);\n    e.m12 = i, e.b = i;\n  }\n  return e;\n}, R = (s) => v(s, 0), D = (s) => v(0, s), N = (s, t) => {\n  const e = t.m11 * s.m11 + t.m12 * s.m21 + t.m13 * s.m31 + t.m14 * s.m41, n = t.m11 * s.m12 + t.m12 * s.m22 + t.m13 * s.m32 + t.m14 * s.m42, i = t.m11 * s.m13 + t.m12 * s.m23 + t.m13 * s.m33 + t.m14 * s.m43, r = t.m11 * s.m14 + t.m12 * s.m24 + t.m13 * s.m34 + t.m14 * s.m44, a = t.m21 * s.m11 + t.m22 * s.m21 + t.m23 * s.m31 + t.m24 * s.m41, l = t.m21 * s.m12 + t.m22 * s.m22 + t.m23 * s.m32 + t.m24 * s.m42, m = t.m21 * s.m13 + t.m22 * s.m23 + t.m23 * s.m33 + t.m24 * s.m43, h = t.m21 * s.m14 + t.m22 * s.m24 + t.m23 * s.m34 + t.m24 * s.m44, c = t.m31 * s.m11 + t.m32 * s.m21 + t.m33 * s.m31 + t.m34 * s.m41, u = t.m31 * s.m12 + t.m32 * s.m22 + t.m33 * s.m32 + t.m34 * s.m42, f = t.m31 * s.m13 + t.m32 * s.m23 + t.m33 * s.m33 + t.m34 * s.m43, w = t.m31 * s.m14 + t.m32 * s.m24 + t.m33 * s.m34 + t.m34 * s.m44, o = t.m41 * s.m11 + t.m42 * s.m21 + t.m43 * s.m31 + t.m44 * s.m41, d = t.m41 * s.m12 + t.m42 * s.m22 + t.m43 * s.m32 + t.m44 * s.m42, A = t.m41 * s.m13 + t.m42 * s.m23 + t.m43 * s.m33 + t.m44 * s.m43, M = t.m41 * s.m14 + t.m42 * s.m24 + t.m43 * s.m34 + t.m44 * s.m44;\n  return g([e, n, i, r, a, l, m, h, c, u, f, w, o, d, A, M]);\n};\nclass y {\n  /**\n   * @constructor\n   * @param init accepts all parameter configurations:\n   * * valid CSS transform string,\n   * * CSSMatrix/DOMMatrix instance,\n   * * a 6/16 elements *Array*.\n   */\n  constructor(t) {\n    return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.e = 0, this.f = 0, this.m11 = 1, this.m12 = 0, this.m13 = 0, this.m14 = 0, this.m21 = 0, this.m22 = 1, this.m23 = 0, this.m24 = 0, this.m31 = 0, this.m32 = 0, this.m33 = 1, this.m34 = 0, this.m41 = 0, this.m42 = 0, this.m43 = 0, this.m44 = 1, t ? this.setMatrixValue(t) : this;\n  }\n  /**\n   * A `Boolean` whose value is `true` if the matrix is the identity matrix. The identity\n   * matrix is one in which every value is 0 except those on the main diagonal from top-left\n   * to bottom-right corner (in other words, where the offsets in each direction are equal).\n   *\n   * @return the current property value\n   */\n  get isIdentity() {\n    return this.m11 === 1 && this.m12 === 0 && this.m13 === 0 && this.m14 === 0 && this.m21 === 0 && this.m22 === 1 && this.m23 === 0 && this.m24 === 0 && this.m31 === 0 && this.m32 === 0 && this.m33 === 1 && this.m34 === 0 && this.m41 === 0 && this.m42 === 0 && this.m43 === 0 && this.m44 === 1;\n  }\n  /**\n   * A `Boolean` flag whose value is `true` if the matrix was initialized as a 2D matrix\n   * and `false` if the matrix is 3D.\n   *\n   * @return the current property value\n   */\n  get is2D() {\n    return this.m31 === 0 && this.m32 === 0 && this.m33 === 1 && this.m34 === 0 && this.m43 === 0 && this.m44 === 1;\n  }\n  /**\n   * The `setMatrixValue` method replaces the existing matrix with one computed\n   * in the browser. EG: `matrix(1,0.25,-0.25,1,0,0)`\n   *\n   * The method accepts any *Array* values, the result of\n   * `DOMMatrix` instance method `toFloat64Array()` / `toFloat32Array()` calls\n   * or `CSSMatrix` instance method `toArray()`.\n   *\n   * This method expects valid *matrix()* / *matrix3d()* string values, as well\n   * as other transform functions like *translateX(10px)*.\n   *\n   * @param source\n   * @return the matrix instance\n   */\n  setMatrixValue(t) {\n    return typeof t == \"string\" && t.length && t !== \"none\" ? O(t) : Array.isArray(t) || t instanceof Float64Array || t instanceof Float32Array ? g(t) : typeof t == \"object\" ? X(t) : this;\n  }\n  /**\n   * Returns a *Float32Array* containing elements which comprise the matrix.\n   * The method can return either the 16 elements or the 6 elements\n   * depending on the value of the `is2D` parameter.\n   *\n   * @param is2D *Array* representation of the matrix\n   * @return an *Array* representation of the matrix\n   */\n  toFloat32Array(t) {\n    return Float32Array.from(x(this, t));\n  }\n  /**\n   * Returns a *Float64Array* containing elements which comprise the matrix.\n   * The method can return either the 16 elements or the 6 elements\n   * depending on the value of the `is2D` parameter.\n   *\n   * @param is2D *Array* representation of the matrix\n   * @return an *Array* representation of the matrix\n   */\n  toFloat64Array(t) {\n    return Float64Array.from(x(this, t));\n  }\n  /**\n   * Creates and returns a string representation of the matrix in `CSS` matrix syntax,\n   * using the appropriate `CSS` matrix notation.\n   *\n   * matrix3d *matrix3d(m11, m12, m13, m14, m21, ...)*\n   * matrix *matrix(a, b, c, d, e, f)*\n   *\n   * @return a string representation of the matrix\n   */\n  toString() {\n    const { is2D: t } = this, e = this.toFloat64Array(t).join(\", \");\n    return `${t ? \"matrix\" : \"matrix3d\"}(${e})`;\n  }\n  /**\n   * Returns a JSON representation of the `CSSMatrix` instance, a standard *Object*\n   * that includes `{a,b,c,d,e,f}` and `{m11,m12,m13,..m44}` properties as well\n   * as the `is2D` & `isIdentity` properties.\n   *\n   * The result can also be used as a second parameter for the `fromMatrix` static method\n   * to load values into another matrix instance.\n   *\n   * @return an *Object* with all matrix values.\n   */\n  toJSON() {\n    const { is2D: t, isIdentity: e } = this;\n    return { ...this, is2D: t, isIdentity: e };\n  }\n  /**\n   * The Multiply method returns a new CSSMatrix which is the result of this\n   * matrix multiplied by the passed matrix, with the passed matrix to the right.\n   * This matrix is not modified.\n   *\n   * @param m2 CSSMatrix\n   * @return The resulted matrix.\n   */\n  multiply(t) {\n    return N(this, t);\n  }\n  /**\n   * The translate method returns a new matrix which is this matrix post\n   * multiplied by a translation matrix containing the passed values. If the z\n   * component is undefined, a 0 value is used in its place. This matrix is not\n   * modified.\n   *\n   * @param x X component of the translation value.\n   * @param y Y component of the translation value.\n   * @param z Z component of the translation value.\n   * @return The resulted matrix\n   */\n  translate(t, e, n) {\n    const i = t;\n    let r = e, a = n;\n    return typeof r > \"u\" && (r = 0), typeof a > \"u\" && (a = 0), N(this, Y(i, r, a));\n  }\n  /**\n   * The scale method returns a new matrix which is this matrix post multiplied by\n   * a scale matrix containing the passed values. If the z component is undefined,\n   * a 1 value is used in its place. If the y component is undefined, the x\n   * component value is used in its place. This matrix is not modified.\n   *\n   * @param x The X component of the scale value.\n   * @param y The Y component of the scale value.\n   * @param z The Z component of the scale value.\n   * @return The resulted matrix\n   */\n  scale(t, e, n) {\n    const i = t;\n    let r = e, a = n;\n    return typeof r > \"u\" && (r = t), typeof a > \"u\" && (a = 1), N(this, I(i, r, a));\n  }\n  /**\n   * The rotate method returns a new matrix which is this matrix post multiplied\n   * by each of 3 rotation matrices about the major axes, first X, then Y, then Z.\n   * If the y and z components are undefined, the x value is used to rotate the\n   * object about the z axis, as though the vector (0,0,x) were passed. All\n   * rotation values are in degrees. This matrix is not modified.\n   *\n   * @param rx The X component of the rotation, or Z if Y and Z are null.\n   * @param ry The (optional) Y component of the rotation value.\n   * @param rz The (optional) Z component of the rotation value.\n   * @return The resulted matrix\n   */\n  rotate(t, e, n) {\n    let i = t, r = e || 0, a = n || 0;\n    return typeof t == \"number\" && typeof e > \"u\" && typeof n > \"u\" && (a = i, i = 0, r = 0), N(this, F(i, r, a));\n  }\n  /**\n   * The rotateAxisAngle method returns a new matrix which is this matrix post\n   * multiplied by a rotation matrix with the given axis and `angle`. The right-hand\n   * rule is used to determine the direction of rotation. All rotation values are\n   * in degrees. This matrix is not modified.\n   *\n   * @param x The X component of the axis vector.\n   * @param y The Y component of the axis vector.\n   * @param z The Z component of the axis vector.\n   * @param angle The angle of rotation about the axis vector, in degrees.\n   * @return The resulted matrix\n   */\n  rotateAxisAngle(t, e, n, i) {\n    if ([t, e, n, i].some((r) => Number.isNaN(+r)))\n      throw new TypeError(\"CSSMatrix: expecting 4 values\");\n    return N(this, T(t, e, n, i));\n  }\n  /**\n   * Specifies a skew transformation along the `x-axis` by the given angle.\n   * This matrix is not modified.\n   *\n   * @param angle The angle amount in degrees to skew.\n   * @return The resulted matrix\n   */\n  skewX(t) {\n    return N(this, R(t));\n  }\n  /**\n   * Specifies a skew transformation along the `y-axis` by the given angle.\n   * This matrix is not modified.\n   *\n   * @param angle The angle amount in degrees to skew.\n   * @return The resulted matrix\n   */\n  skewY(t) {\n    return N(this, D(t));\n  }\n  /**\n   * Specifies a skew transformation along both the `x-axis` and `y-axis`.\n   * This matrix is not modified.\n   *\n   * @param angleX The X-angle amount in degrees to skew.\n   * @param angleY The angle amount in degrees to skew.\n   * @return The resulted matrix\n   */\n  skew(t, e) {\n    return N(this, v(t, e));\n  }\n  /**\n   * Transforms a specified vector using the matrix, returning a new\n   * {x,y,z,w} Tuple *Object* comprising the transformed vector.\n   * Neither the matrix nor the original vector are altered.\n   *\n   * The method is equivalent with `transformPoint()` method\n   * of the `DOMMatrix` constructor.\n   *\n   * @param t Tuple with `{x,y,z,w}` components\n   * @return the resulting Tuple\n   */\n  transformPoint(t) {\n    const e = this.m11 * t.x + this.m21 * t.y + this.m31 * t.z + this.m41 * t.w, n = this.m12 * t.x + this.m22 * t.y + this.m32 * t.z + this.m42 * t.w, i = this.m13 * t.x + this.m23 * t.y + this.m33 * t.z + this.m43 * t.w, r = this.m14 * t.x + this.m24 * t.y + this.m34 * t.z + this.m44 * t.w;\n    return t instanceof DOMPoint ? new DOMPoint(e, n, i, r) : {\n      x: e,\n      y: n,\n      z: i,\n      w: r\n    };\n  }\n}\np(y, \"Translate\", Y), p(y, \"Rotate\", F), p(y, \"RotateAxisAngle\", T), p(y, \"Scale\", I), p(y, \"SkewX\", R), p(y, \"SkewY\", D), p(y, \"Skew\", v), p(y, \"Multiply\", N), p(y, \"fromArray\", g), p(y, \"fromMatrix\", X), p(y, \"fromString\", O), p(y, \"toArray\", x), p(y, \"isCompatibleArray\", E), p(y, \"isCompatibleObject\", P);\nexport {\n  y as default\n};\n//# sourceMappingURL=dommatrix.mjs.map\n","import type { ParserParams } from '../interface';\n\nconst paramsParser: ParserParams = {\n  x1: 0,\n  y1: 0,\n  x2: 0,\n  y2: 0,\n  x: 0,\n  y: 0,\n  qx: null,\n  qy: null,\n};\n\nexport default paramsParser;\n","import paramsParser from '../parser/paramsParser';\nimport type { PathArray, PathCommand, PathSegment, IteratorCallback } from '../types';\n\nconst iterate = <T extends PathArray>(path: PathArray, iterator: IteratorCallback) => {\n  const allPathCommands = [] as PathCommand[];\n  const params = { ...paramsParser };\n  let pathLen = path.length;\n  let segment: PathSegment;\n  let pathCommand = 'M' as PathCommand;\n\n  for (let i = 0; i < pathLen; i += 1) {\n    segment = path[i];\n    [pathCommand] = segment;\n    allPathCommands[i] = pathCommand;\n    const iteratorResult = iterator(segment, params, i);\n    path[i] = iteratorResult;\n\n    if (iteratorResult[0] === 'C') {\n      pathLen = path.length;\n    }\n\n    segment = path[i];\n    const seglen = segment.length;\n    params.x1 = +segment[seglen - 2];\n    params.y1 = +segment[seglen - 1];\n    params.x2 = +segment[seglen - 4] || params.x1;\n    params.y2 = +segment[seglen - 3] || params.y1;\n  }\n  // console.log('iteration: ', ...path)\n  return path as T;\n};\n\nexport default iterate;\n","import type { ParserParams } from '../interface';\nimport type {\n  AbsoluteSegment,\n  AbsoluteCommand,\n  ASegment,\n  VSegment,\n  HSegment,\n  QSegment,\n  SSegment,\n  TSegment,\n  CSegment,\n  PathSegment,\n  MSegment,\n} from '../types';\n\n/**\n * Returns an absolute segment of a `PathArray` object.\n *\n * @param segment the segment object\n * @param params the coordinates of the previous segment\n * @returns the absolute segment\n */\nconst absolutizeSegment = (segment: PathSegment, params: ParserParams) => {\n  const [pathCommand] = segment;\n  const { x, y } = params;\n  const values = segment.slice(1).map(Number);\n  const absCommand = pathCommand.toUpperCase() as AbsoluteCommand;\n  const isAbsolute = absCommand === pathCommand;\n\n  /* istanbul ignore else @preserve */\n  if (!isAbsolute) {\n    if (absCommand === 'A') {\n      return [\n        absCommand,\n        values[0],\n        values[1],\n        values[2],\n        values[3],\n        values[4],\n        values[5] + x,\n        values[6] + y,\n      ] as ASegment;\n    } else if (absCommand === 'V') {\n      return [absCommand, values[0] + y] as VSegment;\n    } else if (absCommand === 'H') {\n      return [absCommand, values[0] + x] as HSegment;\n    } else {\n      // use brakets for `eslint: no-case-declaration`\n      // https://stackoverflow.com/a/50753272/803358\n      const absValues = values.map((n, j) => n + (j % 2 ? y : x));\n      // for n, l, c, s, q, t\n      return [absCommand, ...absValues] as MSegment | QSegment | TSegment | SSegment | CSegment;\n    }\n  }\n\n  return segment as AbsoluteSegment;\n};\nexport default absolutizeSegment;\n","import type { ParserParams } from '../interface';\nimport type { NormalSegment, PointTuple, PathSegment, QSegment, CSegment, LSegment } from '../types';\n\n/**\n * Normalizes a single segment of a `pathArray` object.\n *\n * @param segment the segment object\n * @param params the coordinates of the previous segment\n * @returns the normalized segment\n */\nconst normalizeSegment = (segment: PathSegment, params: ParserParams) => {\n  const [pathCommand] = segment;\n  const { x1: px1, y1: py1, x2: px2, y2: py2 } = params;\n  const values = segment.slice(1).map(Number);\n\n  if (!'TQ'.includes(pathCommand)) {\n    // optional but good to be cautious\n    params.qx = null;\n    params.qy = null;\n  }\n\n  if (pathCommand === 'H') {\n    return ['L', segment[1], py1] as LSegment;\n  } else if (pathCommand === 'V') {\n    return ['L', px1, segment[1]] as LSegment;\n  } else if (pathCommand === 'S') {\n    const x1 = px1 * 2 - px2;\n    const y1 = py1 * 2 - py2;\n    params.x1 = x1;\n    params.y1 = y1;\n    return ['C', x1, y1, ...values] as CSegment;\n  } else if (pathCommand === 'T') {\n    const qx = px1 * 2 - (params.qx ? params.qx : /* istanbul ignore next */ 0);\n    const qy = py1 * 2 - (params.qy ? params.qy : /* istanbul ignore next */ 0);\n    params.qx = qx;\n    params.qy = qy;\n    return ['Q', qx, qy, ...values] as QSegment;\n  } else if (pathCommand === 'Q') {\n    const [nqx, nqy] = values as PointTuple;\n    params.qx = nqx;\n    params.qy = nqy;\n  }\n\n  return segment as NormalSegment;\n};\nexport default normalizeSegment;\n","import { PointTuple } from '../types';\n\n/**\n * Returns the coordinates of a specified distance\n * ratio between two points.\n *\n * @param a the first point coordinates\n * @param b the second point coordinates\n * @param t the ratio\n * @returns the midpoint coordinates\n */\nconst midPoint = (a: PointTuple, b: PointTuple, t: number): PointTuple => {\n  const [ax, ay] = a;\n  const [bx, by] = b;\n  return [ax + (bx - ax) * t, ay + (by - ay) * t];\n};\n\nexport default midPoint;\n","import midPoint from './midPoint';\nimport distanceSquareRoot from './distanceSquareRoot';\n\n/**\n * Returns length for line segments (MoveTo, LineTo).\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @returns the line segment length\n */\nexport const getLineLength = (x1: number, y1: number, x2: number, y2: number) => {\n  return distanceSquareRoot([x1, y1], [x2, y2]);\n};\n\n/**\n * Returns a point along the line segments (MoveTo, LineTo).\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @param distance the distance to point in [0-1] range\n * @returns the point at length\n */\nexport const getPointAtLineLength = (x1: number, y1: number, x2: number, y2: number, distance?: number) => {\n  const length = distanceSquareRoot([x1, y1], [x2, y2]);\n  let point = { x: x1, y: y1 };\n\n  /* istanbul ignore else @preserve */\n  if (typeof distance === 'number') {\n    if (distance <= 0) {\n      point = { x: x1, y: y1 };\n    } else if (distance >= length) {\n      point = { x: x2, y: y2 };\n    } else {\n      const [x, y] = midPoint([x1, y1], [x2, y2], distance / length);\n      point = { x, y };\n    }\n  }\n  return point;\n};\n\n/**\n * Returns bounding box for line segments (MoveTo, LineTo).\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @param distance the distance to point in [0-1] range\n * @returns the extrema for line segments\n */\nexport const getLineBBox = (x1: number, y1: number, x2: number, y2: number) => {\n  const { min, max } = Math;\n  return {\n    min: {\n      x: min(x1, x2),\n      y: min(y1, y2),\n    },\n    max: {\n      x: max(x1, x2),\n      y: max(y1, y2),\n    },\n  };\n};\n","import { getPointAtLineLength } from './lineTools';\nimport type { Point } from '../types';\n\n/**\n * Returns the Arc segment length.\n * @param rx radius along X axis\n * @param ry radius along Y axis\n * @param theta the angle in radians\n * @returns the arc length\n */\nconst ellipticalArcLength = (rx: number, ry: number, theta: number) => {\n  const halfTheta = theta / 2;\n  const sinHalfTheta = Math.sin(halfTheta);\n  const cosHalfTheta = Math.cos(halfTheta);\n  const term1 = rx ** 2 * sinHalfTheta ** 2;\n  const term2 = ry ** 2 * cosHalfTheta ** 2;\n  const arcLength = Math.sqrt(term1 + term2) * theta;\n  return Math.abs(arcLength);\n};\n\n/**\n * Compute point on ellipse from angle around ellipse (theta);\n * @param theta the arc sweep angle\n * @param cx the center X\n * @param cy the center Y\n * @param rx the radius X\n * @param ry the radius Y\n * @param alpha the angle\n * @returns a point around ellipse\n */\nconst arc = (theta: number, cx: number, cy: number, rx: number, ry: number, alpha: number) => {\n  // theta is angle in radians around arc\n  // alpha is angle of rotation of ellipse in radians\n  const cos = Math.cos(alpha);\n  const sin = Math.sin(alpha);\n  const x = rx * Math.cos(theta);\n  const y = ry * Math.sin(theta);\n\n  return {\n    x: cx + cos * x - sin * y,\n    y: cy + sin * x + cos * y,\n  };\n};\n\n/**\n * Returns the angle between two points.\n * @param v0 starting point\n * @param v1 ending point\n * @returns the angle\n */\nconst angleBetween = (v0: Point, v1: Point) => {\n  const { x: v0x, y: v0y } = v0;\n  const { x: v1x, y: v1y } = v1;\n  const p = v0x * v1x + v0y * v1y;\n  const n = Math.sqrt((v0x ** 2 + v0y ** 2) * (v1x ** 2 + v1y ** 2));\n  const sign = v0x * v1y - v0y * v1x < 0 ? -1 : 1;\n  const angle = sign * Math.acos(p / n);\n\n  return angle;\n};\n\n/**\n * Returns the following properties for an Arc segment: center, start angle\n * and radiuses on X and Y coordinates.\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param RX the radius on X axis\n * @param RY the radius on Y axis\n * @param angle the ellipse rotation in degrees\n * @param LAF the large arc flag\n * @param SF the sweep flag\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @returns properties specific to Arc segments\n */\nconst getArcProps = (\n  x1: number,\n  y1: number,\n  RX: number,\n  RY: number,\n  angle: number,\n  LAF: number,\n  SF: number,\n  x: number,\n  y: number,\n) => {\n  const { abs, sin, cos, sqrt, PI } = Math;\n  let rx = abs(RX);\n  let ry = abs(RY);\n  const xRot = ((angle % 360) + 360) % 360;\n  const xRotRad = xRot * (PI / 180);\n\n  if (x1 === x && y1 === y) {\n    return {\n      rx,\n      ry,\n      startAngle: 0,\n      endAngle: 0,\n      center: { x, y },\n    };\n  }\n\n  if (rx === 0 || ry === 0) {\n    return {\n      rx,\n      ry,\n      startAngle: 0,\n      endAngle: 0,\n      center: { x, y },\n    };\n  }\n\n  const dx = (x1 - x) / 2;\n  const dy = (y1 - y) / 2;\n\n  const transformedPoint = {\n    x: cos(xRotRad) * dx + sin(xRotRad) * dy,\n    y: -sin(xRotRad) * dx + cos(xRotRad) * dy,\n  };\n\n  const radiiCheck = transformedPoint.x ** 2 / rx ** 2 + transformedPoint.y ** 2 / ry ** 2;\n\n  if (radiiCheck > 1) {\n    rx *= sqrt(radiiCheck);\n    ry *= sqrt(radiiCheck);\n  }\n\n  const cSquareNumerator = rx ** 2 * ry ** 2 - rx ** 2 * transformedPoint.y ** 2 - ry ** 2 * transformedPoint.x ** 2;\n  const cSquareRootDenom = rx ** 2 * transformedPoint.y ** 2 + ry ** 2 * transformedPoint.x ** 2;\n\n  let cRadicand = cSquareNumerator / cSquareRootDenom;\n  /* istanbul ignore next @preserve */\n  cRadicand = cRadicand < 0 ? 0 : cRadicand;\n  const cCoef = (LAF !== SF ? 1 : -1) * sqrt(cRadicand);\n  const transformedCenter = {\n    x: cCoef * ((rx * transformedPoint.y) / ry),\n    y: cCoef * (-(ry * transformedPoint.x) / rx),\n  };\n\n  const center = {\n    x: cos(xRotRad) * transformedCenter.x - sin(xRotRad) * transformedCenter.y + (x1 + x) / 2,\n    y: sin(xRotRad) * transformedCenter.x + cos(xRotRad) * transformedCenter.y + (y1 + y) / 2,\n  };\n\n  const startVector = {\n    x: (transformedPoint.x - transformedCenter.x) / rx,\n    y: (transformedPoint.y - transformedCenter.y) / ry,\n  };\n\n  const startAngle = angleBetween({ x: 1, y: 0 }, startVector);\n\n  const endVector = {\n    x: (-transformedPoint.x - transformedCenter.x) / rx,\n    y: (-transformedPoint.y - transformedCenter.y) / ry,\n  };\n\n  let sweepAngle = angleBetween(startVector, endVector);\n  if (!SF && sweepAngle > 0) {\n    sweepAngle -= 2 * PI;\n  } else if (SF && sweepAngle < 0) {\n    sweepAngle += 2 * PI;\n  }\n  sweepAngle %= 2 * PI;\n\n  const endAngle = startAngle + sweepAngle;\n\n  // to be used later\n  // point.ellipticalArcStartAngle = startAngle;\n  // point.ellipticalArcEndAngle = startAngle + sweepAngle;\n  // point.ellipticalArcAngle = alpha;\n\n  // point.ellipticalArcCenter = center;\n  // point.resultantRx = rx;\n  // point.resultantRy = ry;\n  // point.length = ellipticalArcLength(rx, ry, sweepAngle);\n  // point.box = minmax(center.x, center.y, rx, ry, xRotRad, startAngle, startAngle + sweepAngle);\n\n  return {\n    center,\n    startAngle,\n    endAngle,\n    rx,\n    ry,\n  };\n};\n\n/**\n * Returns the length of an Arc segment.\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param c1x the first control point X\n * @param c1y the first control point Y\n * @param c2x the second control point X\n * @param c2y the second control point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @returns the length of the Arc segment\n */\nexport const getArcLength = (\n  x1: number,\n  y1: number,\n  RX: number,\n  RY: number,\n  angle: number,\n  LAF: number,\n  SF: number,\n  x: number,\n  y: number,\n) => {\n  const { rx, ry, startAngle, endAngle } = getArcProps(x1, y1, RX, RY, angle, LAF, SF, x, y);\n  return ellipticalArcLength(rx, ry, endAngle - startAngle);\n};\n\n/**\n * Returns a point along an Arc segment at a given distance.\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param RX the radius on X axis\n * @param RY the radius on Y axis\n * @param angle the ellipse rotation in degrees\n * @param LAF the large arc flag\n * @param SF the sweep flag\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @param distance a [0-1] ratio\n * @returns a point along the Arc segment\n */\nexport const getPointAtArcLength = (\n  x1: number,\n  y1: number,\n  RX: number,\n  RY: number,\n  angle: number,\n  LAF: number,\n  SF: number,\n  x: number,\n  y: number,\n  distance?: number,\n) => {\n  let point = { x: x1, y: y1 };\n  const { center, rx, ry, startAngle, endAngle } = getArcProps(x1, y1, RX, RY, angle, LAF, SF, x, y);\n  const length = ellipticalArcLength(rx, ry, endAngle - startAngle);\n\n  /* istanbul ignore else @preserve */\n  if (typeof distance === 'number') {\n    if (distance <= 0) {\n      point = { x: x1, y: y1 };\n    } else if (distance >= length) {\n      point = { x, y };\n    } else {\n      /* istanbul ignore next @preserve */\n      if (x1 === x && y1 === y) {\n        return { x, y };\n      }\n      /* istanbul ignore next @preserve */\n      if (rx === 0 || ry === 0) {\n        return getPointAtLineLength(x1, y1, x, y, distance);\n      }\n      const { PI, cos, sin } = Math;\n      const sweepAngle = endAngle - startAngle;\n      const xRot = ((angle % 360) + 360) % 360;\n      const xRotRad = xRot * (PI / 180);\n      const alpha = startAngle + sweepAngle * (distance / length);\n      const ellipseComponentX = rx * cos(alpha);\n      const ellipseComponentY = ry * sin(alpha);\n\n      point = {\n        x: cos(xRotRad) * ellipseComponentX - sin(xRotRad) * ellipseComponentY + center.x,\n        y: sin(xRotRad) * ellipseComponentX + cos(xRotRad) * ellipseComponentY + center.y,\n      };\n    }\n  }\n\n  return point;\n};\n\n/**\n * Returns the bounding box for an Arc segment.\n * @see https://github.com/herrstrietzel/svg-pathdata-getbbox\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param RX the radius on X axis\n * @param RY the radius on Y axis\n * @param angle the ellipse rotation in degrees\n * @param LAF the large arc flag\n * @param SF the sweep flag\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @returns the extrema of the Arc segment\n *\n */\nexport const getArcBBox = (\n  x1: number,\n  y1: number,\n  RX: number,\n  RY: number,\n  angle: number,\n  LAF: number,\n  SF: number,\n  x: number,\n  y: number,\n) => {\n  const { center, rx, ry, startAngle, endAngle } = getArcProps(x1, y1, RX, RY, angle, LAF, SF, x, y);\n  const deltaAngle = endAngle - startAngle;\n\n  // final on path point\n  const p = { x, y };\n\n  // circle/elipse center coordinates\n  const [cx, cy] = [center.x, center.y];\n\n  // collect extreme points â€“ add end point\n  const extremes = [p];\n\n  // rotation to radians\n  const alpha = (angle * Math.PI) / 180;\n  const tan = Math.tan(alpha);\n\n  /**\n   * find min/max from zeroes of directional derivative along x and y\n   * along x axis\n   */\n  const theta = Math.atan2(-ry * tan, rx);\n  const angle1 = theta;\n  const angle2 = theta + Math.PI;\n  const angle3 = Math.atan2(ry, rx * tan);\n  const angle4 = angle3 + Math.PI;\n\n  // inner bounding box\n  const xArr = [x1, x];\n  const yArr = [y1, y];\n  const xMin = Math.min(...xArr);\n  const xMax = Math.max(...xArr);\n  const yMin = Math.min(...yArr);\n  const yMax = Math.max(...yArr);\n\n  // on path point close after start\n  const angleAfterStart = endAngle - deltaAngle * 0.001;\n  const pP2 = arc(angleAfterStart, cx, cy, rx, ry, alpha);\n\n  // on path point close before end\n  const angleBeforeEnd = endAngle - deltaAngle * 0.999;\n  const pP3 = arc(angleBeforeEnd, cx, cy, rx, ry, alpha);\n\n  /**\n   * expected extremes\n   * if leaving inner bounding box\n   * (between segment start and end point)\n   * otherwise exclude elliptic extreme points\n   */\n\n  // right\n  // istanbul ignore if @preserve\n  if (pP2.x > xMax || pP3.x > xMax) {\n    // get point for this theta\n    extremes.push(arc(angle1, cx, cy, rx, ry, alpha));\n  }\n\n  // left\n  // istanbul ignore if @preserve\n  if (pP2.x < xMin || pP3.x < xMin) {\n    // get anti-symmetric point\n    extremes.push(arc(angle2, cx, cy, rx, ry, alpha));\n  }\n\n  // top\n  // istanbul ignore if @preserve\n  if (pP2.y < yMin || pP3.y < yMin) {\n    // get anti-symmetric point\n    extremes.push(arc(angle4, cx, cy, rx, ry, alpha));\n  }\n\n  // bottom\n  // istanbul ignore if @preserve\n  if (pP2.y > yMax || pP3.y > yMax) {\n    // get point for this theta\n    extremes.push(arc(angle3, cx, cy, rx, ry, alpha));\n  }\n\n  return {\n    min: {\n      x: Math.min(...extremes.map(n => n.x)),\n      y: Math.min(...extremes.map(n => n.y)),\n    },\n    max: {\n      x: Math.max(...extremes.map(n => n.x)),\n      y: Math.max(...extremes.map(n => n.y)),\n    },\n  };\n};\n","import type {\n  PointTuple,\n  DerivedPoint,\n  QuadPoints,\n  CubicPoints,\n  DerivedQuadPoints,\n  DerivedCubicPoints,\n  QuadCoordinates,\n  CubicCoordinates,\n  DeriveCallback,\n} from '../types';\n\n/**\n * Tools from bezier.js by Mike 'Pomax' Kamermans\n * @see https://github.com/Pomax/bezierjs\n */\n\nconst ZERO = { x: 0, y: 0 };\n\nconst Tvalues = [\n  -0.0640568928626056260850430826247450385909, 0.0640568928626056260850430826247450385909,\n  -0.1911188674736163091586398207570696318404, 0.1911188674736163091586398207570696318404,\n  -0.3150426796961633743867932913198102407864, 0.3150426796961633743867932913198102407864,\n  -0.4337935076260451384870842319133497124524, 0.4337935076260451384870842319133497124524,\n  -0.5454214713888395356583756172183723700107, 0.5454214713888395356583756172183723700107,\n  -0.6480936519369755692524957869107476266696, 0.6480936519369755692524957869107476266696,\n  -0.7401241915785543642438281030999784255232, 0.7401241915785543642438281030999784255232,\n  -0.8200019859739029219539498726697452080761, 0.8200019859739029219539498726697452080761,\n  -0.8864155270044010342131543419821967550873, 0.8864155270044010342131543419821967550873,\n  -0.9382745520027327585236490017087214496548, 0.9382745520027327585236490017087214496548,\n  -0.9747285559713094981983919930081690617411, 0.9747285559713094981983919930081690617411,\n  -0.9951872199970213601799974097007368118745, 0.9951872199970213601799974097007368118745,\n];\n\nconst Cvalues = [\n  0.1279381953467521569740561652246953718517, 0.1279381953467521569740561652246953718517,\n  0.1258374563468282961213753825111836887264, 0.1258374563468282961213753825111836887264,\n  0.121670472927803391204463153476262425607, 0.121670472927803391204463153476262425607,\n  0.1155056680537256013533444839067835598622, 0.1155056680537256013533444839067835598622,\n  0.1074442701159656347825773424466062227946, 0.1074442701159656347825773424466062227946,\n  0.0976186521041138882698806644642471544279, 0.0976186521041138882698806644642471544279,\n  0.086190161531953275917185202983742667185, 0.086190161531953275917185202983742667185,\n  0.0733464814110803057340336152531165181193, 0.0733464814110803057340336152531165181193,\n  0.0592985849154367807463677585001085845412, 0.0592985849154367807463677585001085845412,\n  0.0442774388174198061686027482113382288593, 0.0442774388174198061686027482113382288593,\n  0.0285313886289336631813078159518782864491, 0.0285313886289336631813078159518782864491,\n  0.0123412297999871995468056670700372915759, 0.0123412297999871995468056670700372915759,\n];\n\n/**\n *\n * @param points\n * @returns\n */\nconst derive = (points: QuadPoints | CubicPoints) => {\n  const dpoints = [] as (DerivedCubicPoints | DerivedQuadPoints)[];\n  for (let p = points, d = p.length, c = d - 1; d > 1; d -= 1, c -= 1) {\n    const list = [] as unknown as DerivedCubicPoints | DerivedQuadPoints;\n    for (let j = 0; j < c; j += 1) {\n      list.push({\n        x: c * (p[j + 1].x - p[j].x),\n        y: c * (p[j + 1].y - p[j].y),\n        t: 0,\n      });\n    }\n    dpoints.push(list);\n    p = list;\n  }\n  return dpoints;\n};\n\n/**\n *\n * @param points\n * @param t\n */\nconst compute = (points: DerivedQuadPoints | DerivedCubicPoints, t: number) => {\n  // shortcuts\n  /* istanbul ignore next @preserve */\n  if (t === 0) {\n    points[0].t = 0;\n    return points[0];\n  }\n\n  const order = points.length - 1;\n\n  /* istanbul ignore next @preserve */\n  if (t === 1) {\n    points[order].t = 1;\n    return points[order];\n  }\n\n  const mt = 1 - t;\n  let p = points as typeof points | [DerivedPoint, DerivedPoint, DerivedPoint, DerivedPoint];\n\n  // constant?\n  /* istanbul ignore next @preserve */\n  if (order === 0) {\n    points[0].t = t;\n    return points[0];\n  }\n\n  // linear?\n  /* istanbul ignore else @preserve */\n  if (order === 1) {\n    return {\n      x: mt * p[0].x + t * p[1].x,\n      y: mt * p[0].y + t * p[1].y,\n      t,\n    };\n  }\n\n  // quadratic/cubic curve?\n  const mt2 = mt * mt;\n  const t2 = t * t;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  /* istanbul ignore else @preserve */\n  if (order === 2) {\n    p = [p[0], p[1], p[2], ZERO as DerivedPoint];\n    a = mt2;\n    b = mt * t * 2;\n    c = t2;\n  } else if (order === 3) {\n    a = mt2 * mt;\n    b = mt2 * t * 3;\n    c = mt * t2 * 3;\n    d = t * t2;\n  }\n  return {\n    x: a * p[0].x + b * p[1].x + c * p[2].x + d * p[3].x,\n    y: a * p[0].y + b * p[1].y + c * p[2].y + d * p[3].y,\n    t,\n  };\n};\n\nconst arcfn = (derivativeFn: DeriveCallback, t: number) => {\n  const d = derivativeFn(t);\n  const l = d.x * d.x + d.y * d.y;\n\n  return Math.sqrt(l);\n};\n\nconst lengthFn = (derivativeFn: DeriveCallback) => {\n  const z = 0.5;\n  const len = Tvalues.length;\n\n  let sum = 0;\n\n  for (let i = 0, t; i < len; i++) {\n    t = z * Tvalues[i] + z;\n    sum += Cvalues[i] * arcfn(derivativeFn, t);\n  }\n  return z * sum;\n};\n\n/**\n * Returns the length of CubicBezier / Quad segment.\n * @param curve cubic / quad bezier segment\n */\nexport const length = (curve: CubicCoordinates | QuadCoordinates) => {\n  const points = [] as unknown as CubicPoints | QuadPoints;\n  for (let idx = 0, len = curve.length, step = 2; idx < len; idx += step) {\n    points.push({\n      x: curve[idx],\n      y: curve[idx + 1],\n    });\n  }\n  const dpoints = derive(points);\n  return lengthFn((t: number) => {\n    return compute(dpoints[0], t);\n  });\n};\n\n// Precision for consider cubic polynom as quadratic one\nconst CBEZIER_MINMAX_EPSILON = 0.00000001;\n\n/**\n * Returns the most extreme points in a Quad Bezier segment.\n * @param A\n */\n// https://github.com/kpym/SVGPathy/blob/acd1a50c626b36d81969f6e98e8602e128ba4302/lib/box.js#L89\nexport const minmaxQ = (A: [number, number, number]) => {\n  const min = Math.min(A[0], A[2]);\n  const max = Math.max(A[0], A[2]);\n\n  /* istanbul ignore next @preserve */\n  if (A[1] >= A[0] ? A[2] >= A[1] : A[2] <= A[1]) {\n    // if no extremum in ]0,1[\n    return [min, max] as PointTuple;\n  }\n\n  // check if the extremum E is min or max\n  const E = (A[0] * A[2] - A[1] * A[1]) / (A[0] - 2 * A[1] + A[2]);\n  return (E < min ? [E, max] : [min, E]) as PointTuple;\n};\n\n/**\n * Returns the most extreme points in a Cubic Bezier segment.\n * @param A\n * @see https://github.com/kpym/SVGPathy/blob/acd1a50c626b36d81969f6e98e8602e128ba4302/lib/box.js#L127\n */\nexport const minmaxC = (A: [number, number, number, number]) => {\n  const K = A[0] - 3 * A[1] + 3 * A[2] - A[3];\n\n  // if the polynomial is (almost) quadratic and not cubic\n  /* istanbul ignore next @preserve */\n  if (Math.abs(K) < CBEZIER_MINMAX_EPSILON) {\n    if (A[0] === A[3] && A[0] === A[1]) {\n      // no curve, point targeting same location\n      return [A[0], A[3]] as PointTuple;\n    }\n\n    return minmaxQ([A[0], -0.5 * A[0] + 1.5 * A[1], A[0] - 3 * A[1] + 3 * A[2]]);\n  }\n\n  // the reduced discriminant of the derivative\n  const T = -A[0] * A[2] + A[0] * A[3] - A[1] * A[2] - A[1] * A[3] + A[1] * A[1] + A[2] * A[2];\n\n  // if the polynomial is monotone in [0,1]\n  if (T <= 0) {\n    return [Math.min(A[0], A[3]), Math.max(A[0], A[3])] as PointTuple;\n  }\n  const S = Math.sqrt(T);\n\n  // potential extrema\n  let min = Math.min(A[0], A[3]);\n  let max = Math.max(A[0], A[3]);\n\n  const L = A[0] - 2 * A[1] + A[2];\n  // check local extrema\n  for (let R = (L + S) / K, i = 1; i <= 2; R = (L - S) / K, i++) {\n    // istanbul ignore next @preserve\n    if (R > 0 && R < 1) {\n      // if the extrema is for R in [0,1]\n      const Q =\n        A[0] * (1 - R) * (1 - R) * (1 - R) +\n        A[1] * 3 * (1 - R) * (1 - R) * R +\n        A[2] * 3 * (1 - R) * R * R +\n        A[3] * R * R * R;\n      if (Q < min) {\n        min = Q;\n      }\n      if (Q > max) {\n        max = Q;\n      }\n    }\n  }\n\n  return [min, max] as PointTuple;\n};\n","import { length, minmaxC } from './bezier';\nimport { type CubicCoordinates } from '../types';\n\n/**\n * Returns a {x,y} point at a given length of a CubicBezier segment.\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param c1x the first control point X\n * @param c1y the first control point Y\n * @param c2x the second control point X\n * @param c2y the second control point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @param t a [0-1] ratio\n * @returns the point at cubic-bezier segment length\n */\nexport const getPointAtCubicSegmentLength = ([x1, y1, c1x, c1y, c2x, c2y, x2, y2]: CubicCoordinates, t: number) => {\n  const t1 = 1 - t;\n  return {\n    x: t1 ** 3 * x1 + 3 * t1 ** 2 * t * c1x + 3 * t1 * t ** 2 * c2x + t ** 3 * x2,\n    y: t1 ** 3 * y1 + 3 * t1 ** 2 * t * c1y + 3 * t1 * t ** 2 * c2y + t ** 3 * y2,\n  };\n};\n\n/**\n * Returns the length of a CubicBezier segment.\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param c1x the first control point X\n * @param c1y the first control point Y\n * @param c2x the second control point X\n * @param c2y the second control point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @returns the CubicBezier segment length\n */\nexport const getCubicLength = (\n  x1: number,\n  y1: number,\n  c1x: number,\n  c1y: number,\n  c2x: number,\n  c2y: number,\n  x2: number,\n  y2: number,\n) => {\n  return length([x1, y1, c1x, c1y, c2x, c2y, x2, y2]);\n};\n\n/**\n * Returns the point along a CubicBezier segment at a given distance.\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param c1x the first control point X\n * @param c1y the first control point Y\n * @param c2x the second control point X\n * @param c2y the second control point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @param distance the distance to look at\n * @returns the point at CubicBezier length\n */\nexport const getPointAtCubicLength = (\n  x1: number,\n  y1: number,\n  c1x: number,\n  c1y: number,\n  c2x: number,\n  c2y: number,\n  x2: number,\n  y2: number,\n  distance?: number,\n) => {\n  const distanceIsNumber = typeof distance === 'number';\n  let point = { x: x1, y: y1 };\n  /* istanbul ignore else @preserve */\n  if (distanceIsNumber) {\n    const currentLength = length([x1, y1, c1x, c1y, c2x, c2y, x2, y2]);\n    if (distance <= 0) {\n      // first point already defined\n    } else if (distance >= currentLength) {\n      point = { x: x2, y: y2 };\n    } else {\n      point = getPointAtCubicSegmentLength([x1, y1, c1x, c1y, c2x, c2y, x2, y2], distance / currentLength);\n    }\n  }\n  return point;\n};\n\n/**\n * Returns the boundig box of a CubicBezier segment.\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param c1x the first control point X\n * @param c1y the first control point Y\n * @param c2x the second control point X\n * @param c2y the second control point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @returns the point at CubicBezier length\n */\nexport const getCubicBBox = (\n  x1: number,\n  y1: number,\n  c1x: number,\n  c1y: number,\n  c2x: number,\n  c2y: number,\n  x2: number,\n  y2: number,\n) => {\n  const cxMinMax = minmaxC([x1, c1x, c2x, x2]);\n  const cyMinMax = minmaxC([y1, c1y, c2y, y2]);\n  return {\n    min: { x: cxMinMax[0], y: cyMinMax[0] },\n    max: { x: cxMinMax[1], y: cyMinMax[1] },\n  };\n};\n","import { length, minmaxQ } from './bezier';\nimport { type QuadCoordinates } from '../types';\n\n/**\n * Returns the {x,y} coordinates of a point at a\n * given length of a quadratic-bezier segment.\n *\n * @see https://github.com/substack/point-at-length\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param cx the control point X\n * @param cy the control point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @param t a [0-1] ratio\n * @returns the requested {x,y} coordinates\n */\nconst getPointAtQuadSegmentLength = ([x1, y1, cx, cy, x2, y2]: QuadCoordinates, t: number) => {\n  const t1 = 1 - t;\n  return {\n    x: t1 ** 2 * x1 + 2 * t1 * t * cx + t ** 2 * x2,\n    y: t1 ** 2 * y1 + 2 * t1 * t * cy + t ** 2 * y2,\n  };\n};\n\n/**\n * Returns the length of a QuadraticBezier segment.\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param cx the control point X\n * @param cy the control point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @returns the QuadraticBezier segment length\n */\nexport const getQuadLength = (x1: number, y1: number, cx: number, cy: number, x2: number, y2: number) => {\n  return length([x1, y1, cx, cy, x2, y2]);\n};\n\n/**\n * Returns the point along a QuadraticBezier segment at a given distance.\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param cx the control point X\n * @param cy the control point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @param distance the distance to look at\n * @returns the point at QuadraticBezier length\n */\nexport const getPointAtQuadLength = (\n  x1: number,\n  y1: number,\n  cx: number,\n  cy: number,\n  x2: number,\n  y2: number,\n  distance?: number,\n) => {\n  const distanceIsNumber = typeof distance === 'number';\n  let point = { x: x1, y: y1 };\n\n  /* istanbul ignore else @preserve */\n  if (distanceIsNumber) {\n    const currentLength = length([x1, y1, cx, cy, x2, y2]);\n    if (distance <= 0) {\n      // first point already defined\n    } else if (distance >= currentLength) {\n      point = { x: x2, y: y2 };\n    } else {\n      point = getPointAtQuadSegmentLength([x1, y1, cx, cy, x2, y2], distance / currentLength);\n    }\n  }\n  return point;\n};\n\n/**\n * Returns the boundig box of a QuadraticBezier segment.\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param cx the control point X\n * @param cy the control point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @returns the point at CubicBezier length\n */\nexport const getQuadBBox = (x1: number, y1: number, cx: number, cy: number, x2: number, y2: number) => {\n  const cxMinMax = minmaxQ([x1, cx, x2]);\n  const cyMinMax = minmaxQ([y1, cy, y2]);\n  return {\n    min: { x: cxMinMax[0], y: cyMinMax[0] },\n    max: { x: cxMinMax[1], y: cyMinMax[1] },\n  };\n};\n","import iterate from '../process/iterate';\nimport { PathBBox } from '../interface';\nimport {\n  ArcCoordinates,\n  CubicCoordinates,\n  LineCoordinates,\n  MSegment,\n  PathArray,\n  Point,\n  PointTuple,\n  QuadCoordinates,\n} from '../types';\n// import pathFactory from './pathFactory';\nimport absolutizeSegment from '../process/absolutizeSegment';\nimport normalizeSegment from '../process/normalizeSegment';\nimport parsePathString from '../parser/parsePathString';\nimport { getLineBBox } from '../math/lineTools';\nimport { getArcBBox } from '../math/arcTools';\nimport { getCubicBBox } from '../math/cubicTools';\nimport { getQuadBBox } from '../math/quadTools';\n\nconst getPathBBox = (pathInput: PathArray | string) => {\n  if (!pathInput) {\n    return {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0,\n      x2: 0,\n      y2: 0,\n      cx: 0,\n      cy: 0,\n      cz: 0,\n    };\n  }\n\n  const path = parsePathString(pathInput);\n  let data = [] as number[];\n  let pathCommand = 'M';\n  let x = 0;\n  let y = 0;\n  let mx = 0;\n  let my = 0;\n  const MIN = [] as Point[];\n  const MAX = [] as Point[];\n  let min = { x, y };\n  let max = { x, y };\n\n  iterate(path, (seg, params) => {\n    const absoluteSegment = absolutizeSegment(seg, params);\n    const normalSegment = normalizeSegment(absoluteSegment, params);\n    [pathCommand] = normalSegment;\n    data = [x, y, ...normalSegment.slice(1)] as number[];\n\n    // this segment is always ZERO\n    /* istanbul ignore else @preserve */\n    if (pathCommand === 'M') {\n      // remember mx, my for Z\n      [, mx, my] = normalSegment as MSegment;\n      min = { x: mx, y: my };\n      max = { x: mx, y: my };\n    } else if (pathCommand === 'L') {\n      ({ min, max } = getLineBBox(...(data as LineCoordinates)));\n    } else if (pathCommand === 'A') {\n      ({ min, max } = getArcBBox(...(data as ArcCoordinates)));\n    } else if (pathCommand === 'C') {\n      ({ min, max } = getCubicBBox(...(data as CubicCoordinates)));\n    } else if (pathCommand === 'Q') {\n      ({ min, max } = getQuadBBox(...(data as QuadCoordinates)));\n    } else if (pathCommand === 'Z') {\n      data = [x, y, mx, my];\n      ({ min, max } = getLineBBox(...(data as LineCoordinates)));\n    }\n\n    MIN.push(min);\n    MAX.push(max);\n\n    if (pathCommand === 'Z') {\n      x = mx;\n      y = my;\n    } else {\n      [x, y] = normalSegment.slice(-2) as PointTuple;\n\n      if (pathCommand === 'M') {\n        mx = x;\n        my = y;\n      }\n    }\n    params.x = x;\n    params.y = y;\n    return normalSegment;\n  });\n\n  const xMin = Math.min(...MIN.map(n => n.x));\n  const xMax = Math.max(...MAX.map(n => n.x));\n  const yMin = Math.min(...MIN.map(n => n.y));\n  const yMax = Math.max(...MAX.map(n => n.y));\n  const width = xMax - xMin;\n  const height = yMax - yMin;\n\n  return {\n    width,\n    height,\n    x: xMin,\n    y: yMin,\n    x2: xMax,\n    y2: yMax,\n    cx: xMin + width / 2,\n    cy: yMin + height / 2,\n    // an estimated guess\n    cz: Math.max(width, height) + Math.min(width, height) / 2,\n  } satisfies PathBBox;\n};\n\nexport default getPathBBox;\n","/**\n * Returns an {x,y} vector rotated by a given\n * angle in radian.\n *\n * @param x the initial vector x\n * @param y the initial vector y\n * @param rad the radian vector angle\n * @returns the rotated vector\n */\nconst rotateVector = (x: number, y: number, rad: number): { x: number; y: number } => {\n  const X = x * Math.cos(rad) - y * Math.sin(rad);\n  const Y = x * Math.sin(rad) + y * Math.cos(rad);\n  return { x: X, y: Y };\n};\n\nexport default rotateVector;\n","import rotateVector from '../math/rotateVector';\n\n/**\n * Converts A (arc-to) segments to C (cubic-bezier-to).\n *\n * For more information of where this math came from visit:\n * http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n *\n * @param X1 the starting x position\n * @param Y1 the starting y position\n * @param RX x-radius of the arc\n * @param RY y-radius of the arc\n * @param angle x-axis-rotation of the arc\n * @param LAF large-arc-flag of the arc\n * @param SF sweep-flag of the arc\n * @param X2 the ending x position\n * @param Y2 the ending y position\n * @param recursive the parameters needed to split arc into 2 segments\n * @return the resulting cubic-bezier segment(s)\n */\nconst arcToCubic = (\n  X1: number,\n  Y1: number,\n  RX: number,\n  RY: number,\n  angle: number,\n  LAF: number,\n  SF: number,\n  X2: number,\n  Y2: number,\n  recursive?: [number, number, number, number],\n): number[] => {\n  let x1 = X1;\n  let y1 = Y1;\n  let rx = RX;\n  let ry = RY;\n  let x2 = X2;\n  let y2 = Y2;\n  // for more information of where this Math came from visit:\n  // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n  const d120 = (Math.PI * 120) / 180;\n\n  const rad = (Math.PI / 180) * (+angle || 0);\n  let res = [] as number[];\n  let xy;\n  let f1;\n  let f2;\n  let cx;\n  let cy;\n\n  if (!recursive) {\n    xy = rotateVector(x1, y1, -rad);\n    x1 = xy.x;\n    y1 = xy.y;\n    xy = rotateVector(x2, y2, -rad);\n    x2 = xy.x;\n    y2 = xy.y;\n\n    const x = (x1 - x2) / 2;\n    const y = (y1 - y2) / 2;\n    let h = (x * x) / (rx * rx) + (y * y) / (ry * ry);\n    if (h > 1) {\n      h = Math.sqrt(h);\n      rx *= h;\n      ry *= h;\n    }\n    const rx2 = rx * rx;\n    const ry2 = ry * ry;\n\n    const k =\n      (LAF === SF ? -1 : 1) *\n      Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));\n\n    cx = (k * rx * y) / ry + (x1 + x2) / 2;\n    cy = (k * -ry * x) / rx + (y1 + y2) / 2;\n    // eslint-disable-next-line no-bitwise -- Impossible to satisfy no-bitwise\n    f1 = Math.asin(((((y1 - cy) / ry) * 10 ** 9) >> 0) / 10 ** 9);\n    // eslint-disable-next-line no-bitwise -- Impossible to satisfy no-bitwise\n    f2 = Math.asin(((((y2 - cy) / ry) * 10 ** 9) >> 0) / 10 ** 9);\n\n    f1 = x1 < cx ? Math.PI - f1 : f1;\n    f2 = x2 < cx ? Math.PI - f2 : f2;\n    if (f1 < 0) f1 = Math.PI * 2 + f1;\n    if (f2 < 0) f2 = Math.PI * 2 + f2;\n    if (SF && f1 > f2) {\n      f1 -= Math.PI * 2;\n    }\n    if (!SF && f2 > f1) {\n      f2 -= Math.PI * 2;\n    }\n  } else {\n    [f1, f2, cx, cy] = recursive;\n  }\n  let df = f2 - f1;\n  if (Math.abs(df) > d120) {\n    const f2old = f2;\n    const x2old = x2;\n    const y2old = y2;\n    f2 = f1 + d120 * (SF && f2 > f1 ? 1 : -1);\n    x2 = cx + rx * Math.cos(f2);\n    y2 = cy + ry * Math.sin(f2);\n    res = arcToCubic(x2, y2, rx, ry, angle, 0, SF, x2old, y2old, [f2, f2old, cx, cy]);\n  }\n  df = f2 - f1;\n  const c1 = Math.cos(f1);\n  const s1 = Math.sin(f1);\n  const c2 = Math.cos(f2);\n  const s2 = Math.sin(f2);\n  const t = Math.tan(df / 4);\n  const hx = (4 / 3) * rx * t;\n  const hy = (4 / 3) * ry * t;\n  const m1 = [x1, y1];\n  const m2 = [x1 + hx * s1, y1 - hy * c1];\n  const m3 = [x2 + hx * s2, y2 - hy * c2];\n  const m4 = [x2, y2];\n  m2[0] = 2 * m1[0] - m2[0];\n  m2[1] = 2 * m1[1] - m2[1];\n  if (recursive) {\n    return [...m2, ...m3, ...m4, ...res];\n  }\n  res = [...m2, ...m3, ...m4, ...res];\n  const newres = [];\n  for (let i = 0, ii = res.length; i < ii; i += 1) {\n    newres[i] = i % 2 ? rotateVector(res[i - 1], res[i], rad).y : rotateVector(res[i], res[i + 1], rad).x;\n  }\n  return newres;\n};\nexport default arcToCubic;\n","/**\n * Converts a Q (quadratic-bezier) segment to C (cubic-bezier).\n *\n * @param x1 curve start x\n * @param y1 curve start y\n * @param qx control point x\n * @param qy control point y\n * @param x2 curve end x\n * @param y2 curve end y\n * @returns the cubic-bezier segment\n */\nconst quadToCubic = (\n  x1: number,\n  y1: number,\n  qx: number,\n  qy: number,\n  x2: number,\n  y2: number,\n): [number, number, number, number, number, number] => {\n  const r13 = 1 / 3;\n  const r23 = 2 / 3;\n  return [\n    r13 * x1 + r23 * qx, // cpx1\n    r13 * y1 + r23 * qy, // cpy1\n    r13 * x2 + r23 * qx, // cpx2\n    r13 * y2 + r23 * qy, // cpy2\n    x2,\n    y2, // x,y\n  ];\n};\nexport default quadToCubic;\n","import midPoint from '../math/midPoint';\n\n/**\n * Converts an L (line-to) segment to C (cubic-bezier).\n *\n * @param x1 line start x\n * @param y1 line start y\n * @param x2 line end x\n * @param y2 line end y\n * @returns the cubic-bezier segment\n */\nconst lineToCubic = (x1: number, y1: number, x2: number, y2: number) => {\n  const c1 = midPoint([x1, y1], [x2, y2], 1.0 / 3.0);\n  const c2 = midPoint([x1, y1], [x2, y2], 2.0 / 3.0);\n  return [...c1, ...c2, x2, y2];\n};\nexport default lineToCubic;\n","import arcToCubic from './arcToCubic';\nimport quadToCubic from './quadToCubic';\nimport lineToCubic from './lineToCubic';\nimport type { CSegment, MSegment, PathSegment } from '../types';\nimport type { ParserParams } from '../interface';\n\n/**\n * Converts any segment to C (cubic-bezier).\n *\n * @param segment the source segment\n * @param params the source segment parameters\n * @returns the cubic-bezier segment\n */\nconst segmentToCubic = (segment: PathSegment, params: ParserParams) => {\n  const [pathCommand] = segment;\n  const values = segment.slice(1).map(Number);\n  const [x, y] = values;\n  let args;\n  const { x1: px1, y1: py1, x: px, y: py } = params;\n\n  if (!'TQ'.includes(pathCommand)) {\n    params.qx = null;\n    params.qy = null;\n  }\n\n  if (pathCommand === 'M') {\n    params.x = x;\n    params.y = y;\n    return segment;\n  } else if (pathCommand === 'A') {\n    args = [px1, py1, ...values] as [number, number, number, number, number, number, number, number, number];\n    return ['C', ...arcToCubic(...args)] as CSegment;\n  } else if (pathCommand === 'Q') {\n    params.qx = x;\n    params.qy = y;\n    args = [px1, py1, ...values] as [number, number, number, number, number, number];\n    return ['C', ...quadToCubic(...args)] as CSegment;\n  } else if (pathCommand === 'L') {\n    return ['C', ...lineToCubic(px1, py1, x, y)] as CSegment;\n  } else if (pathCommand === 'Z') {\n    return ['C', ...lineToCubic(px1, py1, px, py)] as CSegment;\n  }\n\n  return segment as MSegment | CSegment;\n};\nexport default segmentToCubic;\n","import segmentToCubic from '../process/segmentToCubic';\nimport { AbsoluteCommand, CSegment, CurveArray, PathArray, PointTuple } from '../types';\nimport iterate from '../process/iterate';\nimport parsePathString from '../parser/parsePathString';\nimport normalizeSegment from '../process/normalizeSegment';\nimport absolutizeSegment from '../process/absolutizeSegment';\n\n/**\n * Parses a path string value or 'pathArray' and returns a new one\n * in which all segments are converted to cubic-bezier.\n *\n * In addition, un-necessary `Z` segment is removed if previous segment\n * extends to the `M` segment.\n *\n * @param pathInput the string to be parsed or 'pathArray'\n * @returns the resulted `pathArray` converted to cubic-bezier\n */\nconst pathToCurve = (pathInput: string | PathArray): CurveArray => {\n  let x = 0;\n  let y = 0;\n  let mx = 0;\n  let my = 0;\n  let pathCommand = 'M';\n\n  const path = parsePathString(pathInput);\n  return iterate<CurveArray>(path, (seg, params, i) => {\n    const absSegment = absolutizeSegment(seg, params);\n    [pathCommand] = absSegment;\n\n    const absCommand = pathCommand.toUpperCase() as AbsoluteCommand;\n    const normalSegment = normalizeSegment(absSegment, params);\n    let result = segmentToCubic(normalSegment, params);\n    const isLongArc = result[0] === 'C' && result.length > 7;\n\n    if (isLongArc) {\n      path.splice(i + 1, 0, ['C', ...result.slice(7)] as CSegment);\n      result = result.slice(0, 7) as CSegment;\n    }\n\n    if (absCommand === 'Z') {\n      x = mx;\n      y = my;\n    } else {\n      [x, y] = result.slice(-2) as PointTuple;\n\n      if (absCommand === 'M') {\n        mx = x;\n        my = y;\n      }\n    }\n\n    params.x = x;\n    params.y = y;\n    return result;\n  });\n};\nexport default pathToCurve;\n","import pathToCurve from '../convert/pathToCurve';\nimport type { PointTuple, PathArray, QuadCoordinates } from '../types';\n\n/**\n * Returns the area of a single cubic-bezier segment.\n *\n * http://objectmix.com/graphics/133553-area-closed-bezier-curve.html\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param c1x the first control point X\n * @param c1y the first control point Y\n * @param c2x the second control point X\n * @param c2y the second control point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @returns the area of the cubic-bezier segment\n */\nconst getCubicSegArea = (\n  x1: number,\n  y1: number,\n  c1x: number,\n  c1y: number,\n  c2x: number,\n  c2y: number,\n  x2: number,\n  y2: number,\n) => {\n  return (\n    (3 *\n      ((y2 - y1) * (c1x + c2x) -\n        (x2 - x1) * (c1y + c2y) +\n        c1y * (x1 - c2x) -\n        c1x * (y1 - c2y) +\n        y2 * (c2x + x1 / 3) -\n        x2 * (c2y + y1 / 3))) /\n    20\n  );\n};\n\n/**\n * Returns the area of a shape.\n *\n * @author JÃ¼rg Lehni & Jonathan Puckey\n *\n * @see https://github.com/paperjs/paper.js/blob/develop/src/path/Path.js\n *\n * @param path the shape `pathArray`\n * @returns the length of the cubic-bezier segment\n */\nconst getPathArea = (path: PathArray) => {\n  let x = 0;\n  let y = 0;\n  let len = 0;\n\n  return pathToCurve(path)\n    .map(seg => {\n      switch (seg[0]) {\n        case 'M':\n          [, x, y] = seg;\n          return 0;\n        default:\n          len = getCubicSegArea(x, y, ...(seg.slice(1) as QuadCoordinates));\n          [x, y] = seg.slice(-2) as PointTuple;\n          return len;\n      }\n    })\n    .reduce((a, b) => a + b, 0);\n};\nexport default getPathArea;\n","import parsePathString from '../parser/parsePathString';\nimport type {\n  ArcCoordinates,\n  CubicCoordinates,\n  LineCoordinates,\n  MSegment,\n  PathArray,\n  PointTuple,\n  QuadCoordinates,\n} from '../types';\nimport { getLineLength } from '../math/lineTools';\nimport { getArcLength } from '../math/arcTools';\nimport { getCubicLength } from '../math/cubicTools';\nimport { getQuadLength } from '../math/quadTools';\nimport iterate from '../process/iterate';\nimport absolutizeSegment from '../process/absolutizeSegment';\nimport normalizeSegment from '../process/normalizeSegment';\n// import pathFactory from './pathFactory';\n\n/**\n * Returns the shape total length, or the equivalent to `shape.getTotalLength()`.\n *\n * The `normalizePath` version is lighter, faster, more efficient and more accurate\n * with paths that are not `curveArray`.\n *\n * @param pathInput the target `pathArray`\n * @returns the shape total length\n */\nconst getTotalLength = (pathInput: string | PathArray) => {\n  const path = parsePathString(pathInput);\n  let isM = false;\n  let data = [] as number[];\n  let pathCommand = 'M';\n  let x = 0;\n  let y = 0;\n  let mx = 0;\n  let my = 0;\n  let totalLength = 0;\n\n  iterate(path, (seg, params) => {\n    const absoluteSegment = absolutizeSegment(seg, params);\n    const normalSegment = normalizeSegment(absoluteSegment, params);\n    [pathCommand] = normalSegment;\n    isM = pathCommand === 'M';\n    data = !isM ? [x, y, ...(normalSegment.slice(1) as number[])] : data;\n\n    // this segment is always ZERO\n    /* istanbul ignore else @preserve */\n    if (isM) {\n      // remember mx, my for Z\n      [, mx, my] = seg as MSegment;\n    } else if (pathCommand === 'L') {\n      totalLength += getLineLength(...(data as LineCoordinates));\n    } else if (pathCommand === 'A') {\n      totalLength += getArcLength(...(data as ArcCoordinates));\n    } else if (pathCommand === 'C') {\n      totalLength += getCubicLength(...(data as CubicCoordinates));\n    } else if (pathCommand === 'Q') {\n      totalLength += getQuadLength(...(data as QuadCoordinates));\n    } else if (pathCommand === 'Z') {\n      data = [x, y, mx, my];\n      totalLength += getLineLength(...(data as LineCoordinates));\n    }\n    if (pathCommand === 'Z') {\n      x = mx;\n      y = my;\n    } else {\n      [x, y] = normalSegment.slice(-2) as PointTuple;\n\n      if (isM) {\n        mx = x;\n        my = y;\n      }\n    }\n    params.x = x;\n    params.y = y;\n    return normalSegment;\n  });\n\n  return totalLength;\n};\n\nexport default getTotalLength;\n","import getPathArea from './getPathArea';\nimport pathToCurve from '../convert/pathToCurve';\nimport type { PathArray } from '../types';\n\n/**\n * Check if a path is drawn clockwise and returns true if so,\n * false otherwise.\n *\n * @param path the path string or `pathArray`\n * @returns true when clockwise or false if not\n */\nconst getDrawDirection = (path: string | PathArray) => {\n  return getPathArea(pathToCurve(path)) >= 0;\n};\n\nexport default getDrawDirection;\n","const DISTANCE_EPSILON = 0.00001;\n\nexport default DISTANCE_EPSILON;\n","import DISTANCE_EPSILON from './distanceEpsilon';\nimport parsePathString from '../parser/parsePathString';\nimport type {\n  ArcCoordinates,\n  CubicCoordinates,\n  LineCoordinates,\n  MSegment,\n  PathArray,\n  PointTuple,\n  QuadCoordinates,\n} from '../types';\nimport iterate from '../process/iterate';\nimport absolutizeSegment from '../process/absolutizeSegment';\nimport normalizeSegment from '../process/normalizeSegment';\nimport { getLineLength, getPointAtLineLength } from '../math/lineTools';\nimport { getArcLength, getPointAtArcLength } from '../math/arcTools';\nimport { getCubicLength, getPointAtCubicLength } from '../math/cubicTools';\nimport { getQuadLength, getPointAtQuadLength } from '../math/quadTools';\n\n/**\n * Returns [x,y] coordinates of a point at a given length of a shape.\n *\n * @param pathInput the `pathArray` to look into\n * @param distance the length of the shape to look at\n * @returns the requested {x, y} point coordinates\n */\nconst getPointAtLength = (pathInput: string | PathArray, distance?: number) => {\n  const path = parsePathString(pathInput);\n  let isM = false;\n  let data = [] as number[];\n  let pathCommand = 'M';\n  let x = 0;\n  let y = 0;\n  let [mx, my] = path[0].slice(1) as PointTuple;\n  const distanceIsNumber = typeof distance === 'number';\n  let point = { x: mx, y: my };\n  let length = 0;\n  let POINT = point;\n  let totalLength = 0;\n\n  if (!distanceIsNumber) return point;\n\n  if (distance < DISTANCE_EPSILON) {\n    POINT = point;\n  }\n\n  iterate(path, (seg, params) => {\n    const absoluteSegment = absolutizeSegment(seg, params);\n    const normalSegment = normalizeSegment(absoluteSegment, params);\n    [pathCommand] = normalSegment;\n    isM = pathCommand === 'M';\n    data = !isM ? [x, y, ...(normalSegment.slice(1) as number[])] : data;\n\n    // this segment is always ZERO\n    /* istanbul ignore else @preserve */\n    if (isM) {\n      // remember mx, my for Z\n      [, mx, my] = seg as MSegment;\n      point = { x: mx, y: my };\n      length = 0;\n    } else if (pathCommand === 'L') {\n      point = getPointAtLineLength(...(data as LineCoordinates), distance - totalLength);\n      length = getLineLength(...(data as LineCoordinates));\n    } else if (pathCommand === 'A') {\n      point = getPointAtArcLength(...(data as ArcCoordinates), distance - totalLength);\n      length = getArcLength(...(data as ArcCoordinates));\n    } else if (pathCommand === 'C') {\n      point = getPointAtCubicLength(...(data as CubicCoordinates), distance - totalLength);\n      length = getCubicLength(...(data as CubicCoordinates));\n    } else if (pathCommand === 'Q') {\n      point = getPointAtQuadLength(...(data as QuadCoordinates), distance - totalLength);\n      length = getQuadLength(...(data as QuadCoordinates));\n    } else if (pathCommand === 'Z') {\n      data = [x, y, mx, my];\n      point = { x: mx, y: my };\n      length = getLineLength(...(data as LineCoordinates));\n    }\n\n    if (totalLength < distance && totalLength + length >= distance) {\n      POINT = point;\n    }\n\n    totalLength += length;\n    if (pathCommand === 'Z') {\n      x = mx;\n      y = my;\n    } else {\n      [x, y] = normalSegment.slice(-2) as PointTuple;\n\n      if (pathCommand === 'M') {\n        mx = x;\n        my = y;\n      }\n    }\n    params.x = x;\n    params.y = y;\n    return normalSegment;\n  });\n\n  // native `getPointAtLength` behavior when the given distance\n  // is higher than total length\n  if (distance > totalLength - DISTANCE_EPSILON) {\n    POINT = { x, y };\n  }\n\n  return POINT;\n};\nexport default getPointAtLength;\n","import type { PointTuple, PathArray, PathSegment } from '../types';\nimport type { SegmentProperties } from '../interface';\nimport parsePathString from '../parser/parsePathString';\nimport getTotalLength from './getTotalLength';\n\n/**\n * Returns the segment, its index and length as well as\n * the length to that segment at a given length in a path.\n *\n * @param pathInput target `pathArray`\n * @param distance the given length\n * @returns the requested properties\n */\nconst getPropertiesAtLength = (pathInput: string | PathArray, distance?: number): SegmentProperties => {\n  const pathArray = parsePathString(pathInput);\n\n  let pathTemp = pathArray.slice(0) as PathArray;\n  let pathLength = getTotalLength(pathTemp);\n  let index = pathTemp.length - 1;\n  let lengthAtSegment = 0;\n  let length = 0;\n  let segment = pathArray[0] as PathSegment;\n  const [x, y] = segment.slice(-2) as PointTuple;\n  const point = { x, y };\n\n  // If the path is empty, return 0.\n  if (index <= 0 || !distance || !Number.isFinite(distance)) {\n    return {\n      segment,\n      index: 0,\n      length,\n      point,\n      lengthAtSegment,\n    };\n  }\n\n  if (distance >= pathLength) {\n    pathTemp = pathArray.slice(0, -1) as PathArray;\n    lengthAtSegment = getTotalLength(pathTemp);\n    length = pathLength - lengthAtSegment;\n    return {\n      segment: pathArray[index],\n      index,\n      length,\n      lengthAtSegment,\n    };\n  }\n\n  const segments = [] as SegmentProperties[];\n  while (index > 0) {\n    segment = pathTemp[index];\n    pathTemp = pathTemp.slice(0, -1) as PathArray;\n    lengthAtSegment = getTotalLength(pathTemp);\n    length = pathLength - lengthAtSegment;\n    pathLength = lengthAtSegment;\n    segments.push({\n      segment,\n      index,\n      length,\n      lengthAtSegment,\n    });\n    index -= 1;\n  }\n\n  return segments.find(({ lengthAtSegment: l }) => l <= distance) as SegmentProperties;\n};\n\nexport default getPropertiesAtLength;\n","import normalizeSegment from './normalizeSegment';\nimport type { AbsoluteCommand, NormalArray, PathArray, PointTuple } from '../types';\nimport iterate from './iterate';\nimport parsePathString from '../parser/parsePathString';\nimport absolutizeSegment from './absolutizeSegment';\n\n/**\n * Normalizes a `path` object for further processing:\n * * convert segments to absolute values\n * * convert shorthand path commands to their non-shorthand notation\n *\n * @param pathInput the string to be parsed or 'pathArray'\n * @returns the normalized `pathArray`\n */\nconst normalizePath = (pathInput: string | PathArray) => {\n  let x = 0;\n  let y = 0;\n  let mx = 0;\n  let my = 0;\n  let pathCommand = 'M';\n\n  return iterate<NormalArray>(parsePathString(pathInput), (seg, params) => {\n    const absoluteSegment = absolutizeSegment(seg, params);\n    const result = normalizeSegment(absoluteSegment, params);\n    [pathCommand] = result;\n    const absCommand = pathCommand.toUpperCase() as AbsoluteCommand;\n\n    if (absCommand === 'Z') {\n      x = mx;\n      y = my;\n    } else {\n      [x, y] = result.slice(-2) as PointTuple;\n\n      if (absCommand === 'M') {\n        mx = x;\n        my = y;\n      }\n    }\n\n    // const seglen = result.length;\n    // params.x1 = +result[seglen - 2];\n    // params.y1 = +result[seglen - 1];\n    // params.x2 = +result[seglen - 4] || params.x1;\n    // params.y2 = +result[seglen - 3] || params.y1;\n    params.x = x;\n    params.y = y;\n    return result;\n  });\n};\nexport default normalizePath;\n","import type { PathArray } from '../types';\nimport type { PointProperties } from '../interface';\nimport getPointAtLength from './getPointAtLength';\nimport getPropertiesAtLength from './getPropertiesAtLength';\nimport getTotalLength from './getTotalLength';\nimport parsePathString from '../parser/parsePathString';\nimport normalizePath from '../process/normalizePath';\n\n/**\n * Returns the point and segment in path closest to a given point as well as\n * the distance to the path stroke.\n *\n * @see https://bl.ocks.org/mbostock/8027637\n *\n * @param pathInput target `pathArray`\n * @param point the given point\n * @returns the requested properties\n */\nconst getPropertiesAtPoint = (pathInput: string | PathArray, point: { x: number; y: number }): PointProperties => {\n  const path = parsePathString(pathInput);\n  const normalPath = normalizePath(path);\n  const pathLength = getTotalLength(path);\n  const distanceTo = (p: { x: number; y: number }) => {\n    const dx = p.x - point.x;\n    const dy = p.y - point.y;\n    return dx * dx + dy * dy;\n  };\n  let precision = 8;\n  let scan: { x: number; y: number };\n  let closest = { x: 0, y: 0 }; // make TS happy\n  let scanDistance = 0;\n  let bestLength = 0;\n  let bestDistance = Infinity;\n\n  // linear scan for coarse approximation\n  for (let scanLength = 0; scanLength <= pathLength; scanLength += precision) {\n    scan = getPointAtLength(normalPath, scanLength);\n    scanDistance = distanceTo(scan);\n\n    if (scanDistance < bestDistance) {\n      closest = scan;\n      bestLength = scanLength;\n      bestDistance = scanDistance;\n    }\n  }\n\n  // binary search for precise estimate\n  precision /= 2;\n  let before: { x: number; y: number };\n  let after: { x: number; y: number };\n  let beforeLength = 0;\n  let afterLength = 0;\n  let beforeDistance = 0;\n  let afterDistance = 0;\n\n  while (precision > 0.000001) {\n    beforeLength = bestLength - precision;\n    before = getPointAtLength(normalPath, beforeLength);\n    beforeDistance = distanceTo(before);\n    afterLength = bestLength + precision;\n    after = getPointAtLength(normalPath, afterLength);\n    afterDistance = distanceTo(after);\n\n    if (beforeLength >= 0 && beforeDistance < bestDistance) {\n      closest = before;\n      bestLength = beforeLength;\n      bestDistance = beforeDistance;\n    } else if (afterLength <= pathLength && afterDistance < bestDistance) {\n      closest = after;\n      bestLength = afterLength;\n      bestDistance = afterDistance;\n    } else {\n      precision /= 2;\n    }\n    if (precision < 0.00001) break;\n  }\n\n  const segment = getPropertiesAtLength(path, bestLength);\n  const distance = Math.sqrt(bestDistance);\n\n  return { closest, distance, segment };\n};\n\nexport default getPropertiesAtPoint;\n","import type { PathArray } from '../types';\nimport getPropertiesAtPoint from './getPropertiesAtPoint';\n\n/**\n * Returns the point in path closest to a given point.\n *\n * @param pathInput target `pathArray`\n * @param point the given point\n * @returns the best match\n */\nconst getClosestPoint = (pathInput: string | PathArray, point: { x: number; y: number }) => {\n  return getPropertiesAtPoint(pathInput, point).closest;\n};\n\nexport default getClosestPoint;\n","import type { SegmentProperties } from '../interface';\nimport type { PathArray } from '../types';\nimport getPropertiesAtPoint from './getPropertiesAtPoint';\n\n/**\n * Returns the path segment which contains a given point.\n *\n * @param path the `pathArray` to look into\n * @param point the point of the shape to look for\n * @returns the requested segment\n */\nconst getSegmentOfPoint = (\n  path: string | PathArray,\n  point: { x: number; y: number },\n): SegmentProperties | undefined => {\n  return getPropertiesAtPoint(path, point).segment;\n};\nexport default getSegmentOfPoint;\n","import type { PathArray, PathSegment } from '../types';\nimport getPropertiesAtLength from './getPropertiesAtLength';\n\n/**\n * Returns the segment at a given length.\n *\n * @param pathInput the target `pathArray`\n * @param distance the distance in path to look at\n * @returns the requested segment\n */\nconst getSegmentAtLength = (pathInput: string | PathArray, distance?: number): PathSegment | undefined => {\n  return getPropertiesAtLength(pathInput, distance).segment;\n};\n\nexport default getSegmentAtLength;\n","import type { PathArray } from '../types';\nimport getPropertiesAtPoint from './getPropertiesAtPoint';\nimport DISTANCE_EPSILON from './distanceEpsilon';\n\n/**\n * Checks if a given point is in the stroke of a path.\n *\n * @param pathInput target path\n * @param point the given `{x,y}` point\n * @returns the query result\n */\nconst isPointInStroke = (pathInput: string | PathArray, point: { x: number; y: number }) => {\n  const { distance } = getPropertiesAtPoint(pathInput, point);\n  return Math.abs(distance) < DISTANCE_EPSILON; // 0.01 might be more permissive\n};\nexport default isPointInStroke;\n","import scanSegment from '../parser/scanSegment';\nimport skipSpaces from '../parser/skipSpaces';\nimport PathParser from '../parser/pathParser';\n\n/**\n * Parses a path string value to determine its validity\n * then returns true if it's valid or false otherwise.\n *\n * @param pathString the path string to be parsed\n * @returns the path string validity\n */\nconst isValidPath = (pathString: string) => {\n  if (typeof pathString !== 'string' || !pathString.length) {\n    return false;\n  }\n\n  const path = new PathParser(pathString);\n\n  skipSpaces(path);\n\n  while (path.index < path.max && !path.err.length) {\n    scanSegment(path);\n  }\n\n  return !path.err.length && 'mM'.includes(path.segments[0][0]);\n};\nexport default isValidPath;\n","import type { PathArray, PathSegment, RelativeCommand } from '../types';\nimport paramsCount from '../parser/paramsCount';\n\n/**\n * Iterates an array to check if it's an actual `pathArray`.\n *\n * @param path the `pathArray` to be checked\n * @returns iteration result\n */\nconst isPathArray = (path: unknown): path is PathArray => {\n  return (\n    Array.isArray(path) &&\n    path.every((seg: PathSegment) => {\n      const lk = seg[0].toLowerCase() as RelativeCommand;\n      return (\n        paramsCount[lk] === seg.length - 1 &&\n        'achlmqstvz'.includes(lk) &&\n        (seg.slice(1) as unknown[]).every(Number.isFinite)\n      );\n    }) &&\n    path.length > 0\n  );\n};\nexport default isPathArray;\n","import type { AbsoluteArray } from '../types';\nimport isPathArray from './isPathArray';\n\n/**\n * Iterates an array to check if it's a `pathArray`\n * with all absolute values.\n *\n * @param path the `pathArray` to be checked\n * @returns iteration result\n */\nconst isAbsoluteArray = (path: unknown): path is AbsoluteArray => {\n  return (\n    isPathArray(path) &&\n    // `isPathArray` also checks if it's `Array`\n    path.every(([x]) => x === x.toUpperCase())\n  );\n};\nexport default isAbsoluteArray;\n","import type { RelativeArray } from '../types';\nimport isPathArray from './isPathArray';\n\n/**\n * Iterates an array to check if it's a `pathArray`\n * with relative values.\n *\n * @param path the `pathArray` to be checked\n * @returns iteration result\n */\nconst isRelativeArray = (path: unknown): path is RelativeArray => {\n  return (\n    isPathArray(path) &&\n    // `isPathArray` checks if it's `Array`\n    path.slice(1).every(([pc]) => pc === pc.toLowerCase())\n  );\n};\nexport default isRelativeArray;\n","import type { NormalArray } from '../types';\nimport isAbsoluteArray from './isAbsoluteArray';\n\n/**\n * Iterates an array to check if it's a `pathArray`\n * with all segments are in non-shorthand notation\n * with absolute values.\n *\n * @param {string | SVGPath.pathArray} path the `pathArray` to be checked\n * @returns {boolean} iteration result\n */\nconst isNormalizedArray = (path: unknown): path is NormalArray => {\n  // `isAbsoluteArray` also checks if it's `Array`\n  return isAbsoluteArray(path) && path.every(([pc]) => 'ACLMQZ'.includes(pc));\n};\nexport default isNormalizedArray;\n","import { CurveArray } from '../types';\nimport isNormalizedArray from './isNormalizedArray';\n\n/**\n * Iterates an array to check if it's a `pathArray`\n * with all C (cubic bezier) segments.\n *\n * @param path the `Array` to be checked\n * @returns iteration result\n */\nconst isCurveArray = (path: unknown): path is CurveArray => {\n  // `isPathArray` also checks if it's `Array`\n  return isNormalizedArray(path) && path.every(([pc]) => 'MC'.includes(pc));\n};\nexport default isCurveArray;\n","import type { ShapeParams } from '../interface';\n\n/**\n * Supported shapes and their specific parameters.\n */\nconst shapeParams: ShapeParams = {\n  line: ['x1', 'y1', 'x2', 'y2'],\n  circle: ['cx', 'cy', 'r'],\n  ellipse: ['cx', 'cy', 'rx', 'ry'],\n  rect: ['width', 'height', 'x', 'y', 'rx', 'ry'],\n  polygon: ['points'],\n  polyline: ['points'],\n  glyph: ['d'],\n};\n\nexport default shapeParams;\n","import type { CircleAttr, EllipseAttr, GlyphAttr, LineAttr, PolyAttr, RectAttr, ShapeParams } from '../interface';\nimport type { PathArray, PathSegment, ShapeOps, ShapeTypes } from '../types';\nimport error from '../parser/error';\nimport parsePathString from '../parser/parsePathString';\nimport shapeParams from './shapeParams';\nimport isPathArray from './isPathArray';\n\n/**\n * Returns a new `pathArray` from line attributes.\n *\n * @param attr shape configuration\n * @returns a new line `pathArray`\n */\nexport const getLinePath = (attr: LineAttr): PathArray => {\n  let { x1, y1, x2, y2 } = attr;\n  [x1, y1, x2, y2] = [x1, y1, x2, y2].map(a => +a);\n  return [\n    ['M', x1, y1],\n    ['L', x2, y2],\n  ];\n};\n\n/**\n * Returns a new `pathArray` like from polyline/polygon attributes.\n *\n * @param attr shape configuration\n * @return a new polygon/polyline `pathArray`\n */\nexport const getPolyPath = (attr: PolyAttr): PathArray => {\n  const pathArray = [] as PathSegment[];\n  const points = (attr.points || '')\n    .trim()\n    .split(/[\\s|,]/)\n    .map(a => +a);\n\n  let index = 0;\n  while (index < points.length) {\n    pathArray.push([index ? 'L' : 'M', points[index], points[index + 1]]);\n    index += 2;\n  }\n\n  return (attr.type === 'polygon' ? [...pathArray, ['z']] : pathArray) as PathArray;\n};\n\n/**\n * Returns a new `pathArray` from circle attributes.\n *\n * @param attr shape configuration\n * @return a circle `pathArray`\n */\nexport const getCirclePath = (attr: CircleAttr): PathArray => {\n  let { cx, cy, r } = attr;\n  [cx, cy, r] = [cx, cy, r].map(a => +a);\n\n  return [\n    ['M', cx - r, cy],\n    ['a', r, r, 0, 1, 0, 2 * r, 0],\n    ['a', r, r, 0, 1, 0, -2 * r, 0],\n  ];\n};\n\n/**\n * Returns a new `pathArray` from ellipse attributes.\n *\n * @param attr shape configuration\n * @return an ellipse `pathArray`\n */\nexport const getEllipsePath = (attr: EllipseAttr): PathArray => {\n  let { cx, cy } = attr;\n  let rx = attr.rx || 0;\n  let ry = attr.ry || rx;\n  [cx, cy, rx, ry] = [cx, cy, rx, ry].map(a => +a);\n\n  return [\n    ['M', cx - rx, cy],\n    ['a', rx, ry, 0, 1, 0, 2 * rx, 0],\n    ['a', rx, ry, 0, 1, 0, -2 * rx, 0],\n  ];\n};\n\n/**\n * Returns a new `pathArray` like from rect attributes.\n *\n * @param attr object with properties above\n * @return a new `pathArray` from `<rect>` attributes\n */\nexport const getRectanglePath = (attr: RectAttr): PathArray => {\n  const x = +attr.x || 0;\n  const y = +attr.y || 0;\n  const w = +attr.width;\n  const h = +attr.height;\n  let rx = +(attr.rx || 0);\n  let ry = +(attr.ry || rx);\n\n  // Validity checks from http://www.w3.org/TR/SVG/shapes.html#RectElement:\n  if (rx || ry) {\n    // rx = !rx ? ry : rx;\n    // ry = !ry ? rx : ry;\n\n    /* istanbul ignore else @preserve */\n    if (rx * 2 > w) rx -= (rx * 2 - w) / 2;\n    /* istanbul ignore else @preserve */\n    if (ry * 2 > h) ry -= (ry * 2 - h) / 2;\n\n    return [\n      ['M', x + rx, y],\n      ['h', w - rx * 2],\n      ['s', rx, 0, rx, ry],\n      ['v', h - ry * 2],\n      ['s', 0, ry, -rx, ry],\n      ['h', -w + rx * 2],\n      ['s', -rx, 0, -rx, -ry],\n      ['v', -h + ry * 2],\n      ['s', 0, -ry, rx, -ry],\n    ];\n  }\n\n  return [['M', x, y], ['h', w], ['v', h], ['H', x], ['Z']];\n};\n\n/**\n * Returns a new `pathArray` created from attributes of a `<line>`, `<polyline>`,\n * `<polygon>`, `<rect>`, `<ellipse>`, `<circle>`, <path> or `<glyph>`.\n *\n * The default `ownerDocument` is your current `document` browser page,\n * if you want to use in server-side using `jsdom`, you can pass the\n * `jsdom` `document` to `ownDocument`.\n *\n * It can also work with an options object, see the type below\n *\n * @see ShapeOps\n *\n * @param element target shape\n * @param ownerDocument document for create element\n * @return the newly created `<path>` element\n */\nconst shapeToPathArray = (element: ShapeTypes | ShapeOps, ownerDocument?: Document) => {\n  const doc = ownerDocument || document;\n  const win = doc.defaultView || /* istanbul ignore next */ window;\n  const supportedShapes = Object.keys(shapeParams) as (keyof ShapeParams)[];\n  const targetIsElement = element instanceof win.SVGElement;\n  const tagName = targetIsElement ? element.tagName : null;\n\n  if (tagName && [...supportedShapes, 'path'].every(s => tagName !== s)) {\n    throw TypeError(`${error}: \"${tagName}\" is not SVGElement`);\n  }\n\n  const type = (targetIsElement ? tagName : element.type) as ShapeOps['type'];\n  const shapeAttrs = shapeParams[type] as string[];\n  const config = { type } as Record<string, string>;\n\n  if (targetIsElement) {\n    shapeAttrs.forEach(p => {\n      config[p] = element.getAttribute(p) as string;\n    });\n  } else {\n    Object.assign(config, element);\n  }\n\n  // set d\n  let pathArray = [] as unknown as PathArray;\n\n  /* istanbul ignore else */\n  if (type === 'circle') pathArray = getCirclePath(config as unknown as CircleAttr);\n  else if (type === 'ellipse') pathArray = getEllipsePath(config as unknown as EllipseAttr);\n  else if (['polyline', 'polygon'].includes(type)) pathArray = getPolyPath(config as unknown as PolyAttr);\n  else if (type === 'rect') pathArray = getRectanglePath(config as unknown as RectAttr);\n  else if (type === 'line') pathArray = getLinePath(config as unknown as LineAttr);\n  else if (['glyph', 'path'].includes(type)) {\n    pathArray = parsePathString(\n      targetIsElement\n        ? element.getAttribute('d') || /* istanbul ignore next @preserve */ ''\n        : (element as GlyphAttr).d || '',\n    );\n  }\n\n  // replace target element\n  if (isPathArray(pathArray) && pathArray.length) {\n    return pathArray;\n  }\n  return false;\n};\nexport default shapeToPathArray;\n","import type { PathArray, PathSegment } from '../types';\nimport defaultOptions from '../options/options';\nimport iterate from './iterate';\n\n/**\n * Rounds the values of a `pathArray` instance to\n * a specified amount of decimals and returns it.\n *\n * @param path the source `pathArray`\n * @param roundOption the amount of decimals to round numbers to\n * @returns the resulted `pathArray` with rounded values\n */\nconst roundPath = (path: PathArray, roundOption?: number | 'off') => {\n  let { round } = defaultOptions;\n  if (roundOption === 'off' || round === 'off') return path.slice(0) as PathArray;\n  // allow for ZERO decimals\n  round = typeof roundOption === 'number' && roundOption >= 0 ? roundOption : round;\n  // to round values to the power\n  // the `round` value must be integer\n  const pow = typeof round === 'number' && round >= 1 ? 10 ** round : 1;\n\n  return iterate<typeof path>(path, segment => {\n    const values = (segment.slice(1) as number[]).map(n => (round ? Math.round(n * pow) / pow : Math.round(n)));\n    return [segment[0], ...values] as PathSegment;\n  });\n};\nexport default roundPath;\n","import type { PathArray } from '../types';\nimport roundPath from '../process/roundPath';\n\n/**\n * Returns a valid `d` attribute string value created\n * by rounding values and concatenating the `pathArray` segments.\n *\n * @param path the `pathArray` object\n * @param round amount of decimals to round values to\n * @returns the concatenated path string\n */\nconst pathToString = (path: PathArray, round?: number | 'off'): string => {\n  return roundPath(path, round)\n    .map(x => x[0] + x.slice(1).join(' '))\n    .join('');\n};\nexport default pathToString;\n","import type { ShapeParams } from '../interface';\nimport type { ShapeOps, ShapeTypes } from '../types';\nimport pathToString from '../convert/pathToString';\nimport defaultOptions from '../options/options';\nimport error from '../parser/error';\nimport isValidPath from './isValidPath';\nimport shapeToPathArray from './shapeToPathArray';\nimport shapeParams from './shapeParams';\n\n/**\n * Returns a new `<path>` element created from attributes of a `<line>`, `<polyline>`,\n * `<polygon>`, `<rect>`, `<ellipse>`, `<circle>` or `<glyph>`. If `replace` parameter\n * is `true`, it will replace the target. The default `ownerDocument` is your current\n * `document` browser page, if you want to use in server-side using `jsdom`, you can\n * pass the `jsdom` `document` to `ownDocument`.\n *\n * It can also work with an options object, see the type below\n *\n * @see ShapeOps\n *\n * The newly created `<path>` element keeps all non-specific\n * attributes like `class`, `fill`, etc.\n *\n * @param element target shape\n * @param replace option to replace target\n * @param ownerDocument document for create element\n * @return the newly created `<path>` element\n */\nconst shapeToPath = (\n  element: ShapeTypes | ShapeOps,\n  replace?: boolean,\n  ownerDocument?: Document,\n): SVGPathElement | false => {\n  const doc = ownerDocument || document;\n  const win = doc.defaultView || /* istanbul ignore next */ window;\n  const supportedShapes = Object.keys(shapeParams) as (keyof ShapeParams)[];\n  const targetIsElement = element instanceof win.SVGElement;\n  const tagName = targetIsElement ? element.tagName : null;\n\n  if (tagName === 'path') throw TypeError(`${error}: \"${tagName}\" is already SVGPathElement`);\n  if (tagName && supportedShapes.every(s => tagName !== s)) throw TypeError(`${error}: \"${tagName}\" is not SVGElement`);\n\n  const path = doc.createElementNS('http://www.w3.org/2000/svg', 'path');\n  const type = (targetIsElement ? tagName : element.type) as ShapeOps['type'];\n  const shapeAttrs = shapeParams[type] as string[];\n  const config = { type } as Record<string, string>;\n\n  // set d\n  const round = defaultOptions.round as number;\n  const pathArray = shapeToPathArray(element, doc);\n  const description = pathArray && pathArray.length ? pathToString(pathArray, round) : '';\n\n  if (targetIsElement) {\n    shapeAttrs.forEach(p => {\n      config[p] = element.getAttribute(p) as string;\n    });\n    // set no-specific shape attributes: fill, stroke, etc\n    Object.values(element.attributes).forEach(({ name, value }) => {\n      if (!shapeAttrs.includes(name)) path.setAttribute(name, value);\n    });\n  } else {\n    Object.assign(config, element);\n    // set no-specific shape attributes: fill, stroke, etc\n    Object.keys(config).forEach(k => {\n      if (!shapeAttrs.includes(k) && k !== 'type') {\n        path.setAttribute(\n          k.replace(/[A-Z]/g, m => `-${m.toLowerCase()}`),\n          config[k],\n        );\n      }\n    });\n  }\n\n  // replace target element\n  if (isValidPath(description)) {\n    path.setAttribute('d', description);\n    if (replace && targetIsElement) {\n      element.before(path, element);\n      element.remove();\n    }\n    return path;\n  }\n  return false;\n};\n\nexport default shapeToPath;\n","import paramsParser from '../parser/paramsParser';\nimport type { AbsoluteCommand, HSegment, MSegment, PathArray, PointTuple, RelativeCommand, VSegment } from '../types';\n\n/**\n * Split a path into an `Array` of sub-path strings.\n *\n * In the process, values are converted to absolute\n * for visual consistency.\n *\n * @param pathInput the source `pathArray`\n * @return an array with all sub-path strings\n */\nconst splitPath = (pathInput: PathArray): PathArray[] => {\n  const composite = [] as PathArray[];\n  let path: PathArray;\n  let pi = -1;\n  let x = 0;\n  let y = 0;\n  let mx = 0;\n  let my = 0;\n  const params = { ...paramsParser };\n\n  pathInput.forEach(seg => {\n    const [pathCommand] = seg;\n    const absCommand = pathCommand.toUpperCase() as AbsoluteCommand;\n    const relCommand = pathCommand.toLowerCase() as RelativeCommand;\n    const isRelative = pathCommand === relCommand;\n    const values = seg.slice(1) as number[];\n\n    if (absCommand === 'M') {\n      pi += 1;\n      [x, y] = values as PointTuple;\n      x += isRelative ? params.x : 0;\n      y += isRelative ? params.y : 0;\n      mx = x;\n      my = y;\n      path = [(isRelative ? [absCommand, mx, my] : seg) as MSegment];\n    } else {\n      if (absCommand === 'Z') {\n        x = mx;\n        y = my;\n      } else if (absCommand === 'H') {\n        [, x] = seg as HSegment;\n        x += isRelative ? params.x : /* istanbul ignore next @preserve */ 0;\n      } else if (absCommand === 'V') {\n        [, y] = seg as VSegment;\n        y += isRelative ? params.y : /* istanbul ignore next @preserve */ 0;\n      } else {\n        [x, y] = seg.slice(-2) as PointTuple;\n        x += isRelative ? params.x : 0;\n        y += isRelative ? params.y : 0;\n      }\n      path.push(seg);\n    }\n\n    params.x = x;\n    params.y = y;\n    composite[pi] = path;\n  });\n\n  return composite;\n};\nexport default splitPath;\n","import CSSMatrix from '@thednp/dommatrix';\n// import type { TransformObject } from '../interface';\nimport type { TransformObjectValues } from '../types';\n\n/**\n * Returns a transformation matrix to apply to `<path>` elements.\n *\n * @see TransformObjectValues\n *\n * @param transform the `transformObject`\n * @returns a new transformation matrix\n */\nconst getSVGMatrix = (transform: TransformObjectValues): CSSMatrix => {\n  let matrix = new CSSMatrix();\n  const { origin } = transform;\n  const [originX, originY] = origin as [number, number, number];\n  const { translate } = transform;\n  const { rotate } = transform;\n  const { skew } = transform;\n  const { scale } = transform;\n\n  // set translate\n  if (\n    Array.isArray(translate) &&\n    translate.length >= 2 &&\n    translate.every(x => !Number.isNaN(+x)) &&\n    translate.some(x => x !== 0)\n  ) {\n    matrix = matrix.translate(...(translate as [number, number, number?]));\n  } else if (typeof translate === 'number' && !Number.isNaN(translate)) {\n    matrix = matrix.translate(translate);\n  }\n\n  if (rotate || skew || scale) {\n    // set SVG transform-origin, always defined\n    matrix = matrix.translate(originX, originY);\n\n    // set rotation\n    if (\n      Array.isArray(rotate) &&\n      rotate.length >= 2 &&\n      rotate.every(x => !Number.isNaN(+x)) &&\n      rotate.some(x => x !== 0)\n    ) {\n      matrix = matrix.rotate(...(rotate as [number, number, number?]));\n    } else if (typeof rotate === 'number' && !Number.isNaN(rotate)) {\n      matrix = matrix.rotate(rotate);\n    }\n\n    // set skew(s)\n    if (Array.isArray(skew) && skew.length === 2 && skew.every(x => !Number.isNaN(+x)) && skew.some(x => x !== 0)) {\n      matrix = skew[0] ? matrix.skewX(skew[0]) : matrix;\n      matrix = skew[1] ? matrix.skewY(skew[1]) : matrix;\n    } else if (typeof skew === 'number' && !Number.isNaN(skew)) {\n      matrix = matrix.skewX(skew);\n    }\n\n    // set scale\n    if (Array.isArray(scale) && scale.length >= 2 && scale.every(x => !Number.isNaN(+x)) && scale.some(x => x !== 1)) {\n      matrix = matrix.scale(...(scale as [number, number, number?]));\n    } else if (typeof scale === 'number' && !Number.isNaN(scale)) {\n      matrix = matrix.scale(scale);\n    }\n    // set SVG transform-origin\n    matrix = matrix.translate(-originX, -originY);\n  }\n\n  return matrix;\n};\nexport default getSVGMatrix;\n","import parsePathString from '../parser/parsePathString';\nimport absolutizeSegment from '../process/absolutizeSegment';\nimport type { AbsoluteArray, AbsoluteCommand, HSegment, PathArray, PointTuple, VSegment } from '../types';\nimport iterate from '../process/iterate';\n\n/**\n * Parses a path string value or object and returns an array\n * of segments, all converted to absolute values.\n *\n * @param pathInput the path string | object\n * @returns the resulted `pathArray` with absolute values\n */\nconst pathToAbsolute = (pathInput: string | PathArray) => {\n  let x = 0;\n  let y = 0;\n  let mx = 0;\n  let my = 0;\n  let pathCommand = 'M';\n  const path = parsePathString(pathInput);\n\n  return iterate<AbsoluteArray>(path, (seg, params) => {\n    [pathCommand] = seg;\n    const result = absolutizeSegment(seg, params);\n    const absCommand = pathCommand.toUpperCase() as AbsoluteCommand;\n\n    if (absCommand === 'Z') {\n      x = mx;\n      y = my;\n    } else if (absCommand === 'H') {\n      [, x] = result as HSegment;\n    } else if (absCommand === 'V') {\n      [, y] = result as VSegment;\n    } else {\n      [x, y] = result.slice(-2) as PointTuple;\n\n      if (absCommand === 'M') {\n        mx = x;\n        my = y;\n      }\n    }\n\n    params.x = x;\n    params.y = y;\n    return result;\n  });\n};\nexport default pathToAbsolute;\n","import type { ParserParams } from '../interface';\nimport type {\n  RelativeSegment,\n  RelativeCommand,\n  PathSegment,\n  aSegment,\n  vSegment,\n  hSegment,\n  qSegment,\n  tSegment,\n  sSegment,\n  cSegment,\n} from '../types';\n\n/**\n * Returns a relative segment of a `PathArray` object.\n *\n * @param segment the segment object\n * @param params the coordinates of the previous segment\n * @param index the segment index\n * @returns the absolute segment\n */\nconst relativizeSegment = (segment: PathSegment, params: ParserParams, index: number) => {\n  const [pathCommand] = segment;\n  const { x, y } = params;\n  const values = segment.slice(1).map(Number);\n  const relCommand = pathCommand.toLowerCase() as RelativeCommand;\n\n  if (index === 0 && pathCommand === 'M') {\n    return segment;\n  }\n\n  /* istanbul ignore else @preserve */\n  if (pathCommand !== relCommand) {\n    if (relCommand === 'a') {\n      return [\n        relCommand,\n        values[0],\n        values[1],\n        values[2],\n        values[3],\n        values[4],\n        values[5] - x,\n        values[6] - y,\n      ] as aSegment;\n    } else if (relCommand === 'v') {\n      return [relCommand, values[0] - y] as vSegment;\n    } else if (relCommand === 'h') {\n      return [relCommand, values[0] - x] as hSegment;\n    } else {\n      // use brakets for `eslint: no-case-declaration`\n      // https://stackoverflow.com/a/50753272/803358\n      const relValues = values.map((n, j) => n - (j % 2 ? y : x));\n      // for n, l, c, s, q, t\n      return [relCommand, ...relValues] as qSegment | tSegment | sSegment | cSegment;\n    }\n  }\n\n  return segment as RelativeSegment;\n};\nexport default relativizeSegment;\n","import type {\n  AbsoluteCommand,\n  hSegment,\n  PathArray,\n  PointTuple,\n  RelativeArray,\n  RelativeCommand,\n  vSegment,\n} from '../types';\nimport parsePathString from '../parser/parsePathString';\nimport iterate from '../process/iterate';\nimport relativizeSegment from '../process/relativizeSegment';\n\n/**\n * Parses a path string value or object and returns an array\n * of segments, all converted to relative values.\n *\n * @param pathInput the path string | object\n * @returns the resulted `pathArray` with relative values\n */\nconst pathToRelative = (pathInput: string | PathArray): RelativeArray => {\n  let x = 0;\n  let y = 0;\n  let mx = 0;\n  let my = 0;\n  let pathCommand = 'M';\n  const path = parsePathString(pathInput);\n\n  return iterate<RelativeArray>(path, (seg, params, i) => {\n    [pathCommand] = seg;\n    const result = relativizeSegment(seg, params, i);\n    const [resultedCommand] = result;\n    const absCommand = pathCommand.toUpperCase() as AbsoluteCommand;\n    const relCommand = pathCommand.toLowerCase() as RelativeCommand;\n    const isRelative = resultedCommand === relCommand;\n\n    if (absCommand === 'Z') {\n      x = mx;\n      y = my;\n    } else if (absCommand === 'H') {\n      [, x] = result as hSegment;\n      x += isRelative ? params.x : /* istanbul ignore next @preserve */ 0;\n    } else if (absCommand === 'V') {\n      [, y] = result as vSegment;\n      y += isRelative ? params.y : /* istanbul ignore next @preserve */ 0;\n    } else {\n      [x, y] = result.slice(-2) as PointTuple;\n      x += isRelative ? params.x : 0;\n      y += isRelative ? params.y : 0;\n\n      if (absCommand === 'M') {\n        mx = x;\n        my = y;\n      }\n    }\n\n    params.x = x;\n    params.y = y;\n\n    return result;\n  });\n};\nexport default pathToRelative;\n","import type { ParserParams } from '../interface';\nimport type {\n  AbsoluteSegment,\n  HSegment,\n  NormalSegment,\n  PathCommand,\n  ShortSegment,\n  SSegment,\n  TSegment,\n  VSegment,\n  ZSegment,\n} from '../types';\n\n/**\n * Shorten a single segment of a `pathArray` object.\n *\n * @param segment the `absoluteSegment` object\n * @param normalSegment the `normalSegment` object\n * @param params the coordinates of the previous segment\n * @param prevCommand the path command of the previous segment\n * @returns the shortened segment\n */\nconst shortenSegment = (\n  segment: AbsoluteSegment,\n  normalSegment: NormalSegment,\n  params: ParserParams,\n  prevCommand: PathCommand,\n): ShortSegment => {\n  const [pathCommand] = segment;\n  const round4 = (n: number) => Math.round(n * 10 ** 4) / 10 ** 4;\n  const segmentValues = segment.slice(1) as number[];\n  const normalValues = normalSegment.slice(1) as number[];\n  const { x1: px1, y1: py1, x2: px2, y2: py2, x: px, y: py } = params;\n  let result = segment;\n  const [x, y] = normalValues.slice(-2);\n\n  if (!'TQ'.includes(pathCommand)) {\n    // optional but good to be cautious\n    params.qx = null;\n    params.qy = null;\n  }\n\n  if (['V', 'H', 'S', 'T', 'Z'].includes(pathCommand)) {\n    result = [pathCommand, ...segmentValues] as VSegment | HSegment | SSegment | TSegment | ZSegment;\n  } else if (pathCommand === 'L') {\n    if (round4(px) === round4(x)) {\n      result = ['V', y];\n    } else if (round4(py) === round4(y)) {\n      result = ['H', x];\n    }\n  } else if (pathCommand === 'C') {\n    const [x1, y1] = normalValues;\n\n    if (\n      'CS'.includes(prevCommand) &&\n      ((round4(x1) === round4(px1 * 2 - px2) && round4(y1) === round4(py1 * 2 - py2)) ||\n        (round4(px1) === round4(px2 * 2 - px) && round4(py1) === round4(py2 * 2 - py)))\n    ) {\n      result = ['S', ...normalValues.slice(-4)] as SSegment;\n    }\n    params.x1 = x1;\n    params.y1 = y1;\n  } else if (pathCommand === 'Q') {\n    const [qx, qy] = normalValues;\n    params.qx = qx;\n    params.qy = qy;\n\n    if (\n      'QT'.includes(prevCommand) &&\n      ((round4(qx) === round4(px1 * 2 - px2) && round4(qy) === round4(py1 * 2 - py2)) ||\n        (round4(px1) === round4(px2 * 2 - px) && round4(py1) === round4(py2 * 2 - py)))\n    ) {\n      result = ['T', ...normalValues.slice(-2)] as TSegment;\n    }\n  }\n\n  return result as ShortSegment;\n};\nexport default shortenSegment;\n","import roundPath from './roundPath';\nimport pathToAbsolute from '../convert/pathToAbsolute';\nimport pathToRelative from '../convert/pathToRelative';\nimport shortenSegment from './shortenSegment';\nimport paramsParser from '../parser/paramsParser';\nimport normalizePath from './normalizePath';\nimport type { PathSegment, HSegment, PathArray, VSegment, PathCommand, AbsoluteSegment } from '../types';\n\n/**\n * Optimizes a `pathArray` object:\n * * convert segments to shorthand if possible\n * * select shortest segments from absolute and relative `pathArray`s\n *\n * @param pathInput a string or `pathArray`\n * @param round the amount of decimals to round values to\n * @returns the optimized `pathArray`\n */\nconst optimizePath = (pathInput: PathArray, round: 'off' | number): PathArray => {\n  const path = pathToAbsolute(pathInput);\n  const normalPath = normalizePath(path);\n  const params = { ...paramsParser };\n  const allPathCommands = [] as PathCommand[];\n  const ii = path.length;\n  let pathCommand = '' as PathCommand;\n  let prevCommand = '' as PathCommand;\n  let x = 0;\n  let y = 0;\n  let mx = 0;\n  let my = 0;\n\n  for (let i = 0; i < ii; i += 1) {\n    [pathCommand] = path[i];\n\n    // Save current path command\n    allPathCommands[i] = pathCommand;\n    // Get previous path command for `shortenSegment`\n    if (i) prevCommand = allPathCommands[i - 1];\n    path[i] = shortenSegment(path[i], normalPath[i], params, prevCommand) as AbsoluteSegment;\n\n    const segment = path[i];\n    const seglen = segment.length;\n\n    // update C, S, Q, T specific params\n    params.x1 = +segment[seglen - 2];\n    params.y1 = +segment[seglen - 1];\n    params.x2 = +segment[seglen - 4] || params.x1;\n    params.y2 = +segment[seglen - 3] || params.y1;\n\n    // update x, y params\n    switch (pathCommand) {\n      case 'Z':\n        x = mx;\n        y = my;\n        break;\n      case 'H':\n        [, x] = segment as HSegment;\n        break;\n      case 'V':\n        [, y] = segment as VSegment;\n        break;\n      default:\n        [x, y] = segment.slice(-2).map(Number);\n\n        if (pathCommand === 'M') {\n          mx = x;\n          my = y;\n        }\n    }\n    params.x = x;\n    params.y = y;\n  }\n\n  const absolutePath = roundPath(path, round);\n  const relativePath = roundPath(pathToRelative(path), round);\n\n  return absolutePath.map((a: PathSegment, i: number) => {\n    if (i) {\n      return a.join('').length < relativePath[i].join('').length ? a : relativePath[i];\n    }\n    return a;\n  }) as PathArray;\n};\nexport default optimizePath;\n","import type { CurveArray } from '../types';\n\n/**\n * Reverses all segments of a `pathArray`\n * which consists of only C (cubic-bezier) path commands.\n *\n * @param path the source `pathArray`\n * @returns the reversed `pathArray`\n */\nconst reverseCurve = (path: CurveArray): CurveArray => {\n  const rotatedCurve = path\n    .slice(1)\n    .map((x, i, curveOnly) =>\n      !i ? [...path[0].slice(1), ...x.slice(1)] : [...curveOnly[i - 1].slice(-2), ...x.slice(1)],\n    )\n    .map(x => x.map((_, i) => x[x.length - i - 2 * (1 - (i % 2))]))\n    .reverse();\n\n  return [['M', ...rotatedCurve[0].slice(0, 2)], ...rotatedCurve.map(x => ['C', ...x.slice(2)])] as CurveArray;\n};\nexport default reverseCurve;\n","import type {\n  ASegment,\n  CSegment,\n  HSegment,\n  MSegment,\n  PathArray,\n  PathSegment,\n  QSegment,\n  SSegment,\n  TSegment,\n  VSegment,\n} from '../types';\nimport pathToAbsolute from '../convert/pathToAbsolute';\nimport normalizePath from './normalizePath';\n\n/**\n * Reverses all segments of a `pathArray` and returns a new `pathArray` instance.\n *\n * @param pathInput the source `pathArray`\n * @returns the reversed `pathArray`\n */\nconst reversePath = (pathInput: PathArray): PathArray => {\n  const absolutePath = pathToAbsolute(pathInput);\n  const isClosed = absolutePath.slice(-1)[0][0] === 'Z';\n\n  const reversedPath = normalizePath(absolutePath)\n    .map((segment, i) => {\n      const [x, y] = segment.slice(-2).map(Number);\n      return {\n        seg: absolutePath[i], // absolute\n        n: segment, // normalized\n        c: absolutePath[i][0], // pathCommand\n        x, // x\n        y, // y\n      };\n    })\n    .map((seg, i, path) => {\n      const segment = seg.seg;\n      const data = seg.n;\n      const prevSeg = i && path[i - 1];\n      const nextSeg = path[i + 1];\n      const pathCommand = seg.c;\n      const pLen = path.length;\n      const x = i ? path[i - 1].x : path[pLen - 1].x;\n      const y = i ? path[i - 1].y : path[pLen - 1].y;\n      let result = [];\n\n      switch (pathCommand) {\n        case 'M':\n          result = (isClosed ? ['Z'] : [pathCommand, x, y]) as PathSegment;\n          break;\n        case 'A':\n          result = [pathCommand, ...segment.slice(1, -3), segment[5] === 1 ? 0 : 1, x, y] as ASegment;\n          break;\n        case 'C':\n          if (nextSeg && nextSeg.c === 'S') {\n            result = ['S', segment[1], segment[2], x, y] as SSegment;\n          } else {\n            result = [pathCommand, segment[3], segment[4], segment[1], segment[2], x, y] as CSegment;\n          }\n          break;\n        case 'S':\n          if (prevSeg && 'CS'.includes(prevSeg.c) && (!nextSeg || nextSeg.c !== 'S')) {\n            result = ['C', data[3], data[4], data[1], data[2], x, y] as CSegment;\n          } else {\n            result = [pathCommand, data[1], data[2], x, y] as SSegment;\n          }\n          break;\n        case 'Q':\n          if (nextSeg && nextSeg.c === 'T') {\n            result = ['T', x, y] as TSegment;\n          } else {\n            result = [pathCommand, ...segment.slice(1, -2), x, y] as QSegment;\n          }\n          break;\n        case 'T':\n          if (prevSeg && 'QT'.includes(prevSeg.c) && (!nextSeg || nextSeg.c !== 'T')) {\n            result = ['Q', data[1], data[2], x, y] as QSegment;\n          } else {\n            result = [pathCommand, x, y] as TSegment;\n          }\n          break;\n        case 'Z':\n          result = ['M', x, y] as MSegment;\n          break;\n        case 'H':\n          result = [pathCommand, x] as HSegment;\n          break;\n        case 'V':\n          result = [pathCommand, y] as VSegment;\n          break;\n        default:\n          result = [pathCommand, ...segment.slice(1, -2), x, y] as PathSegment;\n      }\n\n      return result;\n    });\n\n  return (isClosed ? reversedPath.reverse() : [reversedPath[0], ...reversedPath.slice(1).reverse()]) as PathArray;\n};\nexport default reversePath;\n","import CSSMatrix from '@thednp/dommatrix';\nimport { type PointTuple } from '../types';\n\n/**\n * Transforms a specified point using a matrix, returning a new\n * Tuple *Object* comprising of the transformed point.\n * Neither the matrix nor the original point are altered.\n *\n * @copyright thednp Â© 2021\n *\n * @param cssm CSSMatrix instance\n * @param v Tuple\n * @return the resulting Tuple\n */\nconst translatePoint = (cssm: CSSMatrix, v: [number, number, number, number]): [number, number, number, number] => {\n  let m = CSSMatrix.Translate(...(v.slice(0, -1) as [number, number, number]));\n\n  [, , , m.m44] = v;\n  m = cssm.multiply(m);\n\n  return [m.m41, m.m42, m.m43, m.m44];\n};\n\n/**\n * Returns the [x,y] projected coordinates for a given an [x,y] point\n * and an [x,y,z] perspective origin point.\n *\n * Equation found here =>\n * http://en.wikipedia.org/wiki/3D_projection#Diagram\n * Details =>\n * https://stackoverflow.com/questions/23792505/predicted-rendering-of-css-3d-transformed-pixel\n *\n * @param m the transformation matrix\n * @param point2D the initial [x,y] coordinates\n * @param origin the [x,y,z] transform origin\n * @returns the projected [x,y] coordinates\n */\nconst projection2d = (m: CSSMatrix, point2D: PointTuple, origin: [number, number, number]): PointTuple => {\n  const [originX, originY, originZ] = origin;\n  const [x, y, z] = translatePoint(m, [...point2D, 0, 1]);\n\n  const relativePositionX = x - originX;\n  const relativePositionY = y - originY;\n  const relativePositionZ = z - originZ;\n\n  return [\n    // protect against division by ZERO\n    relativePositionX * (Math.abs(originZ) / Math.abs(relativePositionZ) || 1) + originX,\n    relativePositionY * (Math.abs(originZ) / Math.abs(relativePositionZ) || 1) + originY,\n  ];\n};\nexport default projection2d;\n","import getSVGMatrix from './getSVGMatrix';\nimport projection2d from './projection2d';\nimport defaultOptions from '../options/options';\nimport type { AbsoluteArray, CSegment, PathArray, PointTuple, TransformObjectValues } from '../types';\nimport type { TransformObject } from '../interface';\nimport iterate from './iterate';\nimport parsePathString from '../parser/parsePathString';\nimport absolutizeSegment from './absolutizeSegment';\nimport segmentToCubic from './segmentToCubic';\nimport normalizeSegment from './normalizeSegment';\nimport paramsParser from '../parser/paramsParser';\n\n/**\n * Apply a 2D / 3D transformation to a `pathArray` instance.\n *\n * Since *SVGElement* doesn't support 3D transformation, this function\n * creates a 2D projection of the <path> element.\n *\n * @param path the `pathArray` to apply transformation\n * @param transform the transform functions `Object`\n * @returns the resulted `pathArray`\n */\nconst transformPath = (pathInput: PathArray | string, transform?: Partial<TransformObject>) => {\n  let x = 0;\n  let y = 0;\n  let mx = 0;\n  let my = 0;\n  let lx = 0;\n  let ly = 0;\n  let j = 0;\n  let jj = 0;\n  let nx = 0;\n  let ny = 0;\n  let pathCommand = 'M';\n  // transform uses it's own set of params\n  const transformParams = { ...paramsParser };\n  const path = parsePathString(pathInput);\n  const transformProps = transform && Object.keys(transform);\n\n  // when used as a static method, invalidate somehow\n  if (!transform || (transformProps && !transformProps.length)) return path;\n\n  // transform origin is extremely important\n  if (!transform.origin) {\n    Object.assign(transform, { origin: defaultOptions.origin });\n  }\n  const origin = transform.origin as [number, number, number];\n  const matrixInstance = getSVGMatrix(transform as TransformObjectValues);\n\n  if (matrixInstance.isIdentity) return path;\n\n  return iterate<AbsoluteArray>(path, (seg, _, i) => {\n    const absSegment = absolutizeSegment(seg, transformParams);\n    [pathCommand] = absSegment;\n\n    let result =\n      pathCommand === 'A'\n        ? segmentToCubic(absSegment, transformParams)\n        : ['V', 'H'].includes(pathCommand)\n        ? normalizeSegment(absSegment, transformParams)\n        : absSegment;\n    const isLongArc = result[0] === 'C' && result.length > 7;\n    const normalizedSegment = (isLongArc ? result.slice(0, 7) : result.slice(0)) as typeof result;\n\n    if (isLongArc) {\n      path.splice(i + 1, 0, ['C', ...result.slice(7)] as CSegment);\n      result = result.slice(0, 7) as CSegment;\n    }\n\n    if (result[0] === 'L') {\n      const values = result.slice(-2) as PointTuple;\n      [lx, ly] = projection2d(matrixInstance, values, origin);\n\n      /* istanbul ignore else @preserve */\n      if (x !== lx && y !== ly) {\n        result = ['L', lx, ly];\n      } else if (y === ly) {\n        result = ['H', lx];\n      } else if (x === lx) {\n        result = ['V', ly];\n      }\n    } else {\n      for (j = 1, jj = result.length; j < jj; j += 2) {\n        [lx, ly] = projection2d(matrixInstance, [+result[j], +result[j + 1]], origin);\n        result[j] = lx;\n        result[j + 1] = ly;\n      }\n    }\n    // now update x and y\n    x = lx;\n    y = ly;\n\n    if (pathCommand === 'Z') {\n      nx = mx;\n      ny = my;\n    } else {\n      [nx, ny] = normalizedSegment.slice(-2) as PointTuple;\n      if (pathCommand === 'M') {\n        mx = nx;\n        my = ny;\n      }\n    }\n\n    const seglen = normalizedSegment.length;\n    transformParams.x1 = +normalizedSegment[seglen - 2];\n    transformParams.y1 = +normalizedSegment[seglen - 1];\n    transformParams.x2 = +normalizedSegment[seglen - 4] || transformParams.x1;\n    transformParams.y2 = +normalizedSegment[seglen - 3] || transformParams.y1;\n    transformParams.x = nx;\n    transformParams.y = ny;\n    return result;\n  });\n};\n\nexport default transformPath;\n","import midPoint from '../math/midPoint';\nimport type { CubicSegment, PointTuple } from '../types';\n\n/**\n * Split a cubic-bezier segment into two.\n *\n * @param pts the cubic-bezier parameters\n * @param ratio the cubic-bezier parameters\n * @return two new cubic-bezier segments\n */\nconst splitCubic = (pts: number[], ratio = 0.5): [CubicSegment, CubicSegment] => {\n  const t = ratio;\n  const p0 = pts.slice(0, 2) as PointTuple;\n  const p1 = pts.slice(2, 4) as PointTuple;\n  const p2 = pts.slice(4, 6) as PointTuple;\n  const p3 = pts.slice(6, 8) as PointTuple;\n  const p4 = midPoint(p0, p1, t);\n  const p5 = midPoint(p1, p2, t);\n  const p6 = midPoint(p2, p3, t);\n  const p7 = midPoint(p4, p5, t);\n  const p8 = midPoint(p5, p6, t);\n  const p9 = midPoint(p7, p8, t);\n\n  return [\n    ['C', ...p4, ...p7, ...p9],\n    ['C', ...p8, ...p6, ...p3],\n  ];\n};\nexport default splitCubic;\n","'use strict';\nimport { PointTuple, PathArray, TransformObjectValues } from './types';\nimport type { Options, TransformEntries, TransformObject } from './interface';\nexport * from './types';\nexport * from './interface';\nimport defaultOptions from './options/options';\n\nimport error from './parser/error';\nimport parsePathString from './parser/parsePathString';\n\nimport polygonArea from './math/polygonArea';\nimport polygonLength from './math/polygonLength';\n\nimport CSSMatrix from '@thednp/dommatrix';\nimport getPathBBox from './util/getPathBBox';\nimport getPathArea from './util/getPathArea';\nimport getTotalLength from './util/getTotalLength';\nimport getDrawDirection from './util/getDrawDirection';\nimport getPointAtLength from './util/getPointAtLength';\n\nimport getPropertiesAtLength from './util/getPropertiesAtLength';\nimport getPropertiesAtPoint from './util/getPropertiesAtPoint';\nimport getClosestPoint from './util/getClosestPoint';\nimport getSegmentOfPoint from './util/getSegmentOfPoint';\nimport getSegmentAtLength from './util/getSegmentAtLength';\nimport isPointInStroke from './util/isPointInStroke';\n\nimport isValidPath from './util/isValidPath';\nimport isPathArray from './util/isPathArray';\nimport isAbsoluteArray from './util/isAbsoluteArray';\nimport isRelativeArray from './util/isRelativeArray';\nimport isCurveArray from './util/isCurveArray';\nimport isNormalizedArray from './util/isNormalizedArray';\nimport shapeToPathArray from './util/shapeToPathArray';\nimport shapeToPath from './util/shapeToPath';\n\nimport roundPath from './process/roundPath';\nimport splitPath from './process/splitPath';\nimport getSVGMatrix from './process/getSVGMatrix';\nimport optimizePath from './process/optimizePath';\nimport reverseCurve from './process/reverseCurve';\nimport reversePath from './process/reversePath';\nimport normalizePath from './process/normalizePath';\nimport transformPath from './process/transformPath';\nimport splitCubic from './process/splitCubic';\n\nimport pathToAbsolute from './convert/pathToAbsolute';\nimport pathToRelative from './convert/pathToRelative';\nimport pathToCurve from './convert/pathToCurve';\nimport pathToString from './convert/pathToString';\n\n/**\n * Creates a new SVGPathCommander instance with the following properties:\n * * segments: `pathArray`\n * * round: number\n * * origin: [number, number, number?]\n *\n * @class\n * @author thednp <https://github.com/thednp/svg-path-commander>\n * @returns a new SVGPathCommander instance\n */\nclass SVGPathCommander {\n  public static CSSMatrix = CSSMatrix;\n  public static getSVGMatrix = getSVGMatrix;\n  public static getPathBBox = getPathBBox;\n  public static getPathArea = getPathArea;\n  public static getTotalLength = getTotalLength;\n  public static getDrawDirection = getDrawDirection;\n  public static getPointAtLength = getPointAtLength;\n  public static getPropertiesAtLength = getPropertiesAtLength;\n  public static getPropertiesAtPoint = getPropertiesAtPoint;\n  public static polygonLength = polygonLength;\n  public static polygonArea = polygonArea;\n  public static getClosestPoint = getClosestPoint;\n  public static getSegmentOfPoint = getSegmentOfPoint;\n  public static getSegmentAtLength = getSegmentAtLength;\n  public static isPointInStroke = isPointInStroke;\n  public static isValidPath = isValidPath;\n  public static isPathArray = isPathArray;\n  public static isAbsoluteArray = isAbsoluteArray;\n  public static isRelativeArray = isRelativeArray;\n  public static isCurveArray = isCurveArray;\n  public static isNormalizedArray = isNormalizedArray;\n  public static shapeToPath = shapeToPath;\n  public static shapeToPathArray = shapeToPathArray;\n  public static parsePathString = parsePathString;\n  public static roundPath = roundPath;\n  public static splitPath = splitPath;\n  public static splitCubic = splitCubic;\n  public static optimizePath = optimizePath;\n  public static reverseCurve = reverseCurve;\n  public static reversePath = reversePath;\n  public static normalizePath = normalizePath;\n  public static transformPath = transformPath;\n  public static pathToAbsolute = pathToAbsolute;\n  public static pathToRelative = pathToRelative;\n  public static pathToCurve = pathToCurve;\n  public static pathToString = pathToString;\n  // declare class properties\n  declare segments: PathArray;\n  declare round: number | 'off';\n  declare origin: [number, number, number];\n\n  /**\n   * @constructor\n   * @param pathValue the path string\n   * @param config instance options\n   */\n  constructor(pathValue: string, config?: Partial<Options>) {\n    const instanceOptions = config || {};\n    const undefPath = typeof pathValue === 'undefined';\n\n    if (undefPath || !pathValue.length) {\n      throw TypeError(`${error}: \"pathValue\" is ${undefPath ? 'undefined' : 'empty'}`);\n    }\n\n    const segments = parsePathString(pathValue);\n    this.segments = segments;\n\n    // // set instance options.round\n    const { round: roundOption, origin: originOption } = instanceOptions;\n    let round: number | 'off';\n\n    if (Number.isInteger(roundOption) || roundOption === 'off') {\n      round = roundOption as number | 'off';\n    } else {\n      round = defaultOptions.round as number;\n    }\n\n    // set instance options.origin\n    // the SVGPathCommander class will always override the default origin\n    let origin = defaultOptions.origin as [number, number, number];\n    /* istanbul ignore else @preserve */\n    if (Array.isArray(originOption) && originOption.length >= 2) {\n      const [originX, originY, originZ] = originOption.map(Number);\n      origin = [\n        !Number.isNaN(originX) ? originX : 0,\n        !Number.isNaN(originY) ? originY : 0,\n        !Number.isNaN(originZ) ? originZ : 0,\n      ];\n    }\n\n    this.round = round;\n    this.origin = origin;\n\n    return this;\n  }\n  get bbox() {\n    return getPathBBox(this.segments);\n  }\n  get length() {\n    return getTotalLength(this.segments);\n  }\n\n  /**\n   * Returns the path bounding box, equivalent to native `path.getBBox()`.\n   *\n   * @public\n   * @returns the pathBBox\n   */\n  getBBox() {\n    return this.bbox;\n  }\n\n  /**\n   * Returns the total path length, equivalent to native `path.getTotalLength()`.\n   *\n   * @public\n   * @returns the path total length\n   */\n  getTotalLength() {\n    return this.length;\n  }\n\n  /**\n   * Returns an `{x,y}` point in the path stroke at a given length,\n   * equivalent to the native `path.getPointAtLength()`.\n   *\n   * @public\n   * @param length the length\n   * @returns the requested point\n   */\n  getPointAtLength(length: number) {\n    return getPointAtLength(this.segments, length);\n  }\n\n  /**\n   * Convert path to absolute values\n   *\n   * @public\n   */\n  toAbsolute() {\n    const { segments } = this;\n    this.segments = pathToAbsolute(segments);\n    return this;\n  }\n\n  /**\n   * Convert path to relative values\n   *\n   * @public\n   */\n  toRelative() {\n    const { segments } = this;\n    this.segments = pathToRelative(segments);\n    return this;\n  }\n\n  /**\n   * Convert path to cubic-bezier values. In addition, un-necessary `Z`\n   * segment is removed if previous segment extends to the `M` segment.\n   *\n   * @public\n   */\n  toCurve() {\n    const { segments } = this;\n    this.segments = pathToCurve(segments);\n    return this;\n  }\n\n  /**\n   * Reverse the order of the segments and their values.\n   *\n   * @param onlySubpath option to reverse all sub-paths except first\n   * @public\n   */\n  reverse(onlySubpath?: boolean) {\n    this.toAbsolute();\n\n    const { segments } = this;\n    const split = splitPath(segments);\n    const subPath = split.length > 1 ? split : false;\n\n    const absoluteMultiPath = subPath\n      ? subPath.map((x, i) => {\n          if (onlySubpath) {\n            return i ? reversePath(x) : x.slice(0);\n          }\n          return reversePath(x);\n        })\n      : segments.slice(0);\n\n    let path = [] as unknown as PathArray;\n    if (subPath) {\n      path = absoluteMultiPath.flat(1) as PathArray;\n    } else {\n      path = onlySubpath ? segments : reversePath(segments);\n    }\n\n    this.segments = path.slice(0) as PathArray;\n    return this;\n  }\n\n  /**\n   * Normalize path in 2 steps:\n   * * convert `pathArray`(s) to absolute values\n   * * convert shorthand notation to standard notation\n   *\n   * @public\n   */\n  normalize() {\n    const { segments } = this;\n    this.segments = normalizePath(segments);\n    return this;\n  }\n\n  /**\n   * Optimize `pathArray` values:\n   * * convert segments to absolute and/or relative values\n   * * select segments with shortest resulted string\n   * * round values to the specified `decimals` option value\n   *\n   * @public\n   */\n  optimize() {\n    const { segments } = this;\n\n    this.segments = optimizePath(segments, this.round);\n    return this;\n  }\n\n  /**\n   * Transform path using values from an `Object` defined as `transformObject`.\n   *\n   * @see TransformObject for a quick refference\n   *\n   * @param source a `transformObject`as described above\n   * @public\n   */\n  transform(source?: Partial<TransformObject>) {\n    if (\n      !source ||\n      typeof source !== 'object' ||\n      (typeof source === 'object' && !['translate', 'rotate', 'skew', 'scale'].some(x => x in source))\n    )\n      return this;\n\n    const {\n      segments,\n      origin: [cx, cy, cz],\n    } = this;\n    const transform = {} as TransformObjectValues;\n    for (const [k, v] of Object.entries(source) as TransformEntries) {\n      // istanbul ignore else @preserve\n      if (k === 'skew' && Array.isArray(v)) {\n        transform[k] = v.map(Number) as PointTuple;\n      } else if ((k === 'rotate' || k === 'translate' || k === 'origin' || k === 'scale') && Array.isArray(v)) {\n        transform[k] = v.map(Number) as [number, number, number];\n      } else if (k !== 'origin' && typeof Number(v) === 'number') transform[k] = Number(v);\n    }\n\n    // if origin is not specified\n    // it's important that we have one\n    const { origin } = transform;\n\n    if (Array.isArray(origin) && origin.length >= 2) {\n      const [originX, originY, originZ] = origin.map(Number);\n      transform.origin = [!Number.isNaN(originX) ? originX : cx, !Number.isNaN(originY) ? originY : cy, originZ || cz];\n    } else {\n      transform.origin = [cx, cy, cz];\n    }\n\n    this.segments = transformPath(segments, transform);\n    return this;\n  }\n\n  /**\n   * Rotate path 180deg vertically\n   *\n   * @public\n   */\n  flipX() {\n    const { cx, cy } = this.bbox;\n    this.transform({ rotate: [0, 180, 0], origin: [cx, cy, 0] });\n    return this;\n  }\n\n  /**\n   * Rotate path 180deg horizontally\n   *\n   * @public\n   */\n  flipY() {\n    const { cx, cy } = this.bbox;\n    this.transform({ rotate: [180, 0, 0], origin: [cx, cy, 0] });\n    return this;\n  }\n\n  /**\n   * Export the current path to be used\n   * for the `d` (description) attribute.\n   *\n   * @public\n   * @return the path string\n   */\n  toString() {\n    return pathToString(this.segments, this.round);\n  }\n}\n\nexport default SVGPathCommander;\n"],"names":["defaultOptions","error","paramsCount","finalizeSegment","path","pathCommand","LK","data","scanFlag","index","pathValue","code","isDigit","invalidPathValue","scanParam","max","start","zeroFirst","hasCeiling","hasDecimal","hasDot","ch","isSpace","skipSpaces","isPathCommand","isDigitStart","isArcCommand","isMoveCommand","scanSegment","_a","segments","cmdCode","reqParams","paramCounts","lastSegment","i","PathParser","pathString","parsePathString","pathInput","polygonArea","polygon","n","a","b","area","distanceSquareRoot","polygonLength","length","point","Z","z","s","e","p","$","E","P","y","g","r","l","m","h","c","f","w","o","d","A","M","X","O","x","Y","F","T","k","I","v","R","D","N","paramsParser","iterate","iterator","params","pathLen","segment","iteratorResult","seglen","absolutizeSegment","values","absCommand","absValues","j","normalizeSegment","px1","py1","px2","py2","x1","y1","qx","qy","nqx","nqy","midPoint","t","ax","ay","bx","by","getLineLength","x2","y2","getPointAtLineLength","distance","getLineBBox","min","ellipticalArcLength","rx","ry","theta","halfTheta","sinHalfTheta","cosHalfTheta","term1","term2","arcLength","arc","cx","cy","alpha","cos","sin","angleBetween","v0","v1","v0x","v0y","v1x","v1y","getArcProps","RX","RY","angle","LAF","SF","abs","sqrt","PI","xRotRad","dx","dy","transformedPoint","radiiCheck","cSquareNumerator","cSquareRootDenom","cRadicand","cCoef","transformedCenter","center","startVector","startAngle","endVector","sweepAngle","endAngle","getArcLength","getPointAtArcLength","ellipseComponentX","ellipseComponentY","getArcBBox","deltaAngle","extremes","tan","angle1","angle2","angle3","angle4","xArr","yArr","xMin","xMax","yMin","yMax","angleAfterStart","pP2","angleBeforeEnd","pP3","ZERO","Tvalues","Cvalues","derive","points","dpoints","list","compute","order","mt","mt2","t2","arcfn","derivativeFn","lengthFn","len","sum","curve","idx","step","CBEZIER_MINMAX_EPSILON","minmaxQ","minmaxC","K","S","L","Q","getPointAtCubicSegmentLength","c1x","c1y","c2x","c2y","t1","getCubicLength","getPointAtCubicLength","distanceIsNumber","currentLength","getCubicBBox","cxMinMax","cyMinMax","getPointAtQuadSegmentLength","getQuadLength","getPointAtQuadLength","getQuadBBox","getPathBBox","mx","my","MIN","MAX","seg","absoluteSegment","normalSegment","width","height","rotateVector","rad","arcToCubic","X1","Y1","X2","Y2","recursive","d120","res","xy","f1","f2","rx2","ry2","df","f2old","x2old","y2old","c1","s1","c2","s2","hx","hy","m1","m2","m3","m4","newres","ii","quadToCubic","r13","r23","lineToCubic","segmentToCubic","args","px","py","pathToCurve","absSegment","result","getCubicSegArea","getPathArea","getTotalLength","isM","totalLength","getDrawDirection","DISTANCE_EPSILON","getPointAtLength","POINT","getPropertiesAtLength","pathArray","pathTemp","pathLength","lengthAtSegment","normalizePath","getPropertiesAtPoint","normalPath","distanceTo","precision","scan","closest","scanDistance","bestLength","bestDistance","scanLength","before","after","beforeLength","afterLength","beforeDistance","afterDistance","getClosestPoint","getSegmentOfPoint","getSegmentAtLength","isPointInStroke","isValidPath","isPathArray","lk","isAbsoluteArray","isRelativeArray","pc","isNormalizedArray","isCurveArray","shapeParams","getLinePath","attr","getPolyPath","getCirclePath","getEllipsePath","getRectanglePath","shapeToPathArray","element","ownerDocument","win","supportedShapes","targetIsElement","tagName","type","shapeAttrs","config","roundPath","roundOption","round","pow","pathToString","shapeToPath","replace","doc","description","name","value","splitPath","composite","pi","relCommand","isRelative","getSVGMatrix","transform","matrix","CSSMatrix","origin","originX","originY","translate","rotate","skew","scale","pathToAbsolute","relativizeSegment","relValues","pathToRelative","resultedCommand","shortenSegment","prevCommand","round4","segmentValues","normalValues","optimizePath","allPathCommands","absolutePath","relativePath","reverseCurve","rotatedCurve","curveOnly","_","reversePath","isClosed","reversedPath","prevSeg","nextSeg","pLen","translatePoint","cssm","projection2d","point2D","originZ","relativePositionX","relativePositionY","relativePositionZ","transformPath","lx","ly","jj","nx","ny","transformParams","transformProps","matrixInstance","isLongArc","normalizedSegment","splitCubic","pts","ratio","p0","p1","p2","p3","p4","p5","p6","p7","p8","p9","SVGPathCommander","instanceOptions","undefPath","originOption","onlySubpath","split","subPath","absoluteMultiPath","source","cz","__publicField"],"mappings":"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","x_google_ignoreList":[20]}